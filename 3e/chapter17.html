<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">







<div type="bodymatter" class="calibre" id="calibre_link-455">
<section type="chapter" role="doc-chapter" aria-labelledby="ch17">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-966" aria-label="411"></span>
<hgroup>
<h2 class="title" id="calibre_link-1923">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">17</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">PDFとWord文書</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">PDFとWordはテキストを保存する形式だと思われるかもしれませんが、フォントや色やレイアウトの情報を含むバイナリファイルです。そのため、単純なプレーンテキストファイルよりもずっと複雑です。ファイル名を<span class="sans_thesansmonocd_w5regular_">open()</span>に渡すだけでは、プログラムからPDFやWordの読み書きはできません。幸い、PDFやWordの読み書きを簡単にしてくれるPythonのパッケージが存在します。本章では、そのようなパッケージのうち、PyPDFとPython-Docxを紹介します。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1924"><span id="calibre_link-456"></span><span class="sans_futura_std_bold_b_">PDF文書</span></h3>
<p class="tni"><i class="calibre5">PDF</i>は<i class="calibre5">Portable Document Format（持ち運び可能な文書フォーマット）</i>を表しファイル拡張子は<i class="calibre5">.pdf</i>です。PDFにはたくさんの機能がありますが、この節では、テキストの抽出、画像の抽出、既存のPDFファイルから新しいPDFファイル作成の、3つのよくある作業に絞ります。</p>
<p class="tx">PyPDFはPDFファイルの作成と変更を行うためのPythonパッケージです。<span>付録A</span>の指示に従ってインストールしてください。パッケージが正しくインストールされたら、対話型シェルで<span class="thesansmonocd_w5regular_">import pypdf</span>を実行したときにエラーは表示されません。</p>
<p class="tx">PDFファイルは印刷用や閲覧用にテキストをレイアウトするのに適していますが、プレーンテキストへと解析するのは簡単ではありません。そのため、PyPDFはPDFからテキストを抽出する際に間違えることがありますし、PDFを開くことさえできない場合もあります。こうなるとどうしようもありません。PyPDFは一部のファイルについては機能しません。とは言うものの、個人的にはPyPDFが開けないPDFファイルに遭遇したことはないです。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1925"><span id="calibre_link-457"></span><span class="sans_futura_std_heavy_oblique_bi_">テキストの抽出</span></h4>
<p class="tni">PyPDFで作業を行うのに、再帰的アルゴリズムについての私の本<i class="calibre5">The Recursive Book of Recursion</i> (No Starch Press, 2022)から抜粋したサンプルのPDF（図17-1）を使ってください。</p>
<figure class="img"><img class="img2" id="calibre_link-782" src="images/000036.jpg" alt="A PDF showing the beginning of a book chapter called “What Is Recursion?”" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-1：テキストを抽出するサンプルのPDFファイル</span></p></figcaption>
</figure>
<p class="tx">この<i class="calibre5">Recursion_Chapter1.pdf</i>ファイルを<i class="calibre5"><a href="https://nostarch.com/automate-boring-stuff-python-3rd-edition" class="calibre1">https://<wbr></wbr>nostarch<wbr></wbr>.com<wbr></wbr>/automate<wbr></wbr>-boring<wbr></wbr>-stuff<wbr></wbr>-python<wbr></wbr>-3rd<wbr></wbr>-edition</a></i>のオンライン素材からダウンロードし、対話型シェルに以下の内容を入力してください。</p>
<pre class="pre"><code class="calibre9"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-894" aria-label="413"></span>&gt;&gt;&gt; <b class="calibre10">import pypdf</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">reader = pypdf.PdfReader('Recursion_Chapter1.pdf')</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">len(reader.pages)</b>
18
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">pypdf</span>モジュールをインポートしてから、PDFのファイル名を渡して<span class="thesansmonocd_w5regular_">pypdf.PdfReader()</span>を呼び出し、PDFを表す<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトを取得します(<span class="codeannotation" aria-label="annotation1">❶</span>)。このオブジェクトを<span class="thesansmonocd_w5regular_">reader</span>という名前の変数に保存します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトのpages属性は、PDFの個々のページを表す<span class="thesansmonocd_w5regular_">Page</span>オブジェクトのリストのようなデータ構造をしています。Pythonのリストと同じように、このデータ構造を<span class="thesansmonocd_w5regular_">len()</span>関数に渡せます(<span class="codeannotation" aria-label="annotation2">❷</span>)。このサンプルのPDFは18ページです。</p>
<p class="tx">このPDFからテキストを抽出してテキストファイルに出力するには、新しいファイルエディタタブを開いて以下のコードを<i class="calibre5">extractpdftext.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import pypdf
import pdfminer.high_level

PDF_FILENAME = 'Recursion_Chapter1.pdf'
TEXT_FILENAME = 'recursion.txt'

text = ''
try:
    reader = pypdf.PdfReader(PDF_FILENAME)
  <span class="code_codeannotation" aria-label="annotation1">❶</span> for page in reader.pages:
      <span class="code_codeannotation" aria-label="annotation2">❷</span> text += page.extract_text()
except Exception:
  <span class="code_codeannotation" aria-label="annotation3">❸</span> text = pdfminer.high_level.extract_text(PDF_FILENAME)
with open(TEXT_FILENAME, 'w', encoding='utf-8') as file_obj:
  <span class="code_codeannotation" aria-label="annotation4">❹</span> file_obj.write(text)
</code></pre>
<p class="tx">テキストの抽出に<span class="thesansmonocd_w5regular_">pypdf</span>モジュールを使いますが、そのモジュールでうまくいかないPDFファイルについては例外を送出し、<span class="thesansmonocd_w5regular_">pdfminer</span>モジュールに委ねます。<span class="thesansmonocd_w5regular_">try</span>ブロック内では、<span class="thesansmonocd_w5regular_">for</span>ループ(<span class="codeannotation" aria-label="annotation1">❶</span>)でPDFファイルの<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトの<span class="thesansmonocd_w5regular_">Page</span>オブジェクトを反復処理します。<span class="thesansmonocd_w5regular_">Page</span>オブジェクトの<span class="thesansmonocd_w5regular_">extract_text()</span>メソッドを呼び出すと文字列が返されるので、それを変数<span class="thesansmonocd_w5regular_">text</span>に結合します(<span class="codeannotation" aria-label="annotation2">❷</span>)。ループが終われば、<span class="thesansmonocd_w5regular_">text</span>にはPDFの全テキストが一つの文字列として含まれます。</p>
<p class="tx">PDFファイルが一般的なフォーマットではなくPyPDFで読み取れなければ、<span class="thesansmonocd_w5regular_">pdfminer.high_level</span>という、本書のサードパーティーパッケージに含まれている古いモジュールを使います。このモジュールの<span class="thesansmonocd_w5regular_">extract_text()</span>関数は、ページごとに処理するのではなく、PDFの内容を一つの文字列として取得します(<span class="codeannotation" aria-label="annotation3">❸</span>)。</p>
<p class="tx">最後に、<span>第10章</span>で紹介した<span class="thesansmonocd_w5regular_">open()</span>関数と<span class="thesansmonocd_w5regular_">write()</span>メソッドでその文字列をテキストファイルに書き込みます(<span class="codeannotation" aria-label="annotation4">❹</span>)。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h4 class="h1" id="calibre_link-1926"><span id="calibre_link-458"></span><span class="sans_futura_std_heavy_oblique_bi_">AIによる後処理</span></h4>
<p class="tni">先ほど行ったテキスト抽出は完璧ではありません。PDFファイルのフォーマットは複雑であり、印刷のために設計されたものであって、機械が読めるようには設計されていません。抽出に問題がなかったとしても、テキストのレイアウトが固定されています。テキストの各行末には改行記号が含まれますし、単語が行をまたぐときのハイフンが残ります。例えば、先ほどのサンプルのPDFから抽出したテキストは、以下のとおりです。</p>
<pre class="pre"><code class="calibre9">1
WHAT IS RECURSION?
Recursion has an intimidating reputation.
It's considered hard to understand, but
at its core, it depends on only two things:
 function calls and stack data structures.
Most new programmers trace through what a program does by follow -
ing the execution. It's an easy way to read code: you just put your finger
<var class="calibre20">--snip--</var>
</code></pre>
<p class="tx">ご覧のとおり、主観的に判断して処理しなければならない箇所がたくさんあります。</p>
<ul class="ul">
<li class="bl">PDFの段落はどこで始まりどこで終わるか</li>
<li class="bl">ページ番号、ヘッダー、フッターを抽出したテキストに含めるかどうか</li>
<li class="bl">PDFのデータ表をどのようにテキスト化するか</li>
<li class="bl">抽出したテキストにスペースをどれだけ入れるか</li>
</ul>
<p class="tx">このテキストを整形するのは退屈な作業ですが、コードで簡単に自動化することはできません。しかし、ChatGPTなどの大規模言語モデル（LLM）のAIは、テキストの文脈を理解し、自動的に整形してくれます。抽出したテキストについて以下のプロンプトを使ってください。</p>
<p class="blockquote">以下のテキストは、再帰的アルゴリズムについての本のPDFを数ページ抽出したものです。このテキストを整形してください。段落を一行でまとめ、各ページのヘッダーとフッターを除去してください。また、単語が行をまたぐときにつけられたハイフンを取り除いてください。スペルや文法の修正はせず、言い換えをしないでください。テキストは以下です。</p>
<p class="tx">このプロンプトを試してみると、整形されて以下のテキストになりました。</p>
<pre class="pre"><code class="calibre9">WHAT IS RECURSION?

Recursion has an intimidating reputation. It's considered hard
to understand, but at its core, it depends on only two things:
function calls and stack data structures. Most new programmers
trace through what a program does by following the execution.
It's an easy way to read code: you just put your finger...
</code></pre>
<p class="tx">AIを使うときは必ず人間が出力をレビューしてください。例えば、LLMはテキストの冒頭の章番号の<span class="thesansmonocd_w5regular_">1</span>を消してしまいました。これは私の意図に反しています。意図が誤解されないようにプロンプトを洗練させる余地があると思います。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1135" aria-label="415"></span>LLMを利用できなければ、コード例つきで後処理のコツを示したPyPDFのドキュメント（<i class="calibre5"><a href="https://pypdf.readthedocs.io/en/latest/user/post-processing-in-text-extraction.html" class="calibre1">https://<wbr></wbr>pypdf<wbr></wbr>.readthedocs<wbr></wbr>.io<wbr></wbr>/en<wbr></wbr>/latest<wbr></wbr>/user<wbr></wbr>/post<wbr></wbr>-processing<wbr></wbr>-in<wbr></wbr>-text<wbr></wbr>-extraction<wbr></wbr>.html</a></i>）を参照してください。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1927"><span id="calibre_link-459"></span><span class="sans_futura_std_heavy_oblique_bi_">画像の抽出</span></h4>
<p class="tni">PyPDFではPDF文書から画像を抽出することもできます。各<span class="thesansmonocd_w5regular_">Page</span>オブジェクトには<span class="thesansmonocd_w5regular_">images</span>属性があり、そこに<span class="thesansmonocd_w5regular_">Image</span>オブジェクトがリストのようなデータ構造で含まれています。その<span class="thesansmonocd_w5regular_">Image</span>オブジェクトのバイトを<span class="thesansmonocd_w5regular_">'wb'</span>（バイナリ書き込み）モードで開いた画像ファイルに書き込めます。<span class="thesansmonocd_w5regular_">Image</span>オブジェクトには<span class="thesansmonocd_w5regular_">name</span>属性があり、画像の名前の文字列が入っています。以下はサンプルのPDFのすべてのページから画像を抽出するコードです。新しいファイルエディタタブを開いて<i class="calibre5">extractpdfimages.py</i>という名前でコードを保存してください。</p>
<pre class="pre"><code class="calibre9">import pypdf
PDF_FILENAME = 'Recursion_Chapter1.pdf'

reader = pypdf.PdfReader(PDF_FILENAME)
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> image_num = 0
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> for i, page in enumerate(reader.pages):
    print(f'Reading page {i+1} - {len(page.images)} images found...')
    try:
      <span class="code_codeannotation" aria-label="annotation3">❸</span> for image in page.images:
          <span class="code_codeannotation" aria-label="annotation4">❹</span> with open(f'{image_num}_page{i+1}_{image.name}', 'wb') as file:
              <span class="code_codeannotation" aria-label="annotation5">❺</span> file.write(image.data)
            print(f'Wrote {image_num}_page{i+1}_{image.name}...')
          <span class="code_codeannotation" aria-label="annotation6">❻</span> image_num += 1
    except Exception as exc:
      <span class="code_codeannotation" aria-label="annotation7">❼</span> print(f'Skipped page {i+1} due to error: {exc}')
</code></pre>
<p class="tx">このプログラムの出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">Reading page 1 - 7 images found...
Wrote 0_page1_Im0.jpg...
Wrote 1_page1_Im1.png...
<var class="calibre20">--snip--</var>
Reading page 7 - 1 images found...
Skipped page 7 due to error: not enough image data
<var class="calibre20">--snip--</var>
Reading page 17 - 0 images found...
Reading page 18 - 0 images found...
</code></pre>
<p class="tx">PDF文書の画像には、<i class="calibre5">Im0.jpg</i>、<i class="calibre5">Im1.png</i>といった一般的な名前がつけられます。<span class="thesansmonocd_w5regular_">image_num</span>という名前のカウンター変数(<span class="codeannotation" aria-label="annotation1">❶</span>)とページ番号を名前に付加して一意の名前にします。まず、<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトの<span class="thesansmonocd_w5regular_">pages</span>属性の<span class="thesansmonocd_w5regular_">Page</span>オブジェクトを反復処理します。Pythonの<span class="thesansmonocd_w5regular_">enumerate()</span>関数(<span class="codeannotation" aria-label="annotation2">❷</span>)は整数のインデックスとリスト的なオブジェクトの要素を返すことを思い出してください。各<span class="thesansmonocd_w5regular_">Page</span>オブジェクトには<span class="thesansmonocd_w5regular_">images</span>オブジェクトがあり、これも反復処理します(<span class="codeannotation" aria-label="annotation3">❸</span>)。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">images</span>属性の<span class="thesansmonocd_w5regular_">Image</span>オブジェクトを反復処理する、入れ子の内側の<span class="thesansmonocd_w5regular_">for</span>ループでは、<span class="thesansmonocd_w5regular_">open()</span>を呼び出してf文字列でファイル名を指定しています(<span class="codeannotation" aria-label="annotation4">❹</span>)。このファイル名は、<span class="thesansmonocd_w5regular_">image_num</span>カウンターの整数、ページ番号、<span class="thesansmonocd_w5regular_">Image</span>オブジェクトの<span class="thesansmonocd_w5regular_">name</span>属性の文字列の3つから構成されています。PDFのページ番号は1から始まりますが<span class="thesansmonocd_w5regular_">i</span>は<span class="thesansmonocd_w5regular_">0</span>から始まるので、<span class="thesansmonocd_w5regular_">i+1</span>でページ番号にしています。この名前は<i class="calibre5">.png</i>や<i class="calibre5">.jpg</i>のファイル拡張子を含んでいます。<span class="thesansmonocd_w5regular_">open()</span>関数に<span class="thesansmonocd_w5regular_">'wb'</span>を渡してバイナリ書き込みモードで開きます。画像ファイルのバイトは<span class="thesansmonocd_w5regular_">Image</span>オブジェクトの<span class="thesansmonocd_w5regular_">data</span>属性に格納されているので、これを<span class="thesansmonocd_w5regular_">write()</span>メソッドに渡します(<span class="codeannotation" aria-label="annotation5">❺</span>)。画像の書き込み後は<span class="thesansmonocd_w5regular_">image_num</span>を<span class="thesansmonocd_w5regular_">1</span>増やします(<span class="codeannotation" aria-label="annotation6">❻</span>)。</p>
<p class="tx">PDFファイルとPyPDFとの間に互換性がなければ、<span class="thesansmonocd_w5regular_">Page</span>オブジェクトの<span class="thesansmonocd_w5regular_">images</span>属性は例外を送出します。<span class="thesansmonocd_w5regular_">try</span>文と<span class="thesansmonocd_w5regular_">except</span>文でその例外を捕捉し、短いエラーメッセージを表示します(<span class="codeannotation" aria-label="annotation7">❼</span>)。このようにして、あるページで問題が発生してもプログラム全体がクラッシュしないようにしています。</p>
<p class="tx">テキスト抽出と同様に、画像抽出も不完全です。例えば、PyPDFはサンプルのPDFファイルの画像をすべて検知できておらず、エラーメッセージが表示されます。他方で、意外なことに、PyPDFが背景やスペースの小さな空白の画像を抽出しています。PDFに関する作業を行う際は、出力が正しいかどうか人間が確認しなければなりません。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1928"><span id="calibre_link-460"></span><span class="sans_futura_std_heavy_oblique_bi_">他のページからのPDFの作成</span></h4>
<p class="tni">PyPDFには<span class="thesansmonocd_w5regular_">PdfReader</span>と対になる<span class="thesansmonocd_w5regular_">PdfWriter</span>があり、これを使って新しいPDFファイルを作成できます。しかし、PyPDFでは、Pythonが任意のテキストをプレーンテキストに書き込めるようにテキストを自由にPDFに書き込むことはできません。PyPDFのPDF書き込み機能は、他のPDFファイルを利用した、コピー、挿入、除去、変形に限られています。以下の対話型シェルのコードを実行すると、サンプルのPDFの最初の5ページだけがコピーされた新しいPDFファイルが作成されます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pypdf</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">writer = pypdf.PdfWriter()</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">writer.append('Recursion_Chapter1.pdf', (0, 5))</b>
&gt;&gt;&gt; <b class="calibre10">with open('first_five_pages.pdf', 'wb') as file:</b>
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> ...     <b class="calibre10">writer.write(file)</b>
...
(False, &lt;_io.BufferedWriter name='first_five_pages.pdf'&gt;)
</code></pre>
<p class="tx">まず、<span class="thesansmonocd_w5regular_">pypdf.PdfWriter()</span>を呼び出して<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトを作成します(<span class="codeannotation" aria-label="annotation1">❶</span>)。<span class="thesansmonocd_w5regular_">writer</span>変数に格納された<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトは0ページの空白のPDFを表します。次に、<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの<span class="thesansmonocd_w5regular_">append()</span>メソッドで<span class="thesansmonocd_w5regular_">'Recursion_Chapter1.pdf'</span>というファイル名を指定し、サンプルのPDFの最初の5ページをコピーします(<span class="codeannotation" aria-label="annotation2">❷</span>)。（同名ではありますが<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの<span class="thesansmonocd_w5regular_">append()</span>メソッドはリストメソッドの<span class="thesansmonocd_w5regular_">append()</span>とは異なります。）</p>
<p class="tx">このメソッドの第二引数はタプル<span class="thesansmonocd_w5regular_">(0, 5)</span>です。<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトにインデックス<span class="thesansmonocd_w5regular_">0</span>のページ（<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの最初のページ）からインデックス<span class="thesansmonocd_w5regular_">5</span>のページまで（インデックス<span class="thesansmonocd_w5regular_">5</span>のページは含まない）をコピーすることを伝えます。PDFアプリケーションでは最初のページを1ページと表示しますが、PyPDFは<span class="thesansmonocd_w5regular_">0</span>で最初のページを表します。</p>
<p class="tx">最後に、ファイル名と<span class="thesansmonocd_w5regular_">'wb'</span>モードを指定して<span class="thesansmonocd_w5regular_">open()</span>を呼び出し、<span class="thesansmonocd_w5regular_">File</span>オブジェクトの<span class="thesansmonocd_w5regular_">write()</span>メソッドにその<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトを渡して、<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの内容をPDFに書き込みます(<span class="codeannotation" aria-label="annotation3">❸</span>)。これで新しいPDFファイルが作成されます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1234" aria-label="417"></span><span class="thesansmonocd_w5regular_">append()</span>に渡すタプルには2つまたは3つの整数が含まれます。3つの整数が含まれる場合は、3番目の数値がステップ数を表します。これは<span class="thesansmonocd_w5regular_">range()</span>関数と同じですから、<span class="thesansmonocd_w5regular_">list(range())</span>に2つまたは3つの整数を渡すことで、どのページがコピーされるかわかります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">list(range(0, 5))</b>  # (0, 5)を渡すとappend()はこのページをコピーする
[0, 1, 2, 3, 4]
&gt;&gt;&gt; <b class="calibre10">list(range(0, 5, 2))</b>  # (0, 5, 2)を渡すとappend()はこのページをコピーする
[0, 2, 4]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">append()</span>メソッドはコピーするページ番号の整数のリストを取ることもできます。例えば、先ほどの対話型シェルの例を、次のように書くことができます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">writer.append('Recursion_Chapter1.pdf', [0, 1, 2, 3, 4])</b></code></pre>
<p class="tx">このコードもPDF文書の最初の5ページを<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトにコピーします。<span class="thesansmonocd_w5regular_">append()</span>は引数のタプルとリストを異なるように解釈することに注意してください。タプル<span class="thesansmonocd_w5regular_">(0, 5)</span>はインデックス<span class="thesansmonocd_w5regular_">0</span>からインデックス<span class="thesansmonocd_w5regular_">5</span>まで（インデックス<span class="thesansmonocd_w5regular_">5</span>は含まない）をコピーするのに対し、リスト<span class="thesansmonocd_w5regular_">[0, 5]</span>はインデックス<span class="thesansmonocd_w5regular_">0</span>とインデックス<span class="thesansmonocd_w5regular_">5</span>のページをコピーします。タプルとリストでこのような意味の違いを持たせるのは慣習的ではなく、他のPythonのライブラリで目にすることはないでしょうが、PyPDFではそのように設計されています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">append()</span>メソッドはコピーしたページを<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの末尾に追加します。コピーしたページを末尾以外に挿入したい場合は、<span class="thesansmonocd_w5regular_">merge()</span>メソッドを呼び出します。<span class="thesansmonocd_w5regular_">merge()</span>メソッドは、挿入するページを指定するもう一つ引数を取ります。例えば、次のようにします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">writer.merge(2, 'Recursion_Chapter1.pdf', (0, 5))</b></code></pre>
<p class="tx">このコードはインデックス<span class="thesansmonocd_w5regular_">0</span>からインデックス<span class="thesansmonocd_w5regular_">5</span>（インデックス<span class="thesansmonocd_w5regular_">5</span>は含まない）をコピーし、<span class="thesansmonocd_w5regular_">writer</span>変数に格納された<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトのインデックス<span class="thesansmonocd_w5regular_">2</span>のページ（3ページ目）に挿入します。元のインデックス<span class="thesansmonocd_w5regular_">2</span>のページ以降は、コピーされたページのあとに繰り下がります。</p>
<section type="division" aria-labelledby="sec6">
<h5 class="h2" id="calibre_link-1929"><span class="sans_futura_std_bold_b_">ページの回転</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">Page</span>オブジェクトの<span class="thesansmonocd_w5regular_">rotate()</span>メソッドで、PDFのページを90度ずつ回転させることもできます。時計回りに回転させるなら<span class="thesansmonocd_w5regular_">90</span>、<span class="thesansmonocd_w5regular_">180</span>、<span class="thesansmonocd_w5regular_">270</span>を、反時計回りに回転させるなら<span class="thesansmonocd_w5regular_">-90</span>、<span class="thesansmonocd_w5regular_">-180</span>、<span class="thesansmonocd_w5regular_">-270</span>を、このメソッドの引数に渡します。たくさんのPDFがあり、理由はともかく向きが正しくないので回転させたいとしたら、このページの回転が役に立ちます。PDF文書の一部のページだけを回転させることもできます。PDFアプリにも回転機能があり、手動でPDFの向きを正しくすることができますが、PythonだとたくさんのPDFを回転させて面倒な作業を自動化できます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1291" aria-label="418"></span>例えば、対話型シェルに以下の内容を入力して、サンプルのPDFを回転させてみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pypdf</b>
&gt;&gt;&gt; <b class="calibre10">writer = pypdf.PdfWriter()</b>
&gt;&gt;&gt; <b class="calibre10">writer.append('Recursion_Chapter1.pdf')</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">for i in range(len(writer.pages)):</b>
...   <span class="code_codeannotation" aria-label="annotation2">❷</span> <b class="calibre10">writer.pages[i].rotate(90)</b>
...
{'/ArtBox': [21, 21, 525, 687], '/BleedBox': [12, 12, 534, 696],
<var class="calibre20">--snip--</var>

&gt;&gt;&gt; <b class="calibre10">with open('rotated.pdf', 'wb') as file:</b>
...     <b class="calibre10">writer.write(file)</b>
...
(False, &lt;_io.BufferedWriter name='rotated.pdf'&gt;)
</code></pre>
<p class="tx">新しい<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトを作成して、サンプルのPDFのページをコピーします。それから、<span class="thesansmonocd_w5regular_">for</span>ループで各ページを反復処理します。<span class="thesansmonocd_w5regular_">len(writer.pages)</span>を呼び出すとページ数が整数で返されます(<span class="codeannotation" aria-label="annotation1">❶</span>)。式<span class="thesansmonocd_w5regular_">writer.pages[i]</span>で<span class="thesansmonocd_w5regular_">for</span>ループの反復ごとに<span class="thesansmonocd_w5regular_">Page</span>オブジェクトにアクセスし、<span class="thesansmonocd_w5regular_">rotate(90)</span>メソッド呼び出しにより<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの当該ページを回転させます(<span class="codeannotation" aria-label="annotation2">❷</span>)。</p>
<p class="tx">結果として出力されるPDFは、図17-2に示すように、すべてのページが時計回りに90度回転しています。</p>
<figure class="img"><img class="img1" id="calibre_link-787" src="images/000038.jpg" alt="The “What Is Recursion?” PDF oriented horizontally, so the text is sideways." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-2：ページを時計回りに90度回転させた</span><span class="sans_futura_std_book_">rotated.pdf</span><span class="sans_futura_std_book_oblique_i_">ファイル</span></p></figcaption>
</figure>
<p class="tx">PyPDFは90度の整数倍でしか回転させられません。</p>
</section>
<section type="division" aria-labelledby="sec7">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-884" aria-label="419"></span>
<h5 class="h2" id="calibre_link-1930"><span class="sans_futura_std_bold_b_">空白ページの挿入</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">insert _blank_page()</span>メソッドと<span class="thesansmonocd_w5regular_">add_blank_page()</span>メソッドで、<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトに空白ページを挿入したり追加したりできます。新しいページの大きさは前のページの大きさと同じになります。例えば、サンプルのPDFのコピーを作成して、末尾と3ページのあとに空白ページを挿入してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pypdf</b>
&gt;&gt;&gt; <b class="calibre10">writer = pypdf.PdfWriter()</b>
&gt;&gt;&gt; <b class="calibre10">writer.append('Recursion_Chapter1.pdf')</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">writer.add_blank_page()</b>
{'/Type': '/Page', '/Resources': {}, '/MediaBox': [0.0, 0.0,
546, 708], '/Parent': IndirectObject(1, 0, 2629126028624)}
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">writer.insert_blank_page(index=2)</b>
{'/Type': '/Page', '/Parent': NullObject, '/Resources': {},
'/MediaBox': RectangleObject([0.0, 0.0, 546, 708])}
&gt;&gt;&gt; <b class="calibre10">with open('with_blanks.pdf', 'wb') as file:</b>
...     <b class="calibre10">writer.write(file)</b>  # writerオブジェクトをPDFファイルに保存
...
(False, &lt;_io.BufferedWriter name='with_blanks.pdf'&gt;)
</code></pre>
<p class="tx">サンプルのPDFからすべてのページを<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトにコピーしてから、<span class="thesansmonocd_w5regular_">add_blank_page()</span>メソッドで空白ページを末尾に追加します。<span class="thesansmonocd_w5regular_">insert_blank_page()</span>メソッドでインデックス<span class="thesansmonocd_w5regular_">2</span>のページのあと（インデックスは<span class="thesansmonocd_w5regular_">0</span>から始まるので3ページ目のあと）に空白ページを挿入します。このメソッドでは<span class="thesansmonocd_w5regular_">index</span>名前付きパラメータを指定します。</p>
<p class="tx">このページを空白のままにしておくこともできれば、次の節で説明するように、あとで重ね合わせたり透かしを入れたりすることもできます。</p>
</section>
<section type="division" aria-labelledby="sec8">
<h5 class="h2" id="calibre_link-1931"><span class="sans_futura_std_bold_b_">透かしと重ね合わせ</span></h5>
<p class="tni">PyPDFでは、あるページを別のページに重ね合わせることができます。ページにロゴやタイムスタンプや透かしを入れたりするのに便利です。<i class="calibre5">スタンプ</i>や<i class="calibre5">オーバーレイ</i>はページの既存の内容の上に重ね、<i class="calibre5">透かし</i>や<i class="calibre5">アンダーレイ</i>はページの既存の内容の下に重ねます。</p>
<p class="tx">本書のオンライン素材から<i class="calibre5">watermark.pdf</i>をダウンロードして、サンプルのPDFと同じ現在の作業ディレクトリの中に入れてください。そして、対話型シェルに次のように入力します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pypdf</b>
&gt;&gt;&gt; <b class="calibre10">writer = pypdf.PdfWriter()</b>
&gt;&gt;&gt; <b class="calibre10">writer.append('Recursion_Chapter1.pdf')</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">watermark_page = pypdf.PdfReader('watermark.pdf').pages[0]</b>
&gt;&gt;&gt; <b class="calibre10">for page in writer.pages:</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> ...     <b class="calibre10">page.merge_page(watermark_page, over=False)</b>
...
&gt;&gt;&gt; <b class="calibre10">with open('with_watermark.pdf', 'wb') as file:</b>
...     <b class="calibre10">writer.write(file)</b>
...
(False, &lt;_io.BufferedWriter name='with_watermark.pdf'&gt;)
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-892" aria-label="420"></span>この例では、新しい<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトにサンプルのPDFのコピーを作成し、変数<span class="thesansmonocd_w5regular_">writer</span>に格納します。透かしのPDFの最初のページの<span class="thesansmonocd_w5regular_">Page</span>オブジェクトも取得し、変数<span class="thesansmonocd_w5regular_">watermark_page</span>に格納します。<span class="thesansmonocd_w5regular_">for</span>ループで<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの<span class="thesansmonocd_w5regular_">Page</span>オブジェクトを反復処理し、<span class="thesansmonocd_w5regular_">merge_page()</span>で透かしを入れます。（<span class="thesansmonocd_w5regular_">Page</span>オブジェクトの<span class="thesansmonocd_w5regular_">merge_page()</span>メソッドを、本章の最初のほうで紹介した<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの<span class="thesansmonocd_w5regular_">merge()</span>メソッドと混同しないようにしてください。）</p>
<p class="tx"><span class="thesansmonocd_w5regular_">merge_page()</span>メソッドには<span class="thesansmonocd_w5regular_">over</span>キーワード引数があります。この引数に<span class="thesansmonocd_w5regular_">True</span>を渡すとスタンプ（オーバーレイ）になり、<span class="thesansmonocd_w5regular_">False</span>を渡すと透かし（アンダーレイ）になります。</p>
<p class="tx">ループで<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトのページを処理してから、<i class="calibre5">with_watermark.pdf</i>という名前で保存しています。図17-3は元の透かしのPDFと、透かしを入れたサンプルのPDFから2ページを示しています。</p>
<figure class="img"><img class="img1" id="calibre_link-789" src="images/000039.jpg" alt="Three PDFs. The first contains a diagonal gray box with the text “Top Secret”, the second shows the “Top Secret” box overlayed on the “What Is Recursion?” chapter page, and the third shows the “Top Secret” boxed overlayed on another page of text." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-3：透かしのPDF（左側）と透かしを入れたページ（中央と右側）</span></p></figcaption>
</figure>
<p class="tx">2つのページを重ね合わせるなど、PDFに大きな変更を加えたいときに<span class="thesansmonocd_w5regular_">merge_page()</span>メソッドが役立ちます。</p>
</section>
<section type="division" aria-labelledby="sec9">
<h5 class="h2" id="calibre_link-1932"><span class="sans_futura_std_bold_b_">PDFの暗号化と復号</span></h5>
<p class="tni">PDFは内容を暗号化して読めなくできます。暗号化はパスワードにより強度が変わりますから、いろいろな記号を使って辞書に載っていない14から16文字くらいのパスワードを設定します。PDFにはパスワードリセット機能がありませんから、パスワードを失念するとパスワードを当てられない限り永久に読めなくなることに注意してください。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトの<span class="thesansmonocd_w5regular_">encrypt()</span>メソッドは、パスワード文字列と暗号化アルゴリズムの2つを引数に取ります。<span class="thesansmonocd_w5regular_">'AES-256'</span>が推奨される新しい暗号化アルゴリズムなので、ここではそれを使います。対話型シェルに以下の内容を入力し、サンプルのPDFの暗号化されたコピーを作成してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pypdf</b>
&gt;&gt;&gt; <b class="calibre10">writer = pypdf.PdfWriter()</b>
&gt;&gt;&gt; <b class="calibre10">writer.append('Recursion_Chapter1.pdf')</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1098" aria-label="421"></span>&gt;&gt;&gt; <b class="calibre10">writer.encrypt('swordfish', algorithm='AES-256')</b>
&gt;&gt;&gt; <b class="calibre10">with open('encrypted.pdf', 'wb') as file:</b>
...     <b class="calibre10">writer.write(file)</b>
...
(False, &lt;_io.BufferedWriter name='encrypted.pdf'&gt;)
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトについて<span class="thesansmonocd_w5regular_">encrypt('swordfish', algorithm='AES-256')</span>メソッドを呼び出すことで、そのPDFの内容を暗号化しています。この暗号化されたPDFを<i class="calibre5">encrypted.pdf</i>ファイルに書き出したら、PyPDFを含めてどのようなPDFアプリでもパスワードの<i class="calibre5">swordfish</i>を入力しない限りそのファイルを開くことができません。（これは辞書に載っている語なのでまずいパスワードで、簡単に推測できます。）暗号化されたデータは、正しいパスワードで復号しなければランダムに見えます。正しくないパスワードで復号してもデータは使い物にならず、PDFアプリはパスワードをもう一度入力するように要求します。</p>
<p class="tx">PyPDFは暗号化されたPDFをパスワードで復号できます。対話型シェルに以下の内容を入力して、<span class="thesansmonocd_w5regular_">is_encrypted</span>属性でそのPDFが暗号化されているかどうかを判定し、<span class="thesansmonocd_w5regular_">decrypt()</span>で復号します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pypdf</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">reader = pypdf.PdfReader('encrypted.pdf')</b>
&gt;&gt;&gt; <b class="calibre10">writer = pypdf.PdfWriter()</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">reader.is_encrypted</b>
True
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> &gt;&gt;&gt; <b class="calibre10">reader.pages[0]</b>
Traceback (most recent call last):
<var class="calibre20">--snip--</var>
pypdf.errors.FileNotDecryptedError: File has not been decrypted
<span class="codeannotated_codeannotation" aria-label="annotation4">❹</span> &gt;&gt;&gt; <b class="calibre10">reader.decrypt('an incorrect password').name</b>
'NOT_DECRYPTED'
<span class="codeannotated_codeannotation" aria-label="annotation5">❺</span> &gt;&gt;&gt; <b class="calibre10">reader.decrypt('swordfish').name</b>
'OWNER_PASSWORD'
<span class="codeannotated_codeannotation" aria-label="annotation6">❻</span> &gt;&gt;&gt; <b class="calibre10">writer.append(reader)</b>
&gt;&gt;&gt; <b class="calibre10">with open('decrypted.pdf', 'wb') as file:</b>
...     <b class="calibre10">writer.write(file)</b>
...
(False, &lt;_io.BufferedWriter name='decrypted.pdf'&gt;)
</code></pre>
<p class="tx">これまでのPDFと同じように、暗号化されたPDFを<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトにロードしています(<span class="codeannotation" aria-label="annotation1">❶</span>)。<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトには<span class="thesansmonocd_w5regular_">is_encrypted</span>属性があり、<span class="thesansmonocd_w5regular_">True</span>または<span class="thesansmonocd_w5regular_">False</span>が設定されています(<span class="codeannotation" aria-label="annotation2">❷</span>)。<span class="thesansmonocd_w5regular_">pages</span>属性にアクセスするなどしてPDFの内容を読み取ろうとすると(<span class="codeannotation" aria-label="annotation3">❸</span>)、PyPDFは読み取ることができないので<span class="thesansmonocd_w5regular_">FileNotDecryptedError</span>を送出します。</p>
<p class="tx">PDFには、閲覧専用の<i class="calibre5">ユーザーパスワード</i>と、印刷やコメントやテキスト抽出やその他の機能を使える<i class="calibre5">オーナーパスワード</i>があります。<span class="thesansmonocd_w5regular_">encrypt()</span>の第一引数がユーザーパスワードに、第二引数がオーナーパスワードに対応します。<span class="thesansmonocd_w5regular_">encrypt()</span>に一つしか引数を渡さなければ、PyPDFはユーザーパスワードとオーナーパスワードに同じそのパスワードを設定します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトを復号するには、<span class="thesansmonocd_w5regular_">decrypt()</span>メソッドを呼び出してパスワード文字列を渡します。<span class="thesansmonocd_w5regular_">PasswordType</span>メソッドを呼び出してパスワード文字列を渡します。そのオブジェクトの<span class="thesansmonocd_w5regular_">name</span>属性が<span class="thesansmonocd_w5regular_">'NOT_DECRYPTED'</span>であれば(<span class="codeannotation" aria-label="annotation4">❹</span>)、パスワードが間違っています。<span class="thesansmonocd_w5regular_">name</span>属性が<span class="thesansmonocd_w5regular_">'OWNER_PASSWORD'</span>または<span class="thesansmonocd_w5regular_">'USER_PASSWORD'</span>であれば、(<span class="codeannotation" aria-label="annotation5">❺</span>)、正しいユーザーパスワードまたはオーナーパスワードです。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトに<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトのページを追加できるようになりました(<span class="codeannotation" aria-label="annotation6">❻</span>)。復号したPDFをファイルに保存します。</p>
<p class="ph"><span id="calibre_link-461"></span><span class="sans_futura_std_heavy_b_">プロジェクト12：たくさんのPDFから選択したページを結合する</span></p>
<p class="tni">数十のPDFファイルを一つのPDFファイルに結合する退屈な作業をしているとしましょう。各PDFの最初のページは表紙であり、最終成果物では表紙が不要です。PDFを結合する無料のプログラムはたくさんありますが、ファイル全体を結合することしかできないプログラムが多いです。結合したPDFに含めるページを調節できるPythonプログラムを書きましょう。</p>
<p class="tx">このプログラムには以下の内容が必要です。</p>
<ul class="ul">
<li class="bl">現在の作業ディレクトリにあるPDFファイルをすべて見つけてアルファベット順に並べ替える</li>
<li class="bl">各PDFファイルについて、2ページ目以降を出力PDFにコピーする</li>
<li class="bl">出力PDFをファイルに保存する</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">os.listdir()</span>を呼び出して現在の作業ディレクトリのすべてのファイルを見つけ、PDF以外のファイルを除去する（<span>第11章</span>でこの関数を扱いました）</li>
<li class="bl">Pythonの<span class="thesansmonocd_w5regular_">sort()</span>リストメソッドを呼び出してファイル名のアルファベット順に並べ替える</li>
<li class="bl">出力PDF用の<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトを作成する</li>
<li class="bl">各PDFファイルを反復処理して<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトを作成する</li>
<li class="bl"><span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトから2ページ目以降を出力PDFにコピーする</li>
<li class="bl">出力PDFをファイルに書き出す</li>
</ul>
<p class="tx">このプロジェクト用に新しいファイルエディタタブを開いて<i class="calibre5">combine_pdfs.py</i>という名前で保存してください。</p>
</section>
</section>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1933"><span id="calibre_link-462"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：すべてのPDFファイルを見つける</span></h4>
<p class="tni">まず、現在の作業ディレクトリで<i class="calibre5">.pdf</i>拡張子のファイルをすべて見つけて並べ替えます。コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># combine_pdfs.py - 現在の作業ディレクトリにあるすべてのPDFファイルを
# 一つのPDFファイルに結合する

<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> import pypdf, os

# すべてのPDFファイル名を取得
pdf_filenames = []
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1215" aria-label="423"></span>for filename in os.listdir('.'):
    if filename.endswith('.pdf'):
      <span class="code_codeannotation" aria-label="annotation2">❷</span> pdf_files.append(filename)
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> pdf_filenames.sort(key=str.lower)

<span class="codeannotated_codeannotation" aria-label="annotation4">❹</span> writer = pypdf.PdfWriter()

# TODO：すべてのPDFファイルを反復処理

# TODO: 2ページ目以降のすべてのページをコピー

# TODO：出力PDFをファイルに保存
</code></pre>
<p class="tx">このコードでは、<span class="thesansmonocd_w5regular_">pypdf</span>モジュールと<span class="thesansmonocd_w5regular_">os</span>モジュールをインポートしています(<span class="codeannotation" aria-label="annotation1">❶</span>)。<span class="thesansmonocd_w5regular_">os.listdir('.')</span>を呼び出すと現在の作業ディレクトリにあるすべてのファイルのリストが返されます。そのリストを反復処理して、<i class="calibre5">.pdf</i>拡張子のファイルを<span class="thesansmonocd_w5regular_">pdf_filenames</span>変数のリストに追加します(<span class="codeannotation" aria-label="annotation2">❷</span>)。次に、このリストを、<span class="thesansmonocd_w5regular_">sort()</span>に<span class="thesansmonocd_w5regular_">key=str.lower</span>キーワード引数を渡してアルファベット順に並べ替えます(<span class="codeannotation" aria-label="annotation3">❸</span>)。技術的な理由により、<span class="thesansmonocd_w5regular_">sort()</span>メソッドは<i class="calibre5">Z</i>のような大文字を<i class="calibre5">a</i>のような小文字よりも前に並べ替えます。先ほど示したような引数を渡すと文字列を小文字で比較するのでそうした事態を防げます。結合したPDFのページを保持する<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトを作成します(<span class="codeannotation" aria-label="annotation4">❹</span>)。最後に、プログラムの残りの概要をコメントで書いています。</p>
</section>
<section type="division" aria-labelledby="sec11">
<h4 class="h1" id="calibre_link-1934"><span id="calibre_link-463"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：各PDFを開く</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">pdf_filenames</span>の各PDFファイルを開きます。以下のコードです。</p>
<pre class="pre"><code class="calibre9"># combine_pdfs.py - 現在の作業ディレクトリにあるすべてのPDFファイルを
# 一つのPDFファイルに結合する

import pypdf, os

<var class="calibre20">--snip--</var>

<b class="calibre10"># すべてのPDFファイルを反復処理</b>
<b class="calibre10">for pdf_filename in pdf_filenames:</b>
<b class="calibre10">    reader = pypdf.PdfReader(pdf_filename)</b>
<b class="calibre10">    # 2ページ目以降のすべてのページをコピー</b>
<b class="calibre10">    writer.append(pdf_filename, (1, len(reader.pages)))</b>

# TODO：出力PDFをファイルに保存
</code></pre>
<p class="tx">それぞれのPDFファイル名につき、ループで<span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトを作成し、<span class="thesansmonocd_w5regular_">reader</span>という名前の変数に格納します。ループ内のコードで<span class="thesansmonocd_w5regular_">len(reader.pages)</span>を呼び出すとそのPDFのページ数がわかります。この情報を<span class="thesansmonocd_w5regular_">append()</span>メソッド呼び出しで使い、2ページ目から最後のページまでコピーします（PyPDFでは最初のページのインデックスが<span class="thesansmonocd_w5regular_">0</span>です）。その内容を<span class="thesansmonocd_w5regular_">writer</span>に格納されている同じ<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトに追加します。</p>
</section>
<section type="division" aria-labelledby="sec12">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1116" aria-label="424"></span>
<h4 class="h1" id="calibre_link-1935"><span id="calibre_link-464"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：結果を保存する</span></h4>
<p class="tni">この<span class="thesansmonocd_w5regular_">for</span>ループが終われば、変数<span class="thesansmonocd_w5regular_">writer</span>にはすべてのPDFのページを結合した<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトが格納されているはずです。最後にこの内容をハードドライブのファイルに書き込みます。このようなコードです。</p>
<pre class="pre"><code class="calibre9"># combine_pdfs.py - 現在の作業ディレクトリにあるすべてのPDFファイルを
# 一つのPDFファイルに結合する

import pypdf, os

<var class="calibre20">--snip--</var>

<b class="calibre10"># 出力PDFをファイルに保存</b>
<b class="calibre10">with open('combined.pdf', 'wb') as file:</b>
<b class="calibre10">    writer.write(file)</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">open()</span>に<span class="thesansmonocd_w5regular_">'wb'</span>を渡して出力PDFファイルの<i class="calibre5">combined.pdf</i>をバイナリ書き込みモードで開きます。それから、<span class="thesansmonocd_w5regular_">File</span>オブジェクトを<span class="thesansmonocd_w5regular_">write()</span>メソッドに渡して実際のPDFファイルを作成します。（同じ名前の<span class="thesansmonocd_w5regular_">write()</span>メソッドが<span class="thesansmonocd_w5regular_">File</span>オブジェクトにも<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトにもあることに注意してください。）プログラムの最後の部分では、一つのPDFに、フォルダ内のすべてのPDFをファイル名のアルファベット順に並べ替えて最初のページ以外のすべてのページが集約されています。</p>
</section>
<section type="division" aria-labelledby="sec13">
<h4 class="h1" id="calibre_link-1936"><span id="calibre_link-465"></span><span class="sans_futura_std_heavy_oblique_bi_">似たようなプログラムのアイデア</span></h4>
<p class="tni">別のPDFからページを取り出してPDFを作成できると、以下のようなプログラムを作れます。</p>
<ul class="ul">
<li class="bl">PDFから特定のページを切り取る</li>
<li class="bl">PDFのページを並べ替える</li>
<li class="bl"><span class="thesansmonocd_w5regular_">Page</span>オブジェクトの<span class="thesansmonocd_w5regular_">extract_text()</span>メソッドを活用して、特定のテキストがあるPDFのページだけを集めたPDFを作成する</li>
</ul>
</section>
</section>
<section type="division" aria-labelledby="sec14">
<h3 class="h" id="calibre_link-1937"><span id="calibre_link-466"></span><span class="sans_futura_std_bold_b_">Word文書</span></h3>
<p class="tni">Pythonでは、Python-Docxパッケージを使って、<i class="calibre5">.docx</i>拡張子のMicrosfot Word文書の作成や変更ができます。<span>付録A</span>の指示に従ってこのパッケージをインストールしてください。</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_1">警告</span></p>
</blockquote>
<p class="note-txt"><i class="calibre5">DocxではなくPython-Docxをインストールするように気をつけてください。Docxは本書で取り上げていない別のパッケージです。ただし、Python-Docxパッケージからモジュールをインポートする際は、</i><span class="sans_thesansmonocd_w5regular_italic_">import python-docx</span>ではなく<span class="sans_thesansmonocd_w5regular_italic_">import docx</span><i class="calibre5">を実行します。</i></p>
<p class="tx">Wordを持っていなくても、Windows、macOS、Linuxで<i class="calibre5">.docx</i>ファイルを開くのに、フリーのLibreOffice Writerアプリケーションを利用できます。<i class="calibre5"><a href="https://www.libreoffice.org." class="calibre1">https://<wbr></wbr>www<wbr></wbr>.libreoffice<wbr></wbr>.org</a></i>からダウンロードできます。WordはmacOSでも実行できますが、本章ではWindowsのWordを利用しています。また、Office 365やGoogle Docsのようなブラウザベースのウェブアプリでも<i class="calibre5">.docx</i>ファイルのインポート／エクスポートができます。</p>
<p class="tx">プレーンテキストファイルと違って、<i class="calibre5">.docx</i>ファイルには多くの構造的な要素があります。Python-Docxでは3つのデータ型でその要素を表現します。最上位レベルでは、<span class="thesansmonocd_w5regular_">Document</span>オブジェクトが文書全体を表します。<span class="thesansmonocd_w5regular_">Document</span>オブジェクトには、文書中の段落を表す<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトのリストがあります。（Word文書で入力中に<small class="calibre4">ENTER</small>（<small class="calibre4">RETURN</small>）キーを押すと新しい段落が始まります。）これらの<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトは、それぞれ、1つ以上の<span class="thesansmonocd_w5regular_">Run</span>オブジェクトのリストを含みます。図17-4は4つのrun（連続部分）がある一文の段落を示しています。</p>


<figure class="img"><img class="img3" id="calibre_link-790" src="images/000040.jpg" alt="The sentence “A plain paragraph with some bold and some italic.” The  word “bold” is bolded and the word “italic” is italicized. Each chunk of  identically formatted text is labeled “Run.”" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-4：</span><span class="sans_thesansmonocd_w5regular_italic_">Paragraph</span><span class="sans_futura_std_book_oblique_i_">オブジェクト内の</span><span class="sans_thesansmonocd_w5regular_italic_">Run</span><span class="sans_futura_std_book_oblique_i_">オブジェクト</span> </p></figcaption>
</figure>
<p class="tx">Word文書中のテキストは単なる文字列ではありません。フォント、サイズ、色その他のスタイル情報があります。Wordの<i class="calibre5">スタイル</i>はこれらの属性の集まりです。<span class="thesansmonocd_w5regular_">Run</span>オブジェクトは同じスタイルのテキストの連続部分です。スタイルを変更するたびに新しい<span class="thesansmonocd_w5regular_">Run</span>オブジェクトが必要になります。</p>
<section type="division" aria-labelledby="sec15">
<h4 class="h1" id="calibre_link-1938"><span id="calibre_link-467"></span><span class="sans_futura_std_heavy_oblique_bi_">Word文書の読み取り</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">docx</span>モジュールを試してみましょう。本書のオンライン素材から<i class="calibre5">demo.docx</i>をダウンロードして、現在の作業ディレクトリに保存してください。そして、対話型シェルに次のように入力します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import docx</b>
&gt;&gt;&gt; <b class="calibre10">doc = docx.Document('demo.docx')</b>
&gt;&gt;&gt; <b class="calibre10">len(doc.paragraphs)</b>
7
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[0].text</b>
'Document Title'
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].text</b>
'A plain paragraph with some bold text and some italic'
&gt;&gt;&gt; <b class="calibre10">len(doc.paragraphs[1].runs)</b>
4
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].runs[0].text</b>
'A plain paragraph with some '
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].runs[1].text</b>
'bold'
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].runs[2].text</b>
' and some '
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].runs[3].text</b>
'italic'
</code></pre>
<p class="tx">Pythonで<i class="calibre5">.docx</i>ファイルを開きます。<span class="thesansmonocd_w5regular_">docx.Document()</span>を呼び出してファイル名の<i class="calibre5">demo.docx</i>を渡します。これにより<span class="thesansmonocd_w5regular_">Document</span>オブジェクトが返されます。<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトのリストである<span class="thesansmonocd_w5regular_">paragraphs</span>属性があります。この属性について<span class="thesansmonocd_w5regular_">len()</span>を呼び出すと、<span class="thesansmonocd_w5regular_">7</span>が返され、この文書には7つの<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトがあるとわかります。これらの<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトにはそれぞれ<span class="thesansmonocd_w5regular_">text</span>属性があり、その段落の（スタイル情報なしの）テキストの文字列が入っています。最初の<span class="thesansmonocd_w5regular_">text</span>属性には<span class="thesansmonocd_w5regular_">'DocumentTitle'</span>が入っており、2つ目には<span class="thesansmonocd_w5regular_">'A plain paragraph with some bold text and some italic'</span>が入っています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトにはそれぞれ、<span class="thesansmonocd_w5regular_">Run</span>オブジェクトのリストである<span class="thesansmonocd_w5regular_">runs</span>属性があります。<span class="thesansmonocd_w5regular_">Run</span>オブジェクトにも<span class="thesansmonocd_w5regular_">text</span>属性があり、そのrun（連続部分）のテキストが入っています。2つ目の<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトの<span class="thesansmonocd_w5regular_">text</span>属性を見てみましょう。このオブジェクトについて<span class="thesansmonocd_w5regular_">len()</span>を呼び出すと4つの<span class="thesansmonocd_w5regular_">Run</span>オブジェクトがあることがわかります。最初の<span class="thesansmonocd_w5regular_">Run</span>オブジェクトには<span class="thesansmonocd_w5regular_">'A plain paragraph with some '</span>が入っています。次に、テキストは太字になりますから、新しい<span class="thesansmonocd_w5regular_">'bold'</span> という<span class="thesansmonocd_w5regular_">Run</span>オブジェクトが始まります。次は太字ではなくなるので3つ目の<span class="thesansmonocd_w5regular_">' text and some '</span>という<span class="thesansmonocd_w5regular_">Run</span>オブジェクトになります。最後の4つ目の<span class="thesansmonocd_w5regular_">Run</span>オブジェクトは斜体のスタイルの<span class="thesansmonocd_w5regular_">'italic'</span>です。</p>
<p class="tx">Python-Docxを使うと、Pythonプログラムで<i class="calibre5">.docx</i>ファイルからテキストを読み取り、通常の文字列値と同じように扱えます。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h4 class="h1" id="calibre_link-1939"><span id="calibre_link-468"></span><span class="sans_futura_std_heavy_oblique_bi_">.docxファイルからテキスト全文を取得する</span></h4>
<p class="tni">Word文書のテキストしか必要なくスタイル情報が不要なら、ここで作成する<span class="thesansmonocd_w5regular_">get_text()</span>関数を使えます。<i class="calibre5">.docx</i>ファイルのファイル名を取り、そのテキストを一つの文字列値で返します。新しいファイルエディタタブを開き、以下のコードを<i class="calibre5">readDocx.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import docx

def get_text(filename):
    doc = docx.Document(filename)
    full_text = []
    for para in doc.paragraphs:
        full_text.append(para.text)
    return '\n'.join(full_text)
</code></pre>
<p class="tx">この<span class="thesansmonocd_w5regular_">get_text()</span>関数はWord文書を開き、<span class="thesansmonocd_w5regular_">paragraphs</span>リストのすべての<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトを反復処理し、そのテキストを<span class="thesansmonocd_w5regular_">full_text</span>のリストに追加します。ループが終了したら、<span class="thesansmonocd_w5regular_">full_text</span>の文字列を改行文字で連結します。</p>
<p class="tx"><i class="calibre5">readDocx.py</i>プログラムを他のモジュールと同じようにインポートできます。Word文書のテキストだけが必要なら、以下のように実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import readDocx</b>
&gt;&gt;&gt; <b class="calibre10">print(readDocx.get_text('demo.docx'))</b>
Document Title
A plain paragraph with some bold text and some italic
Heading, level 1
Intense quote
first item in unordered list
first item in ordered list
</code></pre>
<p class="tx">文字列を返す前に調整することもできます。例えば、各段落を字下げするなら、 <i class="calibre5">readDocx.py</i>の<span class="thesansmonocd_w5regular_">append()</span>呼び出しを次のように変更します。</p>
<pre class="pre"><code class="calibre9"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1005" aria-label="427"></span>full_text.append(<b class="calibre10">'  ' + </b>para.text)</code></pre>
<p class="tx">段落間の改行を2つにするなら、<span class="thesansmonocd_w5regular_">join()</span>呼び出しを次のように変更します。</p>
<pre class="pre"><code class="calibre9">return '\n<b class="calibre10">\n</b>'.join(full_text)</code></pre>
<p class="tx">ご覧のように、<i class="calibre5">.docx</i>ファイルを読み取って好みの形でその内容を文字列で返す関数を数行のコードで書くことができます。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h4 class="h1" id="calibre_link-1940"><span id="calibre_link-469"></span><span class="sans_futura_std_heavy_oblique_bi_">ParagraphオブジェクトとRunオブジェクトのスタイル</span></h4>
<p class="tni">Wordその他のワープロでは、スタイルを使ってテキストの見た目の一貫性を保ち、変更をしやすくしています。例えば、本文の段落をすべて11ポイントのTimes New Romanで左寄せにすることができます。このような設定のスタイルを本文の段落全体に適用できます。あとで文書中の本文の段落全体の見た目を変えたくなったとしたら、スタイルを変更して段落全体の見た目を自動的に変更できます。</p>
<p class="tx">ブラウザベースのOffice 365 Wordでスタイルを確認するには、<b class="calibre10">ホーム</b>メニューをクリックして、<b class="calibre10">見出しとその他のスタイル</b>ドロップダウンメニューをクリックすると、おそらくノーマルその他のスタイルの名前が表示されます。<b class="calibre10">スタイルのオプション</b>をクリックすると、その他のスタイルウィンドウが表示されます。WindowsのMicrosoft Wordデスクトップアプリケーションでは、<small class="calibre4">CTRL</small>-<small class="calibre4">ALT</small>-<small class="calibre4">SHIFT</small>-Sを押すと、図17-5のようにスタイル枠にスタイルが表示されます。LibreOffice Writerでは、<b class="calibre10">表示</b><span class="listbullet_menuarrow"></span><b class="calibre10">スタイル</b>メニュー項目をクリックすればスタイル枠が表示されます。</p>
<figure class="img"><img class="img1" id="calibre_link-791" src="images/000041.jpg" alt="On the left, a screenshot of the Word Styles pane containing a list of styles, with the option “See More Styles” highlighted. On the right, the “More styles” pane open, showing a “style name” search bar and a list of styles." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-5：スタイル枠</span></p></figcaption>
</figure>
<p class="tx">Word文書には3つの種類のスタイルがあります。<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトに適用される段落スタイルと、<span class="thesansmonocd_w5regular_">Run</span>オブジェクトに適用される文字スタイルと、両方のオブジェクトに適用されるリンクスタイルです。<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクト及び<span class="thesansmonocd_w5regular_">Run</span>オブジェクトについては、<span class="thesansmonocd_w5regular_">style</span>属性にスタイル名の文字列を設定します。<span class="thesansmonocd_w5regular_">style</span>が<span class="thesansmonocd_w5regular_">None</span>に設定されると、<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトないし<span class="thesansmonocd_w5regular_">Run</span>オブジェクトにスタイルは関連づけられません。Wordのデフォルトでは、以下のスタイルがあります。</p>
<pre class="pre1"><code class="calibre9">'Normal'   'Heading 5' 'List Bullet'       'List Paragraph'
'Body Text' 'Heading 6' 'List Bullet 2'     'MacroText'
'Body Text 2'   'Heading 7' 'List Bullet 3'     'No Spacing'
'Body Text 3'   'Heading 8' 'List Continue'     'Quote'
'Caption'   'Heading 9' 'List Continue 2'   'Subtitle'
'Heading 1' 'Intense Quote' 'List Continue 3'   'TOC Heading'
'Heading 2' 'List'      'List Number '      'Title'
'Heading 3' 'List 2'    'List Number 2' 
'Heading 4' 'List 3'    'List Number 3' 
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Run</span>オブジェクトにリンクスタイルを適用する際は、名前の末尾に<span class="thesansmonocd_w5regular_">' Char'</span>をつけます。例えば、<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトに<span class="thesansmonocd_w5regular_">'Quote'</span>リンクスタイルを設定するには、<span class="thesansmonocd_w5regular_">paragraphObj.style</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'Quote'</span>としますが、<span class="thesansmonocd_w5regular_">Run</span>オブジェクトに設定するには、<span class="thesansmonocd_w5regular_">runObj.style</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'Quote Char'</span>とします。</p>
<p class="tx">カスタムスタイルを作成するには、Wordアプリケーションで定義して、それを<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトまたは<span class="thesansmonocd_w5regular_">Run</span>オブジェクトの<span class="thesansmonocd_w5regular_">style</span>属性から読み取ります。</p>
</section>
<section type="division" aria-labelledby="sec18">
<h4 class="h1" id="calibre_link-1941"><span id="calibre_link-470"></span><span class="sans_futura_std_heavy_oblique_bi_">Run属性の適用</span></h4>
<p class="tni">Run属性でrunのスタイルを設定できます。各属性は<span class="thesansmonocd_w5regular_">True</span>（他のスタイルが適用されていても常にその属性が有効化される）、<span class="thesansmonocd_w5regular_">False</span>（常にその属性が無効化される）、<span class="thesansmonocd_w5regular_">None</span>（runのスタイルのデフォルトにする）のいずれかに設定されます。表17-1は<span class="thesansmonocd_w5regular_">Run</span>オブジェクトに設定できる属性の一覧です。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-792"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 17-1：</span></span> <span class="thesansmonocd_w5regular_">Run</span><span class="sans_futura_std_book_">オブジェクトの</span><span class="sans_futura_std_book_">属性</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Attribute</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_"></span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">bold</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">テキストを太字にする</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">italic</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストを斜体にする</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">underline</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストに下線を引く</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">strike</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストに取り消し線を引く</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">double_strike</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストに二重取り消し線を引く</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">all_caps</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストを大文字で表示する</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">small_caps</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキスト少し小さい大文字で表示する</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">shadow</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストを影付きにする</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">outline</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストを実線ではなく枠線で表示する</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">rtl</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストを右から左に書くようにする</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">imprint</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストを刻印表示にする</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">emboss</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">テキストを浮き彫り表示にする</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1106" aria-label="429"></span>例えば、対話型シェルに次の内容を入力して、<i class="calibre5">demo.docx</i>のスタイルを変更してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import docx</b>
&gt;&gt;&gt; <b class="calibre10">doc = docx.Document('demo.docx')</b>
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[0].text</b>
'Document Title'
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[0].style</b>  # idは異なるかもしれない
_ParagraphStyle('Title') id: 3095631007984
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[0].style = 'Normal'</b>
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].text</b>
'A plain paragraph with some bold text and some italic'
&gt;&gt;&gt; <b class="calibre10">(doc.paragraphs[1].runs[0].text, doc.paragraphs[1].runs[1].text, </b>
<b class="calibre10">doc.paragraphs[1].runs[2].text, doc.paragraphs[1].runs[3].text)</b>
('A plain paragraph with some ', 'bold', ' and some ', 'italic')
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].runs[0].style = 'Quote Char'</b>
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].runs[1].underline = True</b>
&gt;&gt;&gt; <b class="calibre10">doc.paragraphs[1].runs[3].underline = True</b>
&gt;&gt;&gt; <b class="calibre10">doc.save('restyled.docx')</b>
</code></pre>
<p class="tx">文書中の段落を見やすくするために属性を使っています。段落をrunに分割してそれぞれのrunに個別にアクセスするのは簡単です。2つ目の段落の1つ目と2つ目と4つ目のrunを取得し、スタイルを調整して、新しい文書に保存します。</p>
<p class="tx"><i class="calibre5">restyled.docx</i>の冒頭の<i class="calibre5">Document Title</i>という文言がTitleスタイルではなくNormalスタイルになりました。<i class="calibre5">A plain paragraph with some</i>というテキストの<span class="thesansmonocd_w5regular_">Run</span>オブジェクトを<span class="thesansmonocd_w5regular_">Quote Char</span>スタイルにして、<i class="calibre5">bold</i>と<i class="calibre5">italic</i>の2つの<span class="thesansmonocd_w5regular_">Run</span>オブジェクトの<span class="thesansmonocd_w5regular_">underline</span>属性を<span class="thesansmonocd_w5regular_">True</span>に設定しました。図17-6は<i class="calibre5">restyled.docx</i>の段落とrunがどのようなスタイルになっているかを示しています。</p>
<figure class="img"><img class="img1" id="calibre_link-793" src="images/000042.jpg" alt="A Word document containing the text “A plain paragraph with some bold and some italic.” An arrow points to the Style bar containing the style “Quote.” Another arrow points to the text that has this style applied." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-6：</span><span class="sans_futura_std_book_">restyled.docx</span><span class="sans_futura_std_book_oblique_i_">ファイル</span></p></figcaption>
</figure>
<p class="tx">Python-Docxのスタイルの使い方は<i class="calibre5"><a href="https://python-docx.readthedocs.io" class="calibre1">https://<wbr></wbr>python<wbr></wbr>-docx<wbr></wbr>.readthedocs<wbr></wbr>.io</a></i>で詳細に説明されています。</p>
</section>
<section type="division" aria-labelledby="sec19">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-890" aria-label="430"></span>
<h4 class="h1" id="calibre_link-1942"><span id="calibre_link-471"></span><span class="sans_futura_std_heavy_oblique_bi_">Word文書の作成</span></h4>
<p class="tni"><i class="calibre5">.docx</i> ファイルを作成するには、<span class="thesansmonocd_w5regular_">docx.Document()</span>を呼び出して新しい空白の<span class="thesansmonocd_w5regular_">Document</span>オブジェクトを取得します。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import docx</b>
&gt;&gt;&gt; <b class="calibre10">doc = docx.Document()</b>
&gt;&gt;&gt; <b class="calibre10">doc.add_paragraph('Hello, world!')</b>
&lt;docx.text.paragraph.Paragraph object at 0x0000000003B56F60&gt;
&gt;&gt;&gt; <b class="calibre10">doc.save('helloworld.docx')</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">add_paragraph()</span>ドキュメントメソッドは、文書に新しい段落のテキストを追加し、追加された<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトへの参照を返します。テキストを追加したら、ファイル名の文字列を<span class="thesansmonocd_w5regular_">save()</span>ドキュメントメソッドに渡して<span class="thesansmonocd_w5regular_">Document</span>オブジェクトをファイルに保存します。</p>
<p class="tx">このコードは、<i class="calibre5">helloworld.docx</i>という名前のファイルを現在の作業ディレクトリに作成します。そのファイルを開くと、図17-7のようになっているはずです。この<i class="calibre5">.docx</i>ファイルをOffice 365やGoogle Docsにアップロードすることができますし、WordやLibreOfficeで開くこともできます。</p>
<figure class="img"><img class="img1" id="calibre_link-794" src="images/000043.jpg" alt="A Word document with the text “Hello, world!”" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-7：</span><span class="sans_thesansmonocd_w5regular_italic_">add_paragraph('Hello, world!')</span>を使って作成したWord文書</p></figcaption>
</figure>
<p class="tx">テキストを渡して<span class="thesansmonocd_w5regular_">add_paragraph()</span>メソッドを繰り返し呼び出すことで、文書に段落を追加できます。既存の段落の末尾にテキストを追加するには、文字列を渡してその段落の<span class="thesansmonocd_w5regular_">add_run()</span>メソッドを呼び出します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import docx</b>
&gt;&gt;&gt; <b class="calibre10">doc = docx.Document()</b>
&gt;&gt;&gt; <b class="calibre10">doc.add_paragraph('Hello world!')</b>
&lt;docx.text.paragraph.Paragraph object at 0x000000000366AD30&gt;
&gt;&gt;&gt; <b class="calibre10">para_obj_1 = doc.add_paragraph('This is a second paragraph.')</b>
&gt;&gt;&gt; <b class="calibre10">para_obj_2 = doc.add_paragraph('This is a yet another paragraph.')</b>
&gt;&gt;&gt; <b class="calibre10">para_obj_1.add_run(' This text is being added to the second paragraph.')</b>
&lt;docx.text.run.Run object at 0x0000000003A2C860&gt;
&gt;&gt;&gt; <b class="calibre10">doc.save('multipleParagraphs.docx')</b>
</code></pre>
<p class="tx">図17-8のような文書が作成されるはずです。<i class="calibre5">This text is being added to the second paragraph.</i>というテキストが、<span class="thesansmonocd_w5regular_">doc</span>に追加された2つ目の段落である<span class="thesansmonocd_w5regular_">para_obj_1</span>の<span class="thesansmonocd_w5regular_">Paragraph</span> <span role="doc-pagebreak" type="pagebreak" id="calibre_link-887" aria-label="431"></span>オブジェクトに追加されています。<span class="thesansmonocd_w5regular_">add_paragraph()</span>と<span class="thesansmonocd_w5regular_">add_run()</span>は、それぞれ<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトと<span class="thesansmonocd_w5regular_">Run</span>オブジェクトを返すので、オブジェクトの作成と取得を別々に行う必要はありません。</p>
<p class="tx">もう一度<span class="thesansmonocd_w5regular_">save()</span>メソッドを呼び出して変更点を保存してください。</p>
<figure class="img"><img class="img1" id="calibre_link-795" src="images/000044.jpg" alt="A Word document with three lines of text. The first says “Hello world!” The second says “This is a second paragraph. This text is being added to the second paragraph.” The third says “This is yet another paragraph.”" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-8：複数の</span><span class="sans_thesansmonocd_w5regular_italic_">Paragraph</span><span class="sans_futura_std_book_oblique_i_">オブジェクトと</span> <span class="sans_thesansmonocd_w5regular_italic_">Run</span><span class="sans_futura_std_book_oblique_i_">オブジェクトを追加した文書</span></p></figcaption>
</figure>
<p class="tx"><span class="thesansmonocd_w5regular_">add_paragraph()</span>と<span class="thesansmonocd_w5regular_">add_run()</span>には、<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトないし<span class="thesansmonocd_w5regular_">Run</span>オブジェクトのスタイルの文字列を取るオプションの第二引数があります。例を示します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">doc.add_paragraph('Hello, world!', 'Title')</b>
&lt;docx.text.paragraph.Paragraph object at 0x00000213E6FA9190&gt;
</code></pre>
<p class="tx">このコードはTitleスタイルの<i class="calibre5">Hello, world!</i>テキストの段落を追加します。</p>
</section>
<section type="division" aria-labelledby="sec20">
<h4 class="h1" id="calibre_link-1943"><span id="calibre_link-472"></span><span class="sans_futura_std_heavy_oblique_bi_">見出しの追加</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">add_heading()</span>を呼び出すと見出しスタイルの段落を追加します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import docx</b>
&gt;&gt;&gt; <b class="calibre10">doc = docx.Document()</b>
&gt;&gt;&gt; <b class="calibre10">doc.add_heading('Header 0', 0)</b>
&lt;docx.text.paragraph.Paragraph object at 0x00000000036CB3C8&gt;
&gt;&gt;&gt; <b class="calibre10">doc.add_heading('Header 1', 1)</b>
&lt;docx.text.paragraph.Paragraph object at 0x00000000036CB630&gt;
&gt;&gt;&gt; <b class="calibre10">doc.add_heading('Header 2', 2)</b>
&lt;docx.text.paragraph.Paragraph object at 0x00000000036CB828&gt;
&gt;&gt;&gt; <b class="calibre10">doc.add_heading('Header 3', 3)</b>
&lt;docx.text.paragraph.Paragraph object at 0x00000000036CB2E8&gt;
&gt;&gt;&gt; <b class="calibre10">doc.add_heading('Header 4', 4)</b>
&lt;docx.text.paragraph.Paragraph object at 0x00000000036CB3C8&gt;
&gt;&gt;&gt; <b class="calibre10">doc.save('headings.docx')</b>
</code></pre>
<p class="tx">作成される<i class="calibre5">headings.docx</i>ファイルは図17-9のように見えるはずです。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-885" aria-label="432"></span>
<figure class="img"><img class="img3" id="calibre_link-796" src="images/000045.jpg" alt="A Word document containing the text “Header 0,” “Header 1”, “Header 2”, “Header 3”, and “Header 4” in progressively smaller font sizes." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-9：見出し0から見出し4がある</span><span class="sans_futura_std_book_">headings.docx</span><span class="sans_futura_std_book_oblique_i_">文書</span></p></figcaption>
</figure>
<p class="tx">上記のコードにおける<span class="thesansmonocd_w5regular_">add_heading()</span>の引数はテキストと<span class="thesansmonocd_w5regular_">0</span>から<span class="thesansmonocd_w5regular_">4</span>までの整数です。整数<span class="thesansmonocd_w5regular_">0</span>は見出しをTitleスタイルにします。これを文書の冒頭で使っています。整数の<span class="thesansmonocd_w5regular_">1</span>から<span class="thesansmonocd_w5regular_">9</span>は見出しのレベルです。<span class="thesansmonocd_w5regular_">1</span>が大きな見出しで<span class="thesansmonocd_w5regular_">9</span>が一番小さな見出しです。<span class="thesansmonocd_w5regular_">add_heading()</span>関数は<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトを返すので、別途<span class="thesansmonocd_w5regular_">Document</span>オブジェクトから<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトを取得する必要はありません。</p>
</section>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1944"><span id="calibre_link-473"></span><span class="sans_futura_std_heavy_oblique_bi_">改行と改ページの追加</span></h4>
<p class="tni">（新しい段落を開始するのではなく）改行を追加するには、改行したい<span class="thesansmonocd_w5regular_">Run</span>オブジェクトについて<span class="thesansmonocd_w5regular_">add_break()</span>メソッドを呼び出します。改ページを追加したければ、<span class="thesansmonocd_w5regular_">add_break()</span>の引数に<span class="thesansmonocd_w5regular_">docx.enum.text.WD_BREAK.PAGE</span>の値を単独で渡します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">doc = docx.Document()</b>
&gt;&gt;&gt; <b class="calibre10">doc.add_paragraph('This is on the first page!')</b>
&lt;docx.text.paragraph.Paragraph object at 0x0000000003785518&gt;
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">doc.paragraphs[0].runs[0].add_break(docx.enum.text.WD_BREAK.PAGE)</b>
&gt;&gt;&gt; <b class="calibre10">doc.add_paragraph('This is on the second page!')</b>
&lt;docx.text.paragraph.Paragraph object at 0x00000000037855F8&gt;
&gt;&gt;&gt; <b class="calibre10">doc.save('twoPage.docx')</b>
</code></pre>
<p class="tx">このコードでは、1ページ目に<i class="calibre5">This is on the first page!</i>が、2ページ目には<i class="calibre5">This is on the second page!</i>がある2ページのWord文書を作成しています。1ページ目の<i class="calibre5">This is</i> <span role="doc-pagebreak" type="pagebreak" id="calibre_link-891" aria-label="433"></span><i class="calibre5">on the first page!</i>のあとにはまだかなり空白がありますが、最初の段落の最初のrunのあとに改ページを挿入して次の段落が強制的に新しいページで始まるようにしました(<span class="codeannotation" aria-label="annotation1">❶</span>)。</p>
</section>
<section type="division" aria-labelledby="sec22">
<h4 class="h1" id="calibre_link-1945"><span id="calibre_link-474"></span><span class="sans_futura_std_heavy_oblique_bi_">画像の追加</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Document</span>オブジェクトの<span class="thesansmonocd_w5regular_">add_picture()</span>メソッドを使うと文書の末尾に画像を追加できます。現在の作業ディレクトリに<i class="calibre5">zophie.png</i>というファイルがあるとします。以下のコードで幅が1インチで高さが4センチメートル（帝国単位とメートル単位のどちらでも可）の<i class="calibre5">zophie.png</i>を文書の末尾に追加できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">doc.add_picture('zophie.png', width=docx.shared.Inches(1), height=docx.shared.Cm(4))</b>
&lt;docx.shape.InlineShape object at 0x00000000036C7D30&gt;
</code></pre>
<p class="tx">第一引数は画像のファイル名の文字列です。オプションの<span class="thesansmonocd_w5regular_">width</span>と<span class="thesansmonocd_w5regular_">height</span>のキーワード引数では文書中の画像の幅と高さを設定します。省略すれば、幅と高さは元の画像の通常サイズになります。</p>
<p class="tx">画像の高さと幅をインチやセンチメートルなどの馴染みのある単位で指定する場合は、<span class="thesansmonocd_w5regular_">width</span>と<span class="thesansmonocd_w5regular_">height</span>のキーワード引数を指定する際に<span class="thesansmonocd_w5regular_">docx.shared.Inches()</span>や<span class="thesansmonocd_w5regular_">docx.shared.Cm()</span>という関数を使えます。</p>
</section>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec23">
<h3 class="h" id="calibre_link-1946"><span id="calibre_link-475"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">テキスト情報はプレーンテキストファイルに限られません。PDFやWord文書を扱うことはよくあるでしょう。PyPDFパッケージを使えばPDF文書を読み書きできます。PDFファイルを読み書きできるPythonのライブラリはほかにもたくさんあります。本章で取り上げたもの以外では、PyPIのウェブサイトで、pdfplumber、ReportLab、pdfrw、PyMuPDF、pdfkit、borb を検索することをおすすめします。</p>
<p class="tx">残念ながら、PDF文書からテキストを読み取る精度は完全ではありません。ファイルフォーマットが複雑で、全く読み取れないPDFもあるかもしれません。pdfminer.sixパッケージは保守されていないpdfminerパッケージのフォークで、PDFからのテキスト抽出に注力しています。本章ではPDFファイルからテキストを抽出できなかった場合にpdfminer.sixを使う仕組みを導入しました。</p>
<p class="tx">Word文書はPDFよりも信頼性が高く、python-docxパッケージの<span class="thesansmonocd_w5regular_">docx</span>モジュールを使うと読み取れます。<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトと<span class="thesansmonocd_w5regular_">Run</span>オブジェクトを通じてWord文書中のテキストを操作できます。これらのオブジェクトはスタイルを適用することもできます。ただし、スタイルはデフォルトのものかすでに文書中にあるものしか使えません。新しい段落、見出し、改行、改ページ、画像を文書の末尾に追加できます。</p>
<p class="tx">PDFやWord文書は、ソフトウェアで解析しやすくすることではなく人間にとって見やすく表示することを意図したフォーマットなので、これらのファイルでの作業には多くの制約があります。次章では、CSV、JSON、XMLファイルという情報を保存するのに一般的に用いられる別のフォーマットを紹介します。これらのフォーマットはコンピュータによる利用が想定されており、PDFやWordと比べてPythonでの作業がずっと簡単にできます。</p>
</section>
<section type="division" aria-labelledby="sec24">
<h3 class="h" id="calibre_link-1947"><span id="calibre_link-476"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. PDFファイルを保存するには、どのモードで<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクト用の<span class="thesansmonocd_w5regular_">File</span>オブジェクトを開く必要がありますか？</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトまたは<span class="thesansmonocd_w5regular_">PdfWriter</span>オブジェクトから、5ページ目の<span class="thesansmonocd_w5regular_">Page</span>オブジェクトを取得するにはどうしますか？</p>
<p class="listnumber">  3. <span class="thesansmonocd_w5regular_">PdfReader</span>オブジェクトのPDFがパスワード<span class="thesansmonocd_w5regular_">swordfish</span>で暗号化されていたら、<span class="thesansmonocd_w5regular_">Page</span>オブジェクトを取得する前に何をしなければならないですか？</p>
<p class="listnumber">  4. <span class="thesansmonocd_w5regular_">rotate()</span>メソッドは時計回りにページを回転させますが、反時計回りに回転させるにはどうしますか？</p>
<p class="listnumber">  5. <i class="calibre5">demo.docx</i>という名前のファイルの<span class="thesansmonocd_w5regular_">Document</span>オブジェクトを返すメソッドは何ですか？</p>
<p class="listnumber">  6. <span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトと<span class="thesansmonocd_w5regular_">Run</span>オブジェクトの違いは何ですか？</p>
<p class="listnumber">  7. <span class="thesansmonocd_w5regular_">doc</span>という名前の変数に格納されている<span class="thesansmonocd_w5regular_">Document</span>オブジェクトの<span class="thesansmonocd_w5regular_">Paragraph</span>オブジェクトのリストを取得するにはどうしますか？</p>
<p class="listnumber">  8. <span class="thesansmonocd_w5regular_">bold</span>、<span class="thesansmonocd_w5regular_">underline</span>、<span class="thesansmonocd_w5regular_">italic</span>、<span class="thesansmonocd_w5regular_">strike</span>、<span class="thesansmonocd_w5regular_">outline</span>という属性を持っているのはどの型のオブジェクトですか？</p>
<p class="listnumber">  9. <span class="thesansmonocd_w5regular_">bold</span>属性を<span class="thesansmonocd_w5regular_">True</span>、<span class="thesansmonocd_w5regular_">False</span>、<span class="thesansmonocd_w5regular_">None</span>に設定するとそれぞれどうなりますか？</p>
<p class="listnumber">10. 新しいWord文書の<span class="thesansmonocd_w5regular_">Document</span>オブジェクトはどのように作成しますか？</p>
<p class="listnumber">11. <span class="thesansmonocd_w5regular_">doc</span>という名前の変数に格納されている<span class="thesansmonocd_w5regular_">Document</span>オブジェクトに<span class="thesansmonocd_w5regular_">'Hello, there!'</span>というテキストの段落を追加するにはどうしますか？</p>
<p class="listnumber">12. Word文書の利用できる見出しのレベルを表す整数は何から何までですか？</p>
</section>
<section type="division" aria-labelledby="sec25">
<h3 class="h" id="calibre_link-1948"><span id="calibre_link-477"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec26">
<h4 class="h1" id="calibre_link-1949"><span id="calibre_link-478"></span><span class="sans_futura_std_heavy_oblique_bi_">PDF偏執狂</span></h4>
<p class="tni"><span>第11章</span>で紹介した<span class="thesansmonocd_w5regular_">os.walk()</span>関数を使って、フォルダ（とそのサブフォルダ）の中にあるすべてのPDFを、コマンドラインから受け取ったパスワードで暗号化するスクリプトを書いてください。暗号化したPDFファイルは元のファイル名に<i class="calibre5">_encrypted.pdf</i>という接尾辞を加えた名前で保存してください。元のファイルを削除する前に、新しいファイルを読み取って復号して正しく暗号化されていることを確認してください。</p>
<p class="tx">それから、すべての暗号化されたPDFをフォルダ（とそのサブフォルダ）から探してパスワードで復号したPDFのコピーを作成するプログラムを書いてください。パスワードが間違っていたら、ユーザーにメッセージを表示して次のPDFに進みます。</p>
</section>
<section type="division" aria-labelledby="sec27">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-987" aria-label="435"></span>
<h4 class="h1" id="calibre_link-1950"><span id="calibre_link-479"></span><span class="sans_futura_std_heavy_oblique_bi_">カスタム招待状</span></h4>
<p class="tni">招待客の名前を書いたテキストファイルがあります。この<i class="calibre5">guests.txt</i>ファイルには、以下のように名前が一行で書かれています。</p>
<pre class="pre"><code class="calibre9">Prof. Plum
Miss Scarlet
Col. Mustard
Al Sweigart
RoboCop
</code></pre>
<p class="tx">図17-10のように招待客の名前を入れたWord文書を生成するプログラムを書いてください。</p>
<p class="tx">Python-DocxはWord文書にすでに存在するスタイルしか使えませんので、まず空白のWordファイルにスタイルを追加してから、Python-Docxでそのファイルを開きます。Word文書で1人分の招待状はページごとに作成します。各招待状の最後の段落のあとに改ページを<span class="thesansmonocd_w5regular_">add_break()</span>で追加してください。こうすることで、1つのWord文書を開けば全員分の招待状を一気に印刷できます。</p>
<figure class="img"><img class="img1" id="calibre_link-798" src="images/000037.jpg" alt="An Excel spreadsheet with values in rows 1, 3, and 5 only." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 17-10：招待状スクリプトで生成されたWord文書</span></p></figcaption>
</figure>
<p class="tx">本書のオンライン素材からサンプルの<i class="calibre5">guests.txt</i>ファイルをダウンロードできます。</p>
</section>
<section type="division" aria-labelledby="sec28">
<h4 class="h1" id="calibre_link-1951"><span id="calibre_link-480"></span><span class="sans_futura_std_heavy_oblique_bi_">PDFパスワード解除装置</span></h4>
<p class="tni">暗号化したPDFファイルのパスワードを忘れてしまいました。ただ、パスワードは英語の1単語だったことは覚えています。忘れたパスワードを当て推量するのは非常に単調な作業です。英単語を一つずつ試して復号するプログラムを書くことができます。これは<i class="calibre5">ブルートフォースアタック</i>と呼ばれる手法です。本書のオンライン素材から<i class="calibre5">dictionary.txt</i>というテキストファイルをダウンロードしてください。この辞書には1行に1単語で44,000の英単語が含まれています。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1099" aria-label="436"></span><span>第10章</span>で学んだファイルの読み取りスキルを活用して、このファイルを読み取り単語の文字列リストを作成します。次に、このリストの単語を反復処理し、<span class="thesansmonocd_w5regular_">decrypt()</span>メソッドに渡します。単語ごとに大文字と小文字の両方を試してください。（私のノートパソコンでは、数分でこのファイルの大文字と小文字で合計88,000単語を処理できました。パスワードに単純な英単語を使ってはならないことがよくわかります。）</p>
</section>
</section>
</section>
</div>

</div>



</body></html>