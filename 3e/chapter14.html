<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">





<div type="bodymatter" class="calibre" id="calibre_link-370">
<section type="chapter" role="doc-chapter" aria-labelledby="ch14">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1142" aria-label="331"></span>
<hgroup>
<h2 class="title" id="calibre_link-1828">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">14</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">Excelファイル</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">スプレッドシートをプログラミングツールだと考えることはあまりありませんが、情報を2次元のデータ構造に整理したり、数式で計算を行ったり、グラフを出力したりと、ほとんど誰もがスプレッドシートを使っています。本章と次章では、2つのよく使われるスプレッドシートアプリケーションであるMicrosoft ExcelとGoogleスプレッドシートを、Pythonで操作します。</p>
<p class="tx">Excelは人気のある強力なスプレッドシートアプリケーションです。<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールを使うと、PythonプログラムからExcelのファイルを読み取って変更できます。例えば、あるExcelファイルから別のExcelファイルにデータをコピーして貼り付ける退屈な作業をすることがあるかもしれません。あるいは、何らかの基準に従って数千行の中から数行を選んで少し編集をすることがあるかもしれません。あるいは、部門の予算の数百あるExcelファイルから赤字の部分を探すことがあるかもしれません。これらは頭を使わない退屈なExcelの作業であり、Pythonで自動化できます。</p>
<p class="tx">ExcelはMicrosoftのプロプライエタリソフトウェアです。Windows、macOS、Linuxで動くLibreOfficeという代替のフリーソフトウェアがあります。LibreOfficeのCalcはExcelの<i class="calibre5">.xlsx</i>ファイルフォーマットを利用できます。よって、<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールは、LibreOfficeのCalcでも使えます。<i class="calibre5"><a href="https://www.libreoffice.org" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.libreoffice<wbr></wbr>.org</a></i>からダウンロードできます。お使いのコンピュータにExcelをすでにインストールしているとしても、LibreOfficeが使いやすいと感じるかもしれません。本章のスクリーンショットは、クラウドベースのOffice 365 Excelのものです。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールはExcelファイルを直接操作するのであって、デスクトップのExcelアプリケーションやクラウドベースのExcelウェブアプリを操作するのではありません。クラウドベースのOffice 365をお使いでしたら、<b class="calibre10">ファイル</b><span class="listbullet_menuarrow"></span><b class="calibre10">コピーを作成する</b><span class="listbullet_menuarrow"></span><b class="calibre10">コピーのダウンロード</b>をクリックしてExcelファイルをダウンロードしてください。Pythonスクリプトを実行してExcelファイルを編集してから、そのExcelファイルをもう一度Office 365にアップロードして変更点を確認します。デスクトップのExcelアプリケーションをお持ちでしたら、Excelファイルを閉じてからPythonスクリプトを実行してExcelファイルを編集して、そのファイルをもう一度Excelで開いて変更点を確認します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールはPythonに付属していませんから、インストールする必要があります。<span>付録A</span>でPythonのpipツールでサードパーティーパッケージをインストールする方法を説明しています。<i class="calibre5"><a href="https://openpyxl.readthedocs.io/en/stable/" class="calibre1">https://<wbr></wbr>openpyxl<wbr></wbr>.readthedocs<wbr></wbr>.io<wbr></wbr>/en<wbr></wbr>/stable<wbr></wbr>/</a></i>で<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールのドキュメントを読むことができます。</p>
<p class="tx">本章ではいくつかのExcelファイルを例として使用します。<i class="calibre5"><a href="https://nostarch.com/automate-boring-stuff-python-3rd-edition" class="calibre1">https://<wbr></wbr>nostarch<wbr></wbr>.com<wbr></wbr>/automate<wbr></wbr>-boring<wbr></wbr>-stuff<wbr></wbr>-python<wbr></wbr>-3rd<wbr></wbr>-edition</a></i>で本書のオンライン素材をダウンロードできます。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1829"><span id="calibre_link-371"></span><span class="sans_futura_std_bold_b_">Excelファイルの読み取り</span></h3>
<p class="tni">最初に基本的な用語の定義を確認します。Excelのスプレッドシート文書は<i class="calibre5">ワークブック</i>と呼ばれます。一つのワークブックは拡張子<i class="calibre5">.xlsx</i>の一つのファイルです。</p>
<p class="tx">各ワークブックは複数の<i class="calibre5">シート</i>（<i class="calibre5">ワークシート</i>）を持つことができます。ユーザーが現在見ているシート（またはExcelを閉じる前に見ていたシート）は、<i class="calibre5">アクティブシート</i>と呼ばれます。各シートには<i class="calibre5">列</i>（<i class="calibre5">A</i>で始まるアルファベットで表されます）と<i class="calibre5">行</i>（1で始まる数字で表されます）があります。列と行で定まる箱は<i class="calibre5">セル</i>と呼ばれます。各セルには数値やテキスト値を入れられます。格子状のセルとデータがシートを構成します。</p>
<p class="tx">本章の例では、現在の作業ディレクトリにある<i class="calibre5">example3.xlsx</i>という名前のExcelファイルを使います。そのExcelファイルを自分で作っても構いませんし、本書のオンライン素材からダウンロードしても構いません。図14-1は、<i class="calibre5">Sheet1</i>、<i class="calibre5">Sheet2</i>、<i class="calibre5">Sheet3</i>という名前の3つのシートのタブを示しています。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1226" aria-label="333"></span>
<figure class="img"><img class="img2" id="calibre_link-756" src="images/000017.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-1：ワークブックのシートのタブはExcelの左下にあります</span></p></figcaption>
</figure>
<p class="tx">この例のファイルの<i class="calibre5">Sheet1</i>は図14-1のようになっています。（<i class="calibre5">example3.xlsx</i>をダウンロードしていなければ、このデータを自分で作成したシートに入力してください。）</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-757"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 14-1：</span></span><span class="sans_futura_std_book_oblique_i_">example3.xlsx</span><span class="sans_futura_std_book_">のExcelファイル</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<td class="tch2"></td>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">A</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">B</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">C</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="sans_futura_std_bold_b_">1</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">4/5/2035 1:34:02 PM</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">Apples</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">73</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="sans_futura_std_bold_b_">2</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">4/5/2035 3:41:23 AM</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Cherries</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">85</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="sans_futura_std_bold_b_">3</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">4/6/2035 12:46:51 PM</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Pears</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">14</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="sans_futura_std_bold_b_">4</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">4/8/2035 8:59:43 AM</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Oranges</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">52</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="sans_futura_std_bold_b_">5</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">4/10/2035 2:07:00 AM</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Apples</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">152</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="sans_futura_std_bold_b_">6</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">4/10/2035 6:10:37 PM</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Bananas</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">23</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="sans_futura_std_bold_b_">7</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">4/10/2035 2:40:46 AM</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">Strawberries</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">98</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">Excelファイルの例が用意できましたから、<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールで操作してみましょう。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1830"><span id="calibre_link-372"></span><span class="sans_futura_std_heavy_oblique_bi_">ワークブックを開く</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールをインポートしたら、<span class="thesansmonocd_w5regular_">openpyxl.load_workbook()</span>関数で<i class="calibre5">.xlsx</i>ファイルを開けます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">type(wb)</b>
&lt;class 'openpyxl.workbook.workbook.Workbook'&gt;
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">openpyxl.load_workbook()</span>関数はファイル名を取り、<span class="thesansmonocd_w5regular_">Workbook</span>データ型の値を返します。この<span class="thesansmonocd_w5regular_">Workbook</span>オブジェクトはExcelファイルを表します。<span class="thesansmonocd_w5regular_">File</span>オブジェクトが開いたテキストファイルを表すのと少し似ています。</p>
</section>
<section type="division" aria-labelledby="sec3">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-882" aria-label="334"></span>
<h4 class="h1" id="calibre_link-1831"><span id="calibre_link-373"></span><span class="sans_futura_std_heavy_oblique_bi_">ワークブックからシートを取得する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">sheetnames</span>属性にアクセスすることでワークブックに含まれるすべてのシート名を取得できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames  </b># ワークブックのシート名
['Sheet1', 'Sheet2', 'Sheet3']
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet3']  </b># ワークブックからシートを取得
&gt;&gt;&gt; <b class="calibre10">sheet</b>
&lt;Worksheet "Sheet3"&gt;
&gt;&gt;&gt; <b class="calibre10">type(sheet)</b>
&lt;class 'openpyxl.worksheet.worksheet.Worksheet'&gt;
&gt;&gt;&gt; <b class="calibre10">sheet.title  </b># シート名を文字列として取得
'Sheet3'
&gt;&gt;&gt; <b class="calibre10">another_sheet = wb.active  </b># アクティブシートを取得
&gt;&gt;&gt; <b class="calibre10">another_sheet</b>
&lt;Worksheet "Sheet1"&gt;
</code></pre>
<p class="tx">各シートは<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトで表されます。<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトは、シート名を辞書のキーのように角かっこ内に指定することで取得できます。このコードの最後では、<span class="thesansmonocd_w5regular_">Workbook</span>オブジェクトの<span class="thesansmonocd_w5regular_">active</span>属性でそのワークブックのアクティブシートを取得しています。アクティブシートはExcelで開いたときに表示されるシートです。<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトの<span class="thesansmonocd_w5regular_">title</span>属性からシート名を取得できます。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1832"><span id="calibre_link-374"></span><span class="sans_futura_std_heavy_oblique_bi_">シートからセルを取得する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトでセル番地を指定すると、<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを取得できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet1']  </b># ワークブックからシートを取得
&gt;&gt;&gt; <b class="calibre10">sheet['A1']  </b># シートからセルを取得
&lt;Cell 'Sheet1'.A1&gt;
&gt;&gt;&gt; <b class="calibre10">sheet['A1'].value  </b># セルから値を取得
datetime.datetime(2035, 4, 5, 13, 34, 2)
&gt;&gt;&gt; <b class="calibre10">c = sheet['B1']  </b># シートから別のセルを取得
&gt;&gt;&gt; <b class="calibre10">c.value</b>
'Apples'
&gt;&gt;&gt;  # セルから行番号、列番号、値を取得
&gt;&gt;&gt; <b class="calibre10">f'Row {c.row}, Column {c.column} is {c.value}'</b>
'Row 1, Column 2 is Apples'
&gt;&gt;&gt; <b class="calibre10">f'Cell {c.coordinate} is {c.value}'</b>
'Cell B1 is Apples'
&gt;&gt;&gt; <b class="calibre10">sheet['C1'].value</b>
73
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Cell</span>オブジェクトには、そのセルに入っている値を含む<span class="thesansmonocd_w5regular_">value</span>属性があります。そのセルの位置情報を示す<span class="thesansmonocd_w5regular_">row</span>、<span class="thesansmonocd_w5regular_">column</span>、<span class="thesansmonocd_w5regular_">coordinate</span>の属性もあります。B1セルの<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトの<span class="thesansmonocd_w5regular_">value</span>属性にアクセスすると、文字列<span class="thesansmonocd_w5regular_">'Apples'</span>を取得できます。<span class="thesansmonocd_w5regular_">row</span>属性は整数の<span class="thesansmonocd_w5regular_">1</span>、<span class="thesansmonocd_w5regular_">column</span>属性は<span class="thesansmonocd_w5regular_">2</span>、<span class="thesansmonocd_w5regular_">coordinate</span>属性は<span class="thesansmonocd_w5regular_">'B1'</span>です。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールは自動的にA列の日付を解釈し、文字列ではなく<span class="thesansmonocd_w5regular_">datetime</span>値として返します。<span>第19章</span>で<span class="thesansmonocd_w5regular_">datetime</span>データ型について詳しく説明します。</p>
<p class="tx">プログラムで列をアルファベットで指定するのはややこしいです。特にZ列以降はAA、AB、ACのように2文字になるので余計にややこしいです。アルファベットで指定しなくても、シートの<span class="thesansmonocd_w5regular_">cell()</span>メソッドに<span class="thesansmonocd_w5regular_">row</span>と<span class="thesansmonocd_w5regular_">column</span>のキーワード引数で整数を渡せば、セルを取得できます。最初の列も最初の行も0ではなく1です。対話型シェルで続けて以下のように入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">sheet.cell(row=1, column=2)</b>
&lt;Cell 'Sheet1'.B1&gt;
&gt;&gt;&gt; <b class="calibre10">sheet.cell(row=1, column=2).value</b>
'Apples'
&gt;&gt;&gt; <b class="calibre10">for i in range(1, 8, 2): </b># 1行おきに反復処理
<b class="calibre10">...     print(i, sheet.cell(row=i, column=2).value)</b>
...
1 Apples
3 Pears
5 Apples
7 Strawberries
</code></pre>
<p class="tx">シートの<span class="thesansmonocd_w5regular_">cell()</span>メソッドに<span class="thesansmonocd_w5regular_">row=1</span>と<span class="thesansmonocd_w5regular_">column=2</span>を渡して、<span class="thesansmonocd_w5regular_">sheet['B1']</span>と同じようにB1セルの<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを取得しています。</p>
<p class="tx">この<span class="thesansmonocd_w5regular_">cell()</span>メソッドとキーワード引数を使うと、<span class="thesansmonocd_w5regular_">for</span>ループで一連のセルの値を表示できます。例えば、B列の奇数行のすべてのセルの値を表示したいとします。<span class="thesansmonocd_w5regular_">range()</span>関数のstepパラメータに<span class="thesansmonocd_w5regular_">2</span>を渡すと、1行おき（この場合は奇数行）のセルを取得できます。この例では、<span class="thesansmonocd_w5regular_">for</span>ループの変数<span class="thesansmonocd_w5regular_">i</span>を<span class="thesansmonocd_w5regular_">cell()</span>メソッドの<span class="thesansmonocd_w5regular_">row</span>キーワード引数に渡し、<span class="thesansmonocd_w5regular_">column</span>キーワード引数には<span class="thesansmonocd_w5regular_">2</span>を渡して、メソッドを呼び出しています。このメソッドは文字列の<span class="thesansmonocd_w5regular_">'B'</span>ではなく整数の<span class="thesansmonocd_w5regular_">2</span>を受け入れます。</p>
<p class="tx">シートのサイズは、<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトの<span class="thesansmonocd_w5regular_">max_row</span>属性と<span class="thesansmonocd_w5regular_">max_column</span>属性で判断できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet1']</b>
&gt;&gt;&gt; <b class="calibre10">sheet.max_row  </b># 最大行番号を取得
7
&gt;&gt;&gt; <b class="calibre10">sheet.max_column  </b># 最大列番号を取得
3
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">max_column</span>属性はExcelで見えるアルファベットの文字ではなく整数であることに注意してください。</p>
</section>
<section type="division" aria-labelledby="sec5">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1035" aria-label="336"></span>
<h4 class="h1" id="calibre_link-1833"><span id="calibre_link-375"></span><span class="sans_futura_std_heavy_oblique_bi_">列のアルファベットと数値を相互に変換する</span></h4>
<p class="tni">数値から文字に変換するには、<span class="thesansmonocd_w5regular_">openpyxl.utils.get_column_letter()</span>関数を呼び出します。文字から数値に変換するには、<span class="thesansmonocd_w5regular_">openpyxl.utils.column_index_from_string()</span>関数を呼び出します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">from openpyxl.utils import get_column_letter, column_index_from_string</b>
&gt;&gt;&gt; <b class="calibre10">get_column_letter(1)</b>  # 1列目を表すアルファベット文字を取得
'A'
&gt;&gt;&gt; <b class="calibre10">get_column_letter(2</b>)
'B'
&gt;&gt;&gt; <b class="calibre10">get_column_letter(27)</b>
'AA'
&gt;&gt;&gt; <b class="calibre10">get_column_letter(900)</b>
'AHP'
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet1']</b>
&gt;&gt;&gt; <b class="calibre10">get_column_letter(sheet.max_column)</b>
'C'
&gt;&gt;&gt; <b class="calibre10">column_index_from_string('A')</b> # A列の列番号を取得
1
&gt;&gt;&gt; <b class="calibre10">column_index_from_string('AA')</b>
27
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">openpyxl.utils</span>モジュールからこれら2つの関数をインポートしたら、<span class="thesansmonocd_w5regular_">27</span>のような整数を渡して<span class="thesansmonocd_w5regular_">get_column_letter()</span>を呼び出すと27列目の文字がわかります。<span class="thesansmonocd_w5regular_">column_index_from_string()</span>は逆のことを行います。 列を表すアルファベット文字を渡して呼び出すと、その列が何列目かを返します。これらの関数を使うためにワークブックを読み込む必要はありません。</p>
</section>
<section type="division" aria-labelledby="sec6">
<h4 class="h1" id="calibre_link-1834"><span id="calibre_link-376"></span><span class="sans_futura_std_heavy_oblique_bi_">行と列を取得する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトをスライスして、行、列、行と列の範囲の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを取得できます。その複数セルをすべてループで反復処理できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet1']</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A1':'C3']  </b># A1からC3までのセルを取得
((&lt;Cell 'Sheet1'.A1&gt;, &lt;Cell 'Sheet1'.B1&gt;, &lt;Cell 'Sheet1'.C1&gt;), (&lt;Cell 'Sheet1'.A2&gt;, &lt;Cell
'Sheet1'.B2&gt;, &lt;Cell 'Sheet1'.C2&gt;), (&lt;Cell 'Sheet1'.A3&gt;, &lt;Cell 'Sheet1'.B3&gt;, &lt;Cell
'Sheet1'.C3&gt;))
&gt;&gt;&gt; <b class="calibre10">for row_of_cell_objects in sheet['A1':'C3']:</b> <span class="code_codeannotation" aria-label="annotation1">❶</span>
<b class="calibre10">...     for cell_obj in row_of_cell_objects:</b> <span class="code_codeannotation" aria-label="annotation2">❷</span>
<b class="calibre10">...         print(cell_obj.coordinate, cell_obj.value)</b>
<b class="calibre10">...     print('--- END OF ROW ---')</b>
...
A1 2035-04-05 13:34:02
B1 Apples
C1 73
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1835" aria-label="337"></span><b class="calibre10">--- </b>END OF ROW <b class="calibre10">---</b>
A2 2035-04-05 03:41:23
B2 Cherries
C2 85
<b class="calibre10">--- </b>END OF ROW <b class="calibre10">---</b>
A3 2035-04-06 12:46:51
B3 Pears
C3 14
<b class="calibre10">--- </b>END OF ROW <b class="calibre10">---</b>
</code></pre>
<p class="tx">A1からC3までの行と列の範囲の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを取得するためにスライスに<span class="thesansmonocd_w5regular_">['A1':'C3']</span>と指定して、その範囲の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを含むタプルを取得しています。</p>
<p class="tx">このタプルは、指定した範囲の上から下までの各行を表す3つのタプルを含んでいます。この3つの内側のタプルは、それぞれ、指定した範囲の左から右までの列の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを含んでいます。まとめると、このシートのスライスは、左上のセルから右下のセルにかけて、A1からC3までの範囲の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトをすべて含んでいます。</p>
<p class="tx">この範囲の各セルの値を表示するためには、2つの<span class="thesansmonocd_w5regular_">for</span>ループを使います。外側の<span class="thesansmonocd_w5regular_">for</span>ループはスライスの各行を反復処理します(<span class="codeannotation" aria-label="annotation1">❶</span>)。各行について、内側の<span class="thesansmonocd_w5regular_">for</span>ループがその行の各セルを反復処理します(<span class="codeannotation" aria-label="annotation2">❷</span>)。</p>
<p class="tx">特定の行または列のセルの値にアクセスするのに、<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトの<span class="thesansmonocd_w5regular_">rows</span>属性と<span class="thesansmonocd_w5regular_">columns</span>属性を利用することもできます。これらの属性は、角かっことインデックスを使えるようにするために、<span class="thesansmonocd_w5regular_">list()</span>関数でリストに変換しなければなりません。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet1']</b>
&gt;&gt;&gt; <b class="calibre10">list(sheet.columns)[1]  </b># 2列目のセルを取得
(&lt;Cell 'Sheet1'.B1&gt;, &lt;Cell 'Sheet1'.B2&gt;, &lt;Cell 'Sheet1'.B3&gt;, &lt;Cell 'Sheet1'.B4&gt;, &lt;Cell
'Sheet1'.B5&gt;, &lt;Cell 'Sheet1'.B6&gt;, &lt;Cell 'Sheet1'.B7&gt;)
&gt;&gt;&gt; <b class="calibre10">for cell_obj in list(sheet.columns)[1]:</b>
...     <b class="calibre10">print(cell_obj.value)</b>
...
Apples
Cherries
Pears
Oranges
Apples
Bananas
Strawberries
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトの<span class="thesansmonocd_w5regular_">rows</span>属性を使い、<span class="thesansmonocd_w5regular_">list()</span>に渡せば、タプルのリストが得られます。このタプルはそれぞれの行を表し、その行の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを含んでいます。<span class="thesansmonocd_w5regular_">columns</span>属性を<span class="thesansmonocd_w5regular_">list()</span>に渡すと、タプルのリストが得られ、そのタプルにはその列の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトが含まれます。<i class="calibre5">example3.xlsx</i>は7行3列あり、<span class="thesansmonocd_w5regular_">list(sheet.rows)</span>で7つのタプル（各タプルには3つの<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトが含まれています）が得られ、<span class="thesansmonocd_w5regular_">list(sheet</span>.<span class="thesansmonocd_w5regular_">columns)</span>で3つのタプル（各タプルには7つの<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトが含まれています）が得られます。</p>
<p class="tx">一つのタプルにアクセスするには、外側のタプルにインデックスを指定します。例えば、B列を表すタプルを取得するには、<span class="thesansmonocd_w5regular_">list(sheet.columns)[1]</span>とします。A列の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを含むタプルを取得するには、<span class="thesansmonocd_w5regular_">list(sheet.columns)[0]</span>とします。一つの行または列を表すタプルを取得できれば、ループで<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトを反復処理してその値を表示できます。</p>
<aside class="box" aria-label="box-17">
<p class="bt" id="calibre_link-1836"><span class="sans_futura_std_bold_b_">ワークブック、シート、セルのおさらい</span></p>
<p class="btni"><span class="sans_futura_std_book_">簡単なおさらいとして、Excelファイルからセルを読み取るために使う関数、メソッド、データ型を要約します。</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">1. </span><span class="thesansmonocd_w5regular_">openpyxl</span><span class="sans_futura_std_book_">モジュールをインポートする</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2. </span><span class="thesansmonocd_w5regular_">openpyxl.load_workbook()</span><span class="sans_futura_std_book_">関数を呼び出して</span><span class="thesansmonocd_w5regular_">Workbook</span><span class="sans_futura_std_book_">オブジェクトを取得する</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">3. </span> <span class="thesansmonocd_w5regular_">active</span><span class="sans_futura_std_book_">属性または</span><span class="thesansmonocd_w5regular_">sheetnames</span><span class="sans_futura_std_book_">属性を使用する</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">4. </span> <span class="thesansmonocd_w5regular_">Worksheet</span><span class="sans_futura_std_book_">オブジェクトを取得する</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">5. インデックスまたは</span><span class="thesansmonocd_w5regular_">row</span><span class="sans_futura_std_book_">と</span><span class="thesansmonocd_w5regular_">column</span><span class="sans_futura_std_book_">のキーワード引数を渡して</span><span class="thesansmonocd_w5regular_">cell()</span><span class="sans_futura_std_book_">シートメソッドを使う</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">6. </span> <span class="thesansmonocd_w5regular_">Cell</span><span class="sans_futura_std_book_">オブジェクトを取得する</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">7. </span> <span class="thesansmonocd_w5regular_">Cell</span><span class="sans_futura_std_book_">オブジェクトの</span><span class="thesansmonocd_w5regular_">value</span><span class="sans_futura_std_book_">属性を読み取る</span></p>
</aside>
<p class="ph"><span id="calibre_link-377"></span><span class="sans_futura_std_heavy_b_">プロジェクト9：国勢調査統計データを集計する</span></p>
<p class="tni">2010年の合衆国の国勢調査のデータが入っている数千行のExcelファイルがあるとして、各郡について人口と国勢統計区を集計するという退屈な作業をすることになったとします（<i class="calibre5">国勢統計区</i>とは、国勢調査のために区画された地理的単位です）。各行は一つの国勢統計区を表しています。<i class="calibre5">censuspopdata.xlsx</i>という名前のファイルで本書のオンライン素材に含まれています。図14-2のような内容になっています。</p>
<figure class="img"><img class="img2" id="calibre_link-758" src="images/000020.jpg" alt="An Excel spreadsheet with the columns “CensusTract”, “State”, “County”, and “POP2010”. Each row contains details about a census tract in San Francisco." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図  14-2：</span><span class="sans_futura_std_book_">censuspopdata.xlsx</span><span class="sans_futura_std_book_oblique_i_">のExcelファイル</span></p></figcaption>
</figure>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1282" aria-label="339"></span>Excelは選択したセルの合計を自動的に計算してくれますが、それでも手動で3000以上の郡のセルを選択しなければなりません。手動で一つの郡の集計をするのは数秒だとしても、ファイル全体のすべての郡の集計をするには何時間もかかります。</p>
<p class="tx">このプロジェクトでは、国勢調査のExcelファイルから読み取って各郡の集計を数秒で行うスクリプトを書きます。</p>
<p class="tx">このプログラムには以下の内容が必要です。</p>
<ul class="ul">
<li class="bl">Excelファイルからデータを読み取る</li>
<li class="bl">各郡の国勢統計区の数を集計する</li>
<li class="bl">各郡の人口を集計する</li>
<li class="bl">結果を表示する</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールでExcelファイルを開いてセルを読み取る</li>
<li class="bl">すべての国勢統計区と人口を集計し、データ構造に格納する</li>
<li class="bl">あとでインポートできるように、<span class="thesansmonocd_w5regular_">pprint</span>モジュールを使って、データ構造を拡張子<i class="calibre5">.py</i>のテキストファイルに書き出す</li>
</ul>
</section>
<section type="division" aria-labelledby="sec7">
<h4 class="h1" id="calibre_link-1837"><span id="calibre_link-378"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：Excelファイルのデータを読み取る</span></h4>
<p class="tni"><i class="calibre5">censuspopdata.xlsx</i>ファイルには、<span class="thesansmonocd_w5regular_">'Population by Census Tract'</span>という名前の一つのシートしかありません。そのシートの各行には、一つの国勢統計区のデータが入っています。列は、国勢統計区(A)、州の略称(B)、郡の名前(C)、その国勢統計区の人口(D)です。</p>
<p class="tx">新しいファイルエディタタブを開いて、以下のコードを<i class="calibre5">readCensusExcel.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9"># readCensusExcel.py - 郡の人口と国勢統計区を集計する

<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> import openpyxl, pprint
print('Opening workbook...')
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> wb = openpyxl.load_workbook('censuspopdata.xlsx')
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> sheet = wb['Population by Census Tract']
county_data = {}

# TODO: county_dataを各郡の人口と国勢統計区で埋める
print('Reading rows...')
<span class="codeannotated_codeannotation" aria-label="annotation4">❹</span> for row in range(2, sheet.max_row + 1):
    # Excelファイルの各行は一つの国勢統計区のデータ
    state  = sheet['B' + str(row)].value
    county = sheet['C' + str(row)].value
    pop    = sheet['D' + str(row)].value

# TODO: 新しいテキストファイルにcounty_dataの内容を書き込む
</code></pre>
<p class="tx">このコードは、<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールと、最終的な郡のデータを出力するのに使う<span class="thesansmonocd_w5regular_">pprint</span>モジュールをインポートしています(<span class="codeannotation" aria-label="annotation1">❶</span>)。次に、<i class="calibre5">censuspopdata.xlsx</i>ファイルを開き(<span class="codeannotation" aria-label="annotation2">❷</span>)、国勢調査データが入ったシートを取得します(<span class="codeannotation" aria-label="annotation3">❸</span>)。そして、各行を反復処理します(<span class="codeannotation" aria-label="annotation4">❹</span>)。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">county_data</span>という名前の変数を作成していることに注目してください。この変数に郡ごとに集計する人口と国勢統計区数を格納します。変数にデータを格納する前に、どのようなデータ構造にするかを決める必要があります。</p>
</section>
<section type="division" aria-labelledby="sec8">
<h4 class="h1" id="calibre_link-1839"><span id="calibre_link-379"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：データ構造にデータを投入する</span></h4>
<p class="tni">合衆国では、州には2文字の略称があり、州はさらに郡へと細分化されます。<span class="thesansmonocd_w5regular_">county_data</span>に格納されるデータ構造は、州の略称をキーとする辞書です。州の略称は、その州の郡の名前をキーとする別の辞書へと対応づけられます。各郡の名前は、<span class="thesansmonocd_w5regular_">'tracts'</span>と<span class="thesansmonocd_w5regular_">'pop'</span>という2つのキーを持つ辞書へと対応づけられます。これらのキーは、その郡の国勢統計区数と人口へと対応づけられます。この辞書は次のような構造をしています。</p>
<pre class="pre"><code class="calibre9">{'AK': {'Aleutians East': {'pop': 3141, 'tracts': 1},
        'Aleutians West': {'pop': 5561, 'tracts': 2},
        'Anchorage': {'pop': 291826, 'tracts': 55},
        'Bethel': {'pop': 17013, 'tracts': 3},
        'Bristol Bay': {'pop': 997, 'tracts': 1},
        <span class="sans_thesansmonocd_w5regular_italic_">--snip--</span>
</code></pre>
<p class="tx">この辞書が<span class="thesansmonocd_w5regular_">county_data</span>に格納されているとすると、以下の式はこのように評価されます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">county_data['AK']['Anchorage']['pop']</b>
291826
&gt;&gt;&gt; <b class="calibre10">county_data['AK']['Anchorage']['tracts']</b>
55
</code></pre>
<p class="tx">一般化すると、辞書<span class="thesansmonocd_w5regular_">county_data</span>のキーは次のとおりです。</p>
<pre class="pre"><code class="calibre9">county_data[<var class="calibre20">state abbrev</var>][<var class="calibre20">county</var>]['tracts']
county_data[<var class="calibre20">state abbrev</var>][<var class="calibre20">county</var>]['pop']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">county_data</span>の構造がわかったので、郡のデータでこの変数を埋めていくコードを書けます。プログラムの末尾に以下のコードを追加してください。</p>
<pre class="pre"><code class="calibre9"># readCensusExcel.py - 郡の人口と国勢統計区を集計する

<var class="calibre20">--snip--</var>

for row in range(2, sheet.max_row + 1):
    # Excelファイルの各行は一つの国勢統計区のデータ
    state  = sheet['B' + str(row)].value
    county = sheet['C' + str(row)].value
    pop    = sheet['D' + str(row)].value

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1109" aria-label="341"></span><b class="calibre10">    # 州のキーが存在することを保証する</b>
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation1">❶</span><b class="calibre10"> county_data.setdefault(state, {})</b>
<b class="calibre10">    # 郡のキーが存在することを保証する</b>
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation2">❷</span><b class="calibre10"> county_data[state].setdefault(county, {'tracts': 0, 'pop': 0})</b>

<b class="calibre10">    # 各行は一つの国勢統計区のデータなので1増やす</b>
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation3">❸</span><b class="calibre10"> county_data[state][county]['tracts'] += 1</b>
<b class="calibre10">    # この国勢統計区の人口分だけ郡の人口を増やす</b>
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation4">❹</span><b class="calibre10"> county_data[state][county]['pop'] += int(pop)</b>

# TODO: 新しいテキストファイルにcounty_dataの内容を書き込む
</code></pre>
<p class="tx">コードの最後の2行で実際の集計作業を行っています。<span class="thesansmonocd_w5regular_">for</span>ループの反復ごとに、その郡について、<span class="thesansmonocd_w5regular_">tracts</span>の値を1増やし(<span class="codeannotation" aria-label="annotation3">❸</span>)、<span class="thesansmonocd_w5regular_">pop</span>の値を加算しています(<span class="codeannotation" aria-label="annotation4">❹</span>)。</p>
<p class="tx">コードのその他の部分は、州の略称のキーが<span class="thesansmonocd_w5regular_">county_data</span>に存在していなければ、その州の値として郡の辞書を追加できないという問題に対応するためのものです（<span class="thesansmonocd_w5regular_">'AK'</span>キーが存在しなければ<span class="thesansmonocd_w5regular_">county_data['AK']['Anchorage']['tracts']</span> <span class="thesansmonocd_w5regular_">+=</span> <span class="thesansmonocd_w5regular_">1</span>がエラーを引き起こします）。データ構造に州の略称のキーが存在することを保証するために、<span class="thesansmonocd_w5regular_">state</span>が存在しなければ値を設定する<span class="thesansmonocd_w5regular_">setdefault()</span>メソッドを呼び出す必要があります(<span class="codeannotation" aria-label="annotation1">❶</span>)。</p>
<p class="tx">辞書<span class="thesansmonocd_w5regular_">county_data</span>には各州の略称をキーとする値として辞書が必要なのと同じように、その辞書にはそれぞれ郡をキーとする値としての辞書が必要です(<span class="codeannotation" aria-label="annotation2">❷</span>)。そして、今度はその辞書に関して、<span class="thesansmonocd_w5regular_">'tracts'</span>と<span class="thesansmonocd_w5regular_">'pop'</span>のキーが<span class="thesansmonocd_w5regular_">0</span>で始まる値が必要になります。（この説明の辞書の構造を追えなかったら、本節の冒頭に示した例に戻って考えてください。）</p>
<p class="tx">キーがすでに存在する場合に、<span class="thesansmonocd_w5regular_">setdefault()</span>は何もしないので、<span class="thesansmonocd_w5regular_">for</span>ループの反復ごとに呼び出しても問題ありません。</p>
</section>
<section type="division" aria-labelledby="sec9">
<h4 class="h1" id="calibre_link-1840"><span id="calibre_link-380"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：結果をファイルに書き込む</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">for</span>ループが終わったら、辞書<span class="thesansmonocd_w5regular_">county_data</span>には、郡と州をキーとする、すべての人口と国勢統計区情報が含まれています。このデータをテキストファイルや別のExcelファイルに書き出すコードを書くこともできますが、今は<span class="thesansmonocd_w5regular_">pprint.pformat()</span>関数で辞書<span class="thesansmonocd_w5regular_">county_data</span>の値を<i class="calibre5">census2010.py</i>という名前のファイルに大きな文字列として書き込みましょう。以下のコードをプログラムの末尾に追加してください（<span class="thesansmonocd_w5regular_">for</span>ループの外側になるようにインデントしないことに注意してください）。</p>
<pre class="pre"><code class="calibre9"># readCensusExcel.py - 郡の人口と国勢統計区を集計する

<var class="calibre20">--snip--</var>

<b class="calibre10"># 新しいテキストファイルにcounty_dataの内容を書き込む</b>
<b class="calibre10">print('Writing results...')</b>
<b class="calibre10">result_file = open('census2010.py', 'w')</b>
<b class="calibre10">result_file.write('allData = ' + pprint.pformat(county_data))</b>
<b class="calibre10">result_file.close()</b>
<b class="calibre10">print('Done.')</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1002" aria-label="342"></span><span class="thesansmonocd_w5regular_">pprint.pformat()</span>関数は、Pythonコードとして使えるように文字列をフォーマットします。それを<i class="calibre5">census2010.py</i>という名前のテキストファイルに出力することにより、PythonプログラムがらPythonプログラムを生成しました。これは複雑に思われるかもしれませんが、こうすれば他のPythonモジュールと同じように<i class="calibre5">census2010.py</i>をインポートできます。対話型シェルで現在の作業ディレクトリを新しく作成した<i class="calibre5">census2010.py</i>ファイルがあるフォルダに移動してインポートしてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import census2010</b>
&gt;&gt;&gt; <b class="calibre10">census2010.allData['AK']['Anchorage']</b>
{'pop': 291826, 'tracts': 55}
&gt;&gt;&gt; <b class="calibre10">anchorage_pop = census2010.allData['AK']['Anchorage']['pop']</b>
&gt;&gt;&gt; <b class="calibre10">print('The 2010 population of Anchorage was ' + str(anchorage_pop))</b>
The 2010 population of Anchorage was 291826
</code></pre>
<p class="tx"><i class="calibre5">readCensusExcel.py</i>プログラムは使い捨てのコードです。結果を<i class="calibre5">census2010.py</i>に保存すれば、プログラムを二度と実行する必要がありません。郡のデータが必要になれば、<span class="thesansmonocd_w5regular_">import census2010</span>を実行するだけでよいです。</p>
<p class="tx">手動でこのデータを集計すると何時間もかかります。このプログラムなら数秒で集計できます。<span class="thesansmonocd_w5regular_">openpyxl</span>を使うと、苦もなくExcelファイルに保存されている情報を抽出して計算できます。本書のオンライン素材からこのプログラム全体をダウンロードできます。</p>
</section>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1841"><span id="calibre_link-381"></span><span class="sans_futura_std_heavy_oblique_bi_">似たようなプログラムのアイデア</span></h4>
<p class="tni">仕事でExcelを使ってさまざまなデータを保存することは多く、Excelファイルが大きくなりすぎて手に負えなくなることも珍しくありません。Excelファイルを解析するプログラムはどれも似たような構成になります。Excelファイルを読み込み、変数やデータ構造を用意して、Excelファイルの各行をループするという構成です。そうしたプログラムで以下のような作業を行えます。</p>
<ul class="ul">
<li class="bl">Excelファイルの複数の行のデータを比較する</li>
<li class="bl">複数のExcelファイルを開いてファイル間のデータを比較する</li>
<li class="bl">Excelファイルに空行など不適切なデータがあるかどうかを確認し、あれば警告を発する</li>
<li class="bl">Excelファイルからデータを読み取り、Pythonプログラムの入力として使う</li>
</ul>
</section>
</section>
<section type="division" aria-labelledby="sec11">
<h3 class="h" id="calibre_link-1842"><span id="calibre_link-382"></span><span class="sans_futura_std_bold_b_">Excelファイルの書き込み</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールを使うとデータの書き込みもできます。プログラムからExcelファイルを作成したり編集したりできるということです。Pythonでは、数千行のデータがあるExcelファイルでも簡単に作成できます。</p>
<section type="division" aria-labelledby="sec12">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1072" aria-label="343"></span>
<h4 class="h1" id="calibre_link-1843"><span id="calibre_link-383"></span><span class="sans_futura_std_heavy_oblique_bi_">Excelファイルの作成と保存</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">openpyxl.Workbook()</span>関数を呼び出すと、新しい空白の<span class="thesansmonocd_w5regular_">Workbook</span>オブジェクトを作成します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()  </b># 空白のワークブックを作成
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames  </b># ワークブックには1シートある
['Sheet']
&gt;&gt;&gt; <b class="calibre10">sheet = wb.active</b>
&gt;&gt;&gt; <b class="calibre10">sheet.title</b>
'Sheet'
&gt;&gt;&gt; <b class="calibre10">sheet.title = 'Spam Bacon Eggs Sheet'  </b># シート名の変更
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames</b>
['Spam Bacon Eggs Sheet']
</code></pre>
<p class="tx">ワークブックには<i class="calibre5">Sheet</i>という名前の1シートがあります。<span class="thesansmonocd_w5regular_">title</span>属性に文字列を格納すると、そのシートの名前を変更できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">Workbook</span>オブジェクトやそのシートまたはセルを変更しても、<span class="thesansmonocd_w5regular_">save()</span>ワークブックメソッドを呼び出すまではExcelファイルが保存されません。以下の式を対話型シェルに入力してみてください。（<i class="calibre5">example3.xlsx</i>が現在の作業ディレクトリにあることを前提としています。）</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('example3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet1']</b>
&gt;&gt;&gt; <b class="calibre10">sheet.title = 'Spam Spam Spam'</b>
&gt;&gt;&gt; <b class="calibre10">wb.save('example3_copy.xlsx')  </b># ワークブックの保存
</code></pre>
<p class="tx">ここではシート名を変更しています。ファイル名を文字列で<span class="thesansmonocd_w5regular_">save()</span>メソッドに渡して、その変更を保存しています。<span class="thesansmonocd_w5regular_">'example3_copy.xlsx'</span>のような、元のファイル名とは異なるファイル名を渡すと、変更したファイルを別のExcelファイルに保存します。</p>
<p class="tx">ファイルから読み込んだExcelファイルを編集するときは、常に元ファイルとは別の名前で新しい編集後のExcelファイルを保存するようにしてください。そうすれば、コードにバグがあって新しく保存したファイルのデータを破損していたとしても、元のExcelファイルから作業をやり直せます。また、<span class="thesansmonocd_w5regular_">save()</span>メソッドはExcelファイルがデスクトップアプリケーションで開かれていると機能しません。Excelファイルを閉じてからPythonプログラムを実行してください。</p>
</section>
<section type="division" aria-labelledby="sec13">
<h4 class="h1" id="calibre_link-1844"><span id="calibre_link-384"></span><span class="sans_futura_std_heavy_oblique_bi_">シートの作成と削除</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">create_sheet()</span>メソッドでワークブックからシートを作成し、<span class="thesansmonocd_w5regular_">del</span>演算子でシートを削除します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames</b>
['Sheet']
&gt;&gt;&gt; <b class="calibre10">wb.create_sheet()  </b># 新しいシートの追加
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1306" aria-label="344"></span>&lt;Worksheet "Sheet1"&gt;
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames</b>
['Sheet', 'Sheet1']
&gt;&gt;&gt; # インデックス0に新しいシートを作成
&gt;&gt;&gt; <b class="calibre10">wb.create_sheet(index=0, title='First Sheet')</b>
&lt;Worksheet "First Sheet"&gt;
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames</b>
['First Sheet', 'Sheet', 'Sheet1']
&gt;&gt;&gt; <b class="calibre10">wb.create_sheet(index=2, title='Middle Sheet')</b>
&lt;Worksheet "Middle Sheet"&gt;
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames</b>
['First Sheet', 'Sheet', 'Middle Sheet', 'Sheet1']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">create_sheet()</span>メソッドは、<span class="thesansmonocd_w5regular_">Sheet</span><span class="sans_thesansmonocd_w5regular_italic_">X</span>（<span class="sans_thesansmonocd_w5regular_italic_">X</span>にはそのワークブックで最後の番号が入ります）という名前の新しい<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトを返します。新しいシートのインデックスと名前をそれぞれ<span class="thesansmonocd_w5regular_">index</span>と<span class="thesansmonocd_w5regular_">title</span>のキーワード引数で指定することもできます。</p>
<p class="tx">前の例から続けて以下の内容を入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">wb.sheetnames</b>
['First Sheet', 'Sheet', 'Middle Sheet', 'Sheet1']
&gt;&gt;&gt; <b class="calibre10">del wb['Middle Sheet']</b>
&gt;&gt;&gt; <b class="calibre10">del wb['Sheet1']</b>
&gt;&gt;&gt; <b class="calibre10">wb.sheetnames</b>
['First Sheet', 'Sheet']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">del</span>演算子でワークブックからシートを削除できます。辞書からキーと値のペアを削除するのと同じ要領です。</p>
<p class="tx">ワークブックでシートの作成や削除をしたら、<span class="thesansmonocd_w5regular_">save()</span>メソッドを呼び出してその変更を保存します。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1845"><span id="calibre_link-385"></span><span class="sans_futura_std_heavy_oblique_bi_">セルへの値の書き込み</span></h4>
<p class="tni">セルへの値の書き込みは、辞書のキーに値を書き込むのと同じです。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet']</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A1'] = 'Hello, world!'  </b># セルの値を編集
&gt;&gt;&gt; <b class="calibre10">sheet['A1'].value</b>
'Hello, world!'
</code></pre>
<p class="tx">セル座標の文字列を<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトの辞書のキーのように用いることで、セルを指定して値を書き込めます。</p>
<p class="ph"><span id="calibre_link-386"></span><span class="sans_futura_std_heavy_b_">プロジェクト10：Excelファイルの更新</span></p>
<p class="tni">このプロジェクトでは、農産物売上Excelファイル中のセルを更新するプログラムを書きます。Excelファイルから特定の種類の農産物を見つけ出して、その価格を更新します。本書のオンライン素材からこの<i class="calibre5">produceSales3.xlsx</i>のExcelファイルをダウンロードしてください。図14-3はそのExcelファイルを示しています。</p>
<figure class="img"><img class="img1" id="calibre_link-759" src="images/000021.jpg" alt="An Excel spreadsheet with the columns “PRODUCE”, “COST PER POUND”, “POUNDS SOLD”, and “TOTAL”. The rows contain details about various produce items." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-3：農産物売上のExcelファイル</span></p></figcaption>
</figure>
<p class="tx">各行がそれぞれの売上を表しています。列は、農産物の種類(A)、1ポンドあたりの価格(B)、販売ポンド数(C)、総売上(D)です。総売上の列には、<i class="calibre5">=ROUND(B2*C2, 2)</i>のような、その行の1ポンドあたりの価格と販売ポンド数をかけ算して小数第2位で丸めるExcelの数式が設定されています。この数式により、総売上列のセルは、1ポンドあたりの価格(B)列と販売ポンド数(C)列に変更があれば自動的に更新されます。</p>
<p class="tx">garlic（にんにく）、celery（セロリ）、lemons（レモン）の価格を誤って入力してしまっていたことに気づきました。このExcelファイルの数千行に目を通してgarlic、celery、lemonsの行の価格を更新するという退屈な作業をしなければなりません。価格を単純に置換することはできません。というのも、同じ価格の別の農産物があるかもしれず、これを更新したくはないからです。数千行もあれば手動だと数時間はかかるでしょう。しかしプログラムを書けば数秒でその作業を実行できます。</p>
<p class="tx">このプログラムには以下の内容が必要です。</p>
<ul class="ul">
<li class="bl">各行をループ処理する</li>
<li class="bl">garlic、celery、lemonsの行であれば、価格を更新する</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl">Excelファイルを開く</li>
<li class="bl">各行について、A列の値が<span class="thesansmonocd_w5regular_">Celery</span>、<span class="thesansmonocd_w5regular_">Garlic</span>、<span class="thesansmonocd_w5regular_">Lemon</span>であるかどうかを確認する</li>
<li class="bl">該当すればB列の価格を更新する</li>
<li class="bl">Excelファイルを新しいファイルに保存する（万一の場合に元ファイルの情報を保持できるように）</li>
</ul>
</section>
<section type="division" aria-labelledby="sec15">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1308" aria-label="346"></span>
<h4 class="h1" id="calibre_link-1846"><span id="calibre_link-387"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：更新する情報のデータ構造を定める</span></h4>
<p class="tni">更新する必要のある価格は次のとおりです。</p>
<ul class="ul">
<li class="bl">Celery: 1.19</li>
<li class="bl">Garlic: 3.07</li>
<li class="bl">Lemon: 1.27</li>
</ul>
<p class="tx">この新しい（正しい）価格を、次のようにコードに書くことができます。</p>
<pre class="pre"><code class="calibre9">if produce_name == 'Celery':
    cell_obj = 1.19
if produce_name == 'Garlic':
    cell_obj = 3.07
if produce_name == 'Lemon':
    cell_obj = 1.27
</code></pre>
<p class="tx">しかし、このように農産物の更新後の価格をハードコードするのは美しくありません。別の農産物について別の価格でExcelファイルをまた更新する必要が生じたときに、コードを何箇所も変更しなければなりません。コードを変更する箇所が多ければ多いほど、バグの可能性が高くなります。</p>
<p class="tx">正しい価格情報を辞書に保存し、コードでそのデータ構造を使うと、もっと柔軟に解決できます。新しいファイルエディタのタブで次のコードを入力してください。</p>
<pre class="pre"><code class="calibre9"># updateProduce.py - 農産物売上Excelファイルの価格を修正

import openpyxl

wb = openpyxl.load_workbook('produceSales3.xlsx')
sheet = wb['Sheet']

# 農産物の種類と更新後の価格
PRICE_UPDATES = {'Garlic': 3.07,
                 'Celery': 1.19,
                 'Lemon': 1.27}

# TODO: 行をループして価格を更新
</code></pre>
<p class="tx">これを<i class="calibre5">updateProduce.py</i>という名前で保存してください。Excelファイルをまた更新する必要が生じても、辞書<span class="thesansmonocd_w5regular_">PRICE_UPDATES</span>を更新するだけですみ、コードの他の部分はそのままで大丈夫です。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h4 class="h1" id="calibre_link-1847"><span id="calibre_link-388"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：すべての行を確認して誤った価格を更新する</span></h4>
<p class="tni">プログラムの次の部分では、Excelファイルのすべての行をループで反復処理します。<i class="calibre5">updateProduce.py</i>の末尾に次のコードを追加してください。</p>
<pre class="pre"><code class="calibre9"># updateProduce.py - 農産物売上Excelファイルの価格を修正

<var class="calibre20">--snip--</var>

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1307" aria-label="347"></span><b class="calibre10"># 行をループして価格を更新</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span><b class="calibre10"> for row_num in range(2, sheet.max_row + 1):  </b># 最初の行は飛ばす
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation2">❷</span><b class="calibre10"> produce_name = sheet.cell(row=row_num, column=1).value</b>
  <span class="code_codeannotation" aria-label="annotation3">❸</span><b class="calibre10"> if produce_name in PRICE_UPDATES:</b>
<b class="calibre10">        sheet.cell(row=row_num, column=2).value = PRICE_UPDATES[produce_name]</b>

<span class="codeannotated_codeannotation" aria-label="annotation4">❹</span> <b class="calibre10">wb.save('updatedProduceSales3.xlsx')</b>
</code></pre>
<p class="tx">1行目はヘッダー（見出し）なので、2行目からループを開始します(<span class="codeannotation" aria-label="annotation1">❶</span>)。1列目（A列）のセルの値を変数<span class="thesansmonocd_w5regular_">produce _name</span>に格納します(<span class="codeannotation" aria-label="annotation2">❷</span>)。<span class="thesansmonocd_w5regular_">produce_name</span>が辞書<span class="thesansmonocd_w5regular_">PRICE_UPDATES</span>のキーに存在すれば(<span class="codeannotation" aria-label="annotation3">❸</span>)、この行は価格を更新する必要があるとわかります。正しい価格は<span class="thesansmonocd_w5regular_">PRICE _UPDATES[produce_name]</span>です。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">PRICE_UPDATES</span>を使うとコードがとてもクリーンになったことがおわかりでしょう。<span class="thesansmonocd_w5regular_">if produce_name</span> <span class="thesansmonocd_w5regular_">==</span> <span class="thesansmonocd_w5regular_">'Garlic':</span>のように更新する農産物ごとに<span class="thesansmonocd_w5regular_">if</span>の行を書くのではなく、<span class="thesansmonocd_w5regular_">if</span>文は1つだけになります。そして、ソースコードでは農産物の種類と正しい価格を<span class="thesansmonocd_w5regular_">for</span>ループにハードコードせずに辞書<span class="thesansmonocd_w5regular_">PRICE_UPDATES</span>を使っているため、価格をさらに変更する必要が生じたとしても、辞書<span class="thesansmonocd_w5regular_">PRICE_UPDATES</span>を修正するだけですみ、コードの残りの部分は変更する必要がありません。</p>
<p class="tx">Excelファイル全体の処理が終われば、<span class="thesansmonocd_w5regular_">Workbook</span>オブジェクトを<i class="calibre5">updatedProduceSales3.xlsx</i>に保存します(<span class="codeannotation" aria-label="annotation4">❹</span>)。万一プログラムにバグがあり更新後のExcelファイルがおかしくなっているといけないので、古いExcelファイルを上書きしないようにしています。更新後のExcelファイルを確認して正しく作成されていれば、古いExcelファイルを削除できます。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h4 class="h1"><span id="calibre_link-1848"></span><span id="calibre_link-389"></span><span class="sans_futura_std_heavy_oblique_bi_">似たようなプログラムのアイデア</span></h4>
<p class="tni">事務関係の仕事をする人はExcelファイルをしょっちゅう使いますから、自動的にExcelファイルを編集して書き込めるプログラムは大いに役立つでしょう。そうしたプログラムで以下のような作業を行えます。</p>
<ul class="ul">
<li class="bl">一つのExcelファイルからデータを読み取り、別のExcelファイルに書き込む</li>
<li class="bl">ウェブサイト、テキストファイル、クリップボードからデータを読み取り、Excelファイルに書き込む</li>
<li class="bl">自動的にExcelファイルのデータを整理する。例えば、正規表現を使って電話番号の複数のフォーマットを読み取り、標準的なフォーマットに統一する。</li>
</ul>
</section>
</section>
<section type="division" aria-labelledby="sec18">
<h3 class="h" id="calibre_link-1849"><span id="calibre_link-390"></span><span class="sans_futura_std_bold_b_">セルのフォントスタイルを設定する</span></h3>
<p class="tni">特定のセルや行や列のスタイルを設定できれば、Excelファイルで重要な箇所を強調するのに役立ちます。例えば、先ほどの農産物Excelファイルで、potato（じゃがいも）、garlic（にんにく）、parsnip（白ニンジン）の行を太字にすることができます。あるいは、1ポンドあたりの価格が5ドルよりも大きい行をすべて斜体にしたいことがあるかもしれません。大きなExcelファイルの一部を手動でスタイル設定するのは面倒ですが、プログラムなら一瞬でその作業をしてくれます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-993" aria-label="348"></span>セルのフォントスタイルを調整するには、<span class="thesansmonocd_w5regular_">openpyxl.styles</span>モジュールから<span class="thesansmonocd_w5regular_">Font()</span>関数をインポートします。</p>
<pre class="pre"><code class="calibre9">from openpyxl.styles import Font</code></pre>
<p class="tx">この関数をこのようにインポートすると、<span class="thesansmonocd_w5regular_">openpyxl.styles.Font()</span>ではなく<span class="thesansmonocd_w5regular_">Font()</span>と書けます（詳しくは<span>第3章の「モジュールのインポート」</span>を参照してください）。</p>
<p class="tx">以下の例では、新しいワークブックを作成し、A1セルを24ポイントの斜体に設定しています。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">from openpyxl.styles import Font</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet']</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">italic_24_font = Font(size=24, italic=True) </b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">sheet['A1'].font = italic_24_font </b>
&gt;&gt;&gt; <b class="calibre10">sheet['A1'] = 'Hello, world!'</b>
&gt;&gt;&gt; <b class="calibre10">wb.save('styles3.xlsx')</b>
</code></pre>
<p class="tx">この例で、<span class="thesansmonocd_w5regular_">Font(size=24, italic=True)</span>は<span class="thesansmonocd_w5regular_">Font</span>オブジェクトを返します。それを <span class="thesansmonocd_w5regular_">italic_24_font</span>に格納しています(<span class="codeannotation" aria-label="annotation1">❶</span>)。<span class="thesansmonocd_w5regular_">Font()</span>のキーワード引数でこのオブジェクトのスタイル情報を設定でき、<span class="thesansmonocd_w5regular_">sheet['A1'].font</span>に<span class="thesansmonocd_w5regular_">italic _24_font</span>オブジェクトを代入しています(<span class="codeannotation" aria-label="annotation2">❷</span>)。これにより、フォントスタイルの情報がすべてA1セルに適用されます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">font</span>属性を設定するには、<span class="thesansmonocd_w5regular_">Font()</span>にキーワード引数を渡します。表14-2は<span class="thesansmonocd_w5regular_">Font()</span>関数に渡せるキーワード引数を示しています。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-761"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 14-2：</span></span><span class="thesansmonocd_w5regular_">Font</span><span class="sans_futura_std_book_">オブジェクトのキーワード引数</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">キーワード引数</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">データ型</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">説明</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">name</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">文字列</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">'Calibri'</span><span class="sans_futura_std_book_">や</span><span class="thesansmonocd_w5regular_">'Times New Roman'</span>のようなフォント名</p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">size</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">整数</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">フォントサイズ</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">bold</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">ブール</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">で太字に</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">italic</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">ブール</span></p></td>
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">で斜体に</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span class="thesansmonocd_w5regular_">Font()</span>を呼び出して<span class="thesansmonocd_w5regular_">Font</span>オブジェクトを作成し、その<span class="thesansmonocd_w5regular_">Font</span>オブジェクトを変数に格納します。その変数を<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトの<span class="thesansmonocd_w5regular_">font</span>属性に代入します。以下のコードではさまざまなフォントスタイルを作成しています。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">from openpyxl.styles import Font</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet']</b>
&gt;&gt;&gt; <b class="calibre10">bold_font = Font(name='Times New Roman', bold=True)</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A1'].font = bold_font</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A1'] = 'Bold Times New Roman'</b>

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1141" aria-label="349"></span>&gt;&gt;&gt; <b class="calibre10">italic_font = Font(size=24, italic=True)</b>
&gt;&gt;&gt; <b class="calibre10">sheet['B3'].font = italic_font</b>
&gt;&gt;&gt; <b class="calibre10">sheet['B3'] = '24 pt Italic'</b>

&gt;&gt;&gt; <b class="calibre10">wb.save('styles3.xlsx')</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">bold_font</span>に<span class="thesansmonocd_w5regular_">Font</span>オブジェクトを格納して、A1の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトの<span class="thesansmonocd_w5regular_">font</span>属性に<span class="thesansmonocd_w5regular_">bold_font</span>を設定しています。別の<span class="thesansmonocd_w5regular_">Font</span>オブジェクトで同じことを繰り返し、2つ目のセルにフォントを設定しています。このコードを実行すると、ExcelファイルのA1セルとB3セルのスタイルは、図14-4のように調整されています。</p>
<figure class="img"><img class="img2" id="calibre_link-762" src="images/000022.jpg" alt="An Excel spreadsheet in which cell A1 contains the text “Bold Times New Roman” in a bolded Times New Roman font and cell B3 contains the text” 24 pt Italic” in a large, italicized font." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-4：フォントスタイルを調整したExcelファイル</span></p></figcaption>
</figure>
<p class="tx">A1セルには<span class="thesansmonocd_w5regular_">'Times New Roman'</span>という名前のフォントで<span class="thesansmonocd_w5regular_">bold</span>を<span class="thesansmonocd_w5regular_">true</span>に設定しました。よって、テキストは太字のTimes New Romanになっています。サイズは指定しなかったので、<span class="thesansmonocd_w5regular_">openpyxl</span>のデフォルトの11です。B3セルは、テキストが斜体でサイズが24になっています。フォント名は指定しませんでしたから、<span class="thesansmonocd_w5regular_">openpyxl</span>のデフォルトのCalibriになっています。</p>
</section>
<section type="division" aria-labelledby="sec19">
<h3 class="h" id="calibre_link-1850"><span id="calibre_link-391"></span><span class="sans_futura_std_bold_b_">数式</span></h3>
<p class="tni">Excelの数式は、イコール記号で始まり、別のセルを参照した計算結果の値を設定できます。この節では、<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールをプログラムで使用してセルに数式を書き込みます。通常の値を書き込むのと同じ要領です。例を示します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">sheet['B9'] = '=SUM(B1:B8)'</b></code></pre>
<p class="tx">このコードはB9に<i class="calibre5">=SUM(B1:B8)</i>という数式を入れます。このセルの値はB1セルからB8セルまでの値の合計値になります。図14-5にその様子を示します。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1091" aria-label="350"></span>
<figure class="img"><img class="img2" id="calibre_link-763" src="images/000023.jpg" alt="An Excel spreadsheet containing a list of numbers in column B. Cell A9 contains the text “TOTAL:”, and cell B9 contains the sum of the other values in column B. The cell is highlighted, and the formula =SUM(B1:B8) is shown in the interface’s top-right corner." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-5：B9セルにはB1セルからB8セルまでを合計する数式が入っている</span></p></figcaption>
</figure>
<p class="tx">Excelの数式をほかのテキスト値と同じようにセルに入れられます。例えば、次のように対話型シェルに入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet']</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A1'] = 200</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A2'] = 300</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A3'] = '=SUM(A1:A2)'</b> # 数式を設定
&gt;&gt;&gt; <b class="calibre10">wb.save('writeFormula3.xlsx')</b>
</code></pre>
<p class="tx">A1セルには200、A2セルには300を入れます。A3セルにはA1セルとA2セルの値を合計する数式を入れます。Excelファイルを開くと、A3には500という値が表示されます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールにはExcelの数式を計算してその結果をセルに入れる機能はありません。しかし、<i class="calibre5">writeFormula3.xlsx</i>ファイルをExcelで開くと、Excelが数式の計算結果を入れてくれます。Excelファイルを保存し、<span class="thesansmonocd_w5regular_">data_only=True</span>キーワード引数を<span class="thesansmonocd_w5regular_">openpyxl.load_workbook()</span>に渡してそのExcelファイルを開けば、セルの値は数式を表す文字列ではなく計算結果になります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; # 先にwriteFormula3.xlsxをExcelで開いて保存してから以下のコードを実行する
&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('writeFormula3.xlsx')</b>  # data_onlyなしで開く
&gt;&gt;&gt; <b class="calibre10">wb.active['A3'].value</b>  # 数式の文字列を取得
'=SUM(A1:A2)'
&gt;&gt;&gt;<b class="calibre10"> wb = openpyxl.load_workbook('writeFormula3.xlsx', data_only=True)</b>  # data_onlyありで開く
&gt;&gt;&gt; <b class="calibre10">wb.active['A3'].value</b>  # 数式の計算結果を取得
500
</code></pre>
<p class="tx">このExcelファイルをExcelで開いて保存してからでないと、<span class="thesansmonocd_w5regular_">500</span> という結果は表示されません。Excelは数式を計算してその結果をExcelファイルに保存します。<span class="thesansmonocd_w5regular_">openpyxl.load_workbook()</span>に<span class="thesansmonocd_w5regular_">data_only=True</span>を渡すと、<span class="thesansmonocd_w5regular_">openpyxl</span>がその値を読み取ります。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1034" aria-label="351"></span>Excelの数式を使うと一定程度のプログラミングができますが、複雑な作業になるとすぐに扱いきれなくなります。例えば、Excelの数式の熟練者でも、<i class="calibre5">=IFERROR(TRIM(IF(LEN(VLOOKUP(F7, Sheet2!$A$1:$B$10000, 2, FALSE))&gt;0,SUBSTITUTE(VLOOKUP(F7, Sheet2!$A$1:$B$10000, 2, FALSE), " ", ""),"")), "")</i>を解読するのに苦労するでしょう。Pythonのコードははるかに読みやすいです。</p>
</section>
<section type="division" aria-labelledby="sec20">
<h3 class="h" id="calibre_link-1851"><span id="calibre_link-392"></span><span class="sans_futura_std_bold_b_">行と列を調整する</span></h3>
<p class="tni">Excelでは、行や列の見出し部分をクリックしてドラッグすれば簡単に行や列のサイズを調整できます。しかしセルの内容に基づいて行や列のサイズを設定する必要がある場合や、多数のExcelファイルの行や列のサイズを調整する必要がある場合は、Pythonのプログラムを書いたほうが早いです。</p>
<p class="tx">行や列を非表示にしたり、常に画面に表示して印刷の各ページに表示されるようにその場所に固定したりすることもできます（見出しに使えます）。</p>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1852"><span id="calibre_link-393"></span><span class="sans_futura_std_heavy_oblique_bi_">行の高さと列の幅を設定する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトには、行の高さを制御する<span class="thesansmonocd_w5regular_">row_dimensions</span>属性と、列の幅を制御する<span class="thesansmonocd_w5regular_">column_dimensions</span>属性があります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet']</b>
&gt;&gt;&gt; <b class="calibre10">sheet['A1'] = 'Tall row'</b>
&gt;&gt;&gt; <b class="calibre10">sheet['B2'] = 'Wide column'</b>
&gt;&gt;&gt; <b class="calibre10">sheet.row_dimensions[1].height = 70</b>
&gt;&gt;&gt; <b class="calibre10">sheet.column_dimensions['B'].width = 20</b>
&gt;&gt;&gt; <b class="calibre10">wb.save('dimensions3.xlsx')</b>
</code></pre>
<p class="tx">シートの<span class="thesansmonocd_w5regular_">row_dimensions</span>と<span class="thesansmonocd_w5regular_">column_dimensions</span>は辞書のような値です。<span class="thesansmonocd_w5regular_">row_dimensions</span>は<span class="thesansmonocd_w5regular_">RowDimension</span>オブジェクトを含み、<span class="thesansmonocd_w5regular_">column_dimensions</span>は<span class="thesansmonocd_w5regular_">ColumnDimension</span>オブジェクトを含みます。<span class="thesansmonocd_w5regular_">row_dimensions</span>では、行番号（この例では1や2）でそのオブジェクトにアクセスできます。<span class="thesansmonocd_w5regular_">column_dimensions</span>では、列を表す文字（この例ではAやB）でそのオブジェクトにアクセスできます。</p>
<p class="tx"><i class="calibre5">dimensions3.xlsx</i>のExcelファイルは、図14-6のように見えます。</p>
<figure class="img"><img class="img2" id="calibre_link-764" src="images/000024.jpg" alt="An Excel spreadsheet in which row 1 is taller than usual and column B is wider than usual. Cell A1 contains the text “Tall row” and cell B1” contains the text “Wide column”." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-6：1行目の高さとB列の幅を広げた様子</span></p></figcaption>
</figure>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1036" aria-label="352"></span>デフォルトの高さと幅はExcelや<span class="thesansmonocd_w5regular_">openpyxl</span>のバージョンによって異なります。</p>
</section>
<section type="division" aria-labelledby="sec22">
<h4 class="h1" id="calibre_link-1853"><span id="calibre_link-394"></span><span class="sans_futura_std_heavy_oblique_bi_">セルの結合と結合の解除</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">merge _cells()</span>シートメソッドで長方形の範囲のセルを一つのセルに結合できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet']</b>
&gt;&gt;&gt; <b class="calibre10">sheet.merge_cells('A1:D3')  </b># この範囲のセルを結合
&gt;&gt;&gt; <b class="calibre10">sheet['A1'] = 'Twelve cells merged together.'</b>
&gt;&gt;&gt; <b class="calibre10">sheet.merge_cells('C5:D5')  </b># 2つのセルを結合
&gt;&gt;&gt; <b class="calibre10">sheet['C5'] = 'Two merged cells.'</b>
&gt;&gt;&gt; <b class="calibre10">wb.save('merged3.xlsx')</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">merge_cells()</span>の引数は、結合する長方形の範囲の左上から右下のセルを表す一つの文字列です。<span class="thesansmonocd_w5regular_">'A1:D3'</span>だと12個のセルを一つのセルに結合します。この結合したセルに値を入れるときは、結合したセルの左上のセルに値を入れます。</p>
<p class="tx">このコードを実行すると、<i class="calibre5">merged.xlsx</i>は図14-7のように見えます。</p>
<figure class="img"><img class="img2" id="calibre_link-765" src="images/000025.jpg" alt="An excel spreadsheet in which cells A1 through D3 are all merged into one, with no delineating grid lines. This cell contains the text “Twelve cells merged together.” The cells C5 and B5 are also merged and contain the text “Two merged cells.”" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-7：結合したセル</span></p></figcaption>
</figure>
<p class="tx"><span class="thesansmonocd_w5regular_">unmerge_cells()</span>シートメソッドを呼び出すと、セルの結合を解除します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('merged3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb['Sheet']</b>
&gt;&gt;&gt; <b class="calibre10">sheet.unmerge_cells('A1:D3')  </b># セルの結合を解除
&gt;&gt;&gt; <b class="calibre10">sheet.unmerge_cells('C5:D5')</b>
&gt;&gt;&gt; <b class="calibre10">wb.save('unmerged3.xlsx')</b>
</code></pre>
<p class="tx">この変更を保存してExcelファイルを確認すると、結合したセルが元のセルに分割されていることがわかります。</p>
</section>
<section type="division" aria-labelledby="sec23">
<h4 class="h1" id="calibre_link-1854"><span id="calibre_link-395"></span><span class="sans_futura_std_heavy_oblique_bi_">ウィンドウ枠の固定</span></h4>
<p class="tni">一画面に収まらないほど大きなExcelファイルでは、一番上の行や一番左の列を「固定」すると見やすくなります。固定した列や行の見出しは、Excelファイルをスクロールしても常に表示されたままです。これは<i class="calibre5">ウィンドウ枠の固定</i>と呼ばれます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1168" aria-label="353"></span><span class="thesansmonocd_w5regular_">openpyxl</span>では、各<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトに<span class="thesansmonocd_w5regular_">freeze_panes</span>属性があり、この属性に<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトまたはセルの座標を表す文字列を設定します。この属性はそのセルより上の行と左の列をすべて固定しますが、指定したセル自体は固定されません。<span class="thesansmonocd_w5regular_">freeze _panes</span>に<span class="thesansmonocd_w5regular_">None</span>または<span class="thesansmonocd_w5regular_">'A1'</span>を設定すると、ウィンドウ枠の固定を解除します。表14-3は、どの行と列が固定されるかの<span class="thesansmonocd_w5regular_">freeze_panes</span>の設定例を示しています。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-766"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 14-3：</span></span><span class="sans_futura_std_book_">ウィンドウ枠の固定の例</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_thesansmonocd_w7bold_b_">freeze_panesの設定</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_thesansmonocd_w7bold_b_">固定される行と列</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">sheet.freeze_panes</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'A2'</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">1行目（列は固定されない）</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">sheet.freeze_panes</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'B1'</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">A列（行は固定されない）</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">sheet.freeze_panes</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'C1'</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">A列とB列（業は固定されない）</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">sheet.freeze_panes</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'C2'</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">1行目とA列とB列</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">sheet.freeze_panes</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'A1'</span> <span class="sans_futura_std_book_">or</span> <span class="thesansmonocd_w5regular_">sheet.freeze_panes</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">None</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">行と列の固定なし</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><i class="calibre5">produceSales3.xlsx</i>をダウンロードして、対話型シェルに次のように入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.load_workbook('produceSales3.xlsx')</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb.active</b>
&gt;&gt;&gt; <b class="calibre10">sheet.freeze_panes = 'A2'  </b># A2より上の行を固定
&gt;&gt;&gt; <b class="calibre10">wb.save('freezeExample3.xlsx')</b>
</code></pre>
<p class="tx">図14-8に結果を示します。</p>
<figure class="img"><img class="img1" id="calibre_link-767" src="images/000026.jpg" alt="An Excel spreadsheet in which Row 1 is visible as the user scrolls to the right." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-8：1行目を固定</span></p></figcaption>
</figure>
<p class="tx"><span class="thesansmonocd_w5regular_">freeze_panes</span>属性を<span class="thesansmonocd_w5regular_">'A2'</span>に設定したので、Excelファイルをどこまでスクロールしても1行目が常に表示されます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec24">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-952" aria-label="354"></span>
<h3 class="h" id="calibre_link-1855"><span id="calibre_link-396"></span><span class="sans_futura_std_bold_b_">グラフ</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">openpyxl</span>モジュールは、シートのセルに入ったデータを使った、棒グラフ、折れ線グラフ、散布図、円グラフの作成に対応しています。以下の手順でグラフを作成できます。</p>
<p class="listnumberf">  1. セルの長方形の範囲を選択して<span class="thesansmonocd_w5regular_">Reference</span>オブジェクトを作成する</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">Reference</span>オブジェクトを渡して<span class="thesansmonocd_w5regular_">Series</span>オブジェクトを作成する</p>
<p class="listnumber">  3. <span class="thesansmonocd_w5regular_">Chart</span>オブジェクトを作成する</p>
<p class="listnumber">  4. <span class="thesansmonocd_w5regular_">Chart</span>オブジェクトに<span class="thesansmonocd_w5regular_">Series</span>オブジェクトを追加する</p>
<p class="listnumberl">  5. <span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトに<span class="thesansmonocd_w5regular_">Chart</span>オブジェクトを追加する（オプションでグラフの左上が位置するセルを指定する）</p>
<p class="tx"><span class="thesansmonocd_w5regular_">Reference</span>オブジェクトについては説明が必要でしょう。<span class="thesansmonocd_w5regular_">openpyxl.chart.Reference()</span>関数に以下の5つの引数を渡して<span class="thesansmonocd_w5regular_">Reference</span>オブジェクトを作成します。</p>
<ul class="ul">
<li class="bl">グラフのデータを含む<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクト</li>
<li class="bl">グラフのデータを含む長方形の範囲のセルの左上のセルの行番号と列番号（行番号、列番号という順番で、0ではなく1始まり）</li>
<li class="bl">グラフのデータを含む長方形の範囲のセルの右下のセルの行番号と列番号（行番号、列番号という順番で、0ではなく1始まり）</li>
</ul>
<p class="tx">対話型シェルに以下の内容を入力して、棒グラフをExcelファイルに作成してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import openpyxl</b>
&gt;&gt;&gt; <b class="calibre10">wb = openpyxl.Workbook()</b>
&gt;&gt;&gt; <b class="calibre10">sheet = wb.active</b>
&gt;&gt;&gt; <b class="calibre10">for i in range(1, 11):  </b># A列にデータを作成
...<b class="calibre10">     sheet['A' + str(i)] = i * i</b>
...
&gt;&gt;&gt; <b class="calibre10">ref_obj = openpyxl.chart.Reference(sheet, 1, 1,</b> <b class="calibre10">1, 10)</b>

&gt;&gt;&gt; <b class="calibre10">series_obj = openpyxl.chart.Series(ref_obj, title='First series')</b>

&gt;&gt;&gt; <b class="calibre10">chart_obj = openpyxl.chart.BarChart()</b>
&gt;&gt;&gt; <b class="calibre10">chart_obj.title = 'My Chart'</b>
&gt;&gt;&gt; <b class="calibre10">chart_obj.append(series_obj)</b>

&gt;&gt;&gt; <b class="calibre10">sheet.add_chart(chart_obj, 'C5')</b>
&gt;&gt;&gt; <b class="calibre10">wb.save('sampleChart3.xlsx')</b>
</code></pre>
<p class="tx">このコードを実行すると、図14-9のようなExcelファイルが作成されます。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1218" aria-label="355"></span>
<figure class="img"><img class="img1" id="calibre_link-768" src="images/000027.jpg" alt="An Excel spreadsheet with a numbers populated in column A. In the center of the spreadsheet is a bar chart whose bars correspond to the column A values and are labeled using the row numbers." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-9：グラフを追加したExcelファイル</span></p></figcaption>
</figure>
<p class="tx"><span class="thesansmonocd_w5regular_">openpyxl.chart.BarChart()</span>を呼び出して棒グラフを作成しました。<span class="thesansmonocd_w5regular_">openpyxl.chart .LineChart()</span>で折れ線グラフ、<span class="thesansmonocd_w5regular_">openpyxl.chart.ScatterChart()</span>で散布図、<span class="thesansmonocd_w5regular_">openpyxl.chart.PieChart()</span>で円グラフを作成できます。</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec25">
<h3 class="h" id="calibre_link-1856"><span id="calibre_link-397"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">情報処理の難しい部分は、情報処理そのものではなく、データの正しい形式での入手であることが多いです。ExcelファイルをPythonで読み込めば、手動で行うよりもずっと速くデータを抽出して操作できます。</p>
<p class="tx">プログラムの出力としてもExcelファイルを使うことができます。テキストファイルやPDFファイルから何千もの連絡先をExcelファイルに移す必要があったとしても、退屈なコピーアンドペーストなどしなくてよいです。<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールとプログラミングの知識がいくらかあれば、もっと大きなExcelファイルの処理でも朝飯前です。</p>
<p class="tx">次章では、Pythonを使って、Googleスプレッドシートという、もう一つのスプレッドシートプログラムを扱います。</p>
</section>
<section type="division" aria-labelledby="sec26">
<h3 class="h" id="calibre_link-1857"><span id="calibre_link-398"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="tni">以下の練習問題では、変数<span class="thesansmonocd_w5regular_">wb</span>に<span class="thesansmonocd_w5regular_">Workbook</span>オブジェクトが、変数<span class="thesansmonocd_w5regular_">sheet</span>に<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトが格納されていることを前提にしてください。</p>
<p class="listnumber">  1. <span class="thesansmonocd_w5regular_">openpyxl.load_workbook()</span>関数は何を返しますか？</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">wb.sheetnames</span>ワークブック属性には何が含まれていますか？</p>
<p class="listnumber">  3. <span class="thesansmonocd_w5regular_">'Sheet1'</span>という名前のシートの<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトはどのように取得しますか？</p>
<p class="listnumber"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1242" aria-label="356"></span>  4. ワークブックのアクティブシートの<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトはどのように取得しますか？</p>
<p class="listnumber">  5. C5セルの値はどのように取得しますか？</p>
<p class="listnumber">  6. C5セルに<span class="thesansmonocd_w5regular_">"Hello"</span>という値をどのように設定しますか？</p>
<p class="listnumber">  7. セルの行番号と列番号をどのように取得しますか？</p>
<p class="listnumber">  8. <span class="thesansmonocd_w5regular_">sheet.max_column</span>と<span class="thesansmonocd_w5regular_">sheet.max_row</span>のシート属性には何が入っていて、そのデータ型は何ですか？</p>
<p class="listnumber">  9. <span class="thesansmonocd_w5regular_">'M'</span>列の列番号が知りたいときに、どの関数を呼び出しますか？</p>
<p class="listnumber">10. <span class="thesansmonocd_w5regular_">14</span>列目のアルファベットが知りたいときに、どの関数を呼び出しますか？</p>
<p class="listnumber">11. A1からF1の<span class="thesansmonocd_w5regular_">Cell</span>オブジェクトをすべてタプルで取得するにはどうしますか？</p>
<p class="listnumber">12. ワークブックを<i class="calibre5">example3.xlsx</i>という名前で保存するにはどうしますか？</p>
<p class="listnumber">13. セルに数式を設定するにはどうしますか？</p>
<p class="listnumber">14. セルの数式ではなく数式の計算結果を取得したいときに、まずどうしますか？</p>
<p class="listnumber">15. 5行目の高さを100に設定するにはどうしますか？</p>
<p class="listnumber">16. C列を非表示にするにはどうしますか？</p>
<p class="listnumber">17. ウィンドウ枠の固定とは何ですか？</p>
<p class="listnumber">18. 棒グラフを作成するのに呼び出す5つの関数とメソッドを挙げてください。</p>
</section>
<section type="division" aria-labelledby="sec27">
<h3 class="h" id="calibre_link-1858"><span id="calibre_link-399"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec28">
<h4 class="h1" id="calibre_link-1859"><span id="calibre_link-400"></span><span class="sans_futura_std_heavy_oblique_bi_">かけ算表の作成</span></h4>
<p class="tni">コマンドラインから数値<i class="calibre5">N</i>を取り、<i class="calibre5">N</i>×<i class="calibre5">N</i>のかけ算表をExcelファイルで作成する<i class="calibre5">multiplicationTable.py</i>というプログラムを作成してください。例えば、このように呼び出すと、</p>
<pre class="pre"><code class="calibre9">py multiplicationTable.py 6</code></pre>
<p class="tni">図14-10のようなExcelファイルを作成します。</p>
<figure class="img"><img class="img2" id="calibre_link-769" src="images/000018.jpg" alt="An Excel spreadsheet in which cells A2 through A7 contain the numbers 1 through 6, and cells B1 through G1 also contain the values 1 through 6. All other cells show the results of multiplying the value in the row and column." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-10：かけ算表が作成されたExcelファイル</span></p></figcaption>
</figure>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-970" aria-label="357"></span>1行目とA列はラベルなので太字にしてください。</p>
</section>
<section type="division" aria-labelledby="sec29">
<h4 class="h1" id="calibre_link-1860"><span id="calibre_link-401"></span><span class="sans_futura_std_heavy_oblique_bi_">空行挿入</span></h4>
<p class="tni">2つの整数とファイル名の文字列を取る、<i class="calibre5">blankRowInserter.py</i>という名前のプログラムを作成してください。最初の整数を<i class="calibre5">N</i>、2番目の整数を<i class="calibre5">M</i>とします。このプログラムは、Excelファイルの<i class="calibre5">N</i>行目から<i class="calibre5">M</i>行分空行を挿入します。例えば、このように呼び出すと、</p>
<pre class="pre"><code class="calibre9">python blankRowInserter.py 3 2 myProduce.xlsx</code></pre>
<p class="tni">実行前と実行後のExcelファイルは図14-11のようになります。</p>
<figure class="img"><img class="img1" id="calibre_link-770" src="images/000019.jpg" alt="Two Excel spreadsheets whose cells contain produce items. In the second spreadsheet, rows three and four are blank, and those rows’ previous contents have been shifted to rows five and six." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 14-11：3行目に2行分の空行挿入の実行前（左）と実行後（右）</span></p></figcaption>
</figure>
<p class="tx">指定されたExcelファイルを読み取り、新しいExcelファイルに書き込みます。<span class="thesansmonocd_w5regular_">for</span>ループで最初の<i class="calibre5">N</i>行をコピーして、残りの行は<i class="calibre5">M</i>行分だけ繰り下げて書き込みます。</p>
</section>
</section>
</section>
</div>


</div>



</body></html>