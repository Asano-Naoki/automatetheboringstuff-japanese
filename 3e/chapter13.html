<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-314">
<section type="chapter" role="doc-chapter" aria-labelledby="ch13">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1188" aria-label="289"></span>
<hgroup>
<h2 class="title" id="calibre_link-1765">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">13</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">ウェブスクレイピング</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">Wi-Fiがつながらないというめったにない恐ろしい瞬間に、私は自分がコンピュータで行っていることの大半が実はインターネットで行っていることに気づきました。習慣的に、メールをチェックし、ソーシャルメディアを読み、「カートウッド・スミスは1987年の初代<i class="calibre18">ロボコップ</i>に出演する前に主要な役を演じたことがあるか」<sup class="calibre21"><a role="doc-noteref" id="calibre_link-755" href="chapter13.html#calibre_link-742" class="calibre1">1</a></sup>といった質問に答えています。</p>
<p class="tx">コンピュータで行う作業の多くはインターネットと関係していますから、プログラムでもインターネットに接続できるといいです。<i class="calibre5">ウェブスクレイピング</i>はプログラムを使ってウェブ上のコンテンツをダウンロードしたり処理したりすることを指します。例えば、Googleはウェブスクレイピングプログラムをたくさん実行し、検索エンジン用にウェブページのインデックスを作成しています。本章では、以下のモジュールを使って、Pythonでウェブスクレイピングを行います。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">webbrowser </span>Pythonに付属していて、指定したページをブラウザで開きます。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">requests </span>インターネット上のファイルとウェブページをダウンロードします。</p>
<p class="listplain"><b class="calibre10">Beautiful Soup (<span class="sans_thesansmonocd_w7bold_b_">bs4</span>)</b> ウェブページを作成する言語であるHTMLを解析し、必要な情報を抽出します。</p>
<p class="listplain"><b class="calibre10">Selenium</b> ウェブブラウザを起動して制御します。フォームの入力やマウスクリックなどができます。</p>
<p class="listplain"><b class="calibre10">Playwright</b> ウェブブラウザを起動して制御します。Seleniumよりも新しく、機能が追加されています。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1766"><span id="calibre_link-315"></span><span class="sans_futura_std_bold_b_">HTTPとHTTPS</span></h3>
<p class="tni">ウェブサイトを訪問するときに、<i class="calibre5"><a href="https://autbor.com/example3.html" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/example3<wbr></wbr>.html</a></i> のような<i class="calibre5">URL（Uniform Resource Locator）</i>と呼ばれるアドレスを利用します。URL中の<i class="calibre5">HTTPS</i>（<i class="calibre5">HyperText Transfer Protocol Secure</i>）は、ブラウザがウェブサイトにアクセスするのに使用するプロトコルです。本章で紹介するパッケージは、このプロトコルでスクリプトからウェブサーバーにアクセスします。</p>
<p class="tx">より正確に言うと、HTTPSはHTTPを暗号化したもので、インターネットを使用する間のプライバシーを保護します。HTTPを使っているとしたら、なりすまし犯や国の諜報機関やインターネットサービスプロバイダーが、送信したパスワードやクレジットカード情報なども含めて、訪問したウェブページの内容を見ることができます。VPNを使うと、インターネットサービスプロバイダーがインターネット通信の中身を見ることはできなくなりますが、VPNプロバイダはインターネット通信の中身を見ることができます。悪質なVPNプロバイダは、訪問したウェブサイトについての情報をデータブローカーに売るかもしれません。（Tom ScottはVPNがすることとしないことを、“This Video Is Sponsored by VPN.”という動画で論じています。）</p>
<p class="tx">これとは対照的に、HTTPSで閲覧したページの内容は、暗号化されて秘匿されます。かつてはパスワードやクレジットカード番号を送信するページでのみHTTPSが使われていましたが、現在では大部分のウェブサイトですべての通信が暗号化されています。それでも、どのウェブサイトを訪問したかはわかってしまうことに気をつけてください。CatPhotos.comから何をダウンロードしたかを見ることはできませんが、CatPhotos.comのウェブサイトに接続したことはわかり、きっとネコの写真を見たのだろうと推測することができてしまいます。Tor匿名ネットワークを使うTorブラウザなら、真に匿名的なウェブブラウズが可能です。<i class="calibre5"><a href="https://www.torproject.org/download/" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.torproject<wbr></wbr>.org<wbr></wbr>/download<wbr></wbr>/</a></i>でダウンロードできます。</p>
<p class="ph"><span id="calibre_link-316"></span><span role="doc-pagebreak" type="pagebreak" id="calibre_link-983" aria-label="291"></span><span class="sans_futura_std_heavy_b_">プロジェクト6：webbrowserモジュールを使用してプログラムを実行する</span></p>
<p class="tni">Pythonの<span class="thesansmonocd_w5regular_">webbrowser</span>モジュールをプログラミングで使うことについて説明します。<span class="thesansmonocd_w5regular_">webbrowser</span>モジュールの<span class="thesansmonocd_w5regular_">open()</span>関数は、ブラウザを立ち上げて指定したURLを開きます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import webbrowser</b>
&gt;&gt;&gt; <b class="calibre10">webbrowser.open('https://inventwithpython.com/')</b>
</code></pre>
<p class="tx">URLが<i class="calibre5"><a href="https://inventwithpython.com" class="calibre1">https://<wbr></wbr>inventwithpython<wbr></wbr>.com</a></i>であるウェブブラウザのタブを開きます。<span class="thesansmonocd_w5regular_">webbrowser</span>モジュールができることはこれだけです。それでも、<span class="thesansmonocd_w5regular_">open()</span>関数で興味深いことを行えます。</p>
<p class="tx">例えば、OpenStreetMapで地図を表示したいと思ったときに、毎回住所をクリップボードにコピーするのは面倒です。クリップボードの内容をもとにして自動的にブラウザで地図を立ち上げるちょっとしたスクリプトを書けば、この作業から数ステップを減らすことができます。こうすれば、住所をクリップボードにコピーして、地図を表示するスクリプトを実行するだけですみます。OpenStreetMapのURLに直接住所を埋め込めますから、<span class="thesansmonocd_w5regular_">webbrowser.open()</span>関数だけで実現できます。</p>
<p class="tx">このプログラムには以下の内容が必要です。</p>
<ul class="ul">
<li class="bl">コマンドライン引数またはクリップボードから住所を取得する</li>
<li class="bl">ウェブブラウザでその住所のOpenStreetMapのページを開く</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">sys.argv</span>からコマンドライン引数を読み取る</li>
<li class="bl">クリップボードの内容を読み取る</li>
<li class="bl"><span class="thesansmonocd_w5regular_">webbrowser.open()</span>関数を呼び出してウェブブラウザを開く</li>
</ul>
<p class="tx">新しいファイルエディタタブを開いて、<i class="calibre5">showmap.py</i>という名前で保存します。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1767"><span id="calibre_link-317"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：URLを理解する</span></h4>
<p class="tni"><span>第12章</span>の手順に沿って、<i class="calibre5">showmap.py</i>ファイルを、次のようにコマンドラインから実行できるようにします。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt; <b class="calibre10">showmap 777 Valencia St, San Francisco, CA 94110</b></code></pre>
<p class="tni">このスクリプトはクリップボードではなくコマンドライン引数を優先的に使います。コマンドライン引数がなければクリップボードの内容を使います。</p>
<p class="tx">このプログラムでは、住所を指定するURLの仕組みを理解する必要があります。ブラウザで<i class="calibre5"><a href="https://www.openstreetmap.org" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.openstreetmap<wbr></wbr>.org</a></i>を読み込んで住所を検索すると、ブラウザのアドレスバーのURLは <i class="calibre5"><a href="https://www.openstreetmap.org/search?query=777%20Valencia%20St%2C%20San%20Francisco%2C%20CA%2094110#map=19/37.75897/-122.42142" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.openstreetmap<wbr></wbr>.org<wbr></wbr>/search<wbr></wbr>?query<wbr></wbr>=777%20Valencia%20St%2C%20San%20Francisco%2C%20CA%2094110#map<wbr></wbr>=19<wbr></wbr>/37<wbr></wbr>.75897<wbr></wbr>/<wbr></wbr>-122<wbr></wbr>.42142</a></i>のようになります。</p>
<p class="tx">アドレスバーから取り出したURLの<i class="calibre5">#map</i>の部分は不要です（実験してみればわかります）。よって、プログラムで<i class="calibre5"><a href="https://www.openstreetmap.org/search%3Fquery=%3Cyour_address_string%3E" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.openstreetmap<wbr></wbr>.org<wbr></wbr>/search<wbr></wbr>?query<wbr></wbr>=&lt;your<wbr></wbr>_address<wbr></wbr>_string&gt;</a></i>をウェブブラウザで開けばよいということがわかります（<i class="calibre5">&lt;your_address_string&gt;</i>の部分は地図を表示したい住所です）。URL中のスペースを<i class="calibre5">%20</i>に置き換えるなど、必要なURLエンコードをブラウザが自動的にしてくれます。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h4 class="h1" id="calibre_link-1768"><span id="calibre_link-318"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：コマンドライン引数を処理する</span></h4>
<p class="tni">コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># showmap.py - コマンドラインまたはクリップボードから
# 住所を指定してブラウザで地図を起動する

import webbrowser, sys
if len(sys.argv) &gt; 1:
    # コマンドラインから住所を取得
    address = ' '.join(sys.argv[1:])

# TODO: クリップボードから住所を取得

# TODO: ウェブブラウザを開く
</code></pre>
<p class="tx">まず、ブラウザを起動するために<span class="thesansmonocd_w5regular_">webbrowser</span>モジュールを、コマンドライン引数を読み取るために<span class="thesansmonocd_w5regular_">sys</span>モジュールを、インポートする必要があります。変数<span class="thesansmonocd_w5regular_">sys.argv</span>にはプログラムのファイル名とコマンドライン引数がリストとして格納されています。このリストにファイル名以外のものが含まれていたら、<span class="thesansmonocd_w5regular_">len(sys.argv)</span>が<span class="thesansmonocd_w5regular_">1</span>より大きい数に評価されるので、コマンドライン引数があったということになります。</p>
<p class="tx">コマンドライン引数は通常スペースで区切られますが、今回はすべての引数を一つの文字列として解釈したいです。<span class="thesansmonocd_w5regular_">sys.argv</span>は文字列のリストですから、<span class="thesansmonocd_w5regular_">join()</span>メソッドに渡して一つの文字列値にします。この文字列でプログラム名は不要ですから、配列の最初の要素を削ぎ落とすために、<span class="thesansmonocd_w5regular_">sys.argv</span>ではなく<span class="thesansmonocd_w5regular_">sys.argv[1:]</span>を渡します。この式が最終的に評価する値を変数<span class="thesansmonocd_w5regular_">address</span>に格納します。</p>
<p class="tx">このプログラムをコマンドラインからこのように実行すると</p>
<pre class="pre"><code class="calibre9">showmap 777 Valencia St, San Francisco, CA 94110</code></pre>
<p class="tni">変数<span class="thesansmonocd_w5regular_">sys.argv</span>は次のようなリスト値になります。</p>
<pre class="pre"><code class="calibre9">['showmap.py', '777', 'Valencia', 'St, ', 'San', 'Francisco, ', 'CA', '94110']</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">sys.argv[1:]</span>をスペース文字で連結すると、変数<span class="thesansmonocd_w5regular_">address</span>には<span class="thesansmonocd_w5regular_">'777 Valencia St, San Francisco, CA 94110'</span>が格納されます。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1769"><span id="calibre_link-319"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：クリップボードの内容を取得する</span></h4>
<p class="tni">クリップボードからURLを取得するコードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># showmap.py - コマンドラインまたはクリップボードから
# 住所を指定してブラウザで地図を起動する

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1255" aria-label="293"></span>import webbrowser, sys<b class="calibre10">, pyperclip</b>
if len(sys.argv) &gt; 1:
    # コマンドラインから住所を取得
    address = ' '.join(sys.argv[1:])
<b class="calibre10">else:</b>
    # クリップボードから住所を取得
<b class="calibre10">    address = pyperclip.paste()</b>

# ウェブブラウザを開く
<b class="calibre10">webbrowser.open('https://www.openstreetmap.org/search?query=' + address)</b>
</code></pre>
<p class="tx">コマンドライン引数がなければ、クリップボードにある住所を使います。<span class="thesansmonocd_w5regular_">pyperclip.paste()</span>でクリップボードの内容を取得し、変数<span class="thesansmonocd_w5regular_">address</span>に保存します。最後に、<span class="thesansmonocd_w5regular_">webbrowser.open()</span>を呼び出して、OpenStreetMapのURLをウェブブラウザで開きます。</p>
<p class="tx">何時間も節約してくれるような大きな作業を行うプログラムを書くこともできれば、指定した住所の地図を開くといった、日常的な作業で数秒を節約してくれるプログラムを書くこともできます。表13-1は<i class="calibre5">showmap.py</i>プログラムがある場合とない場合とで地図を表示するのに必要なステップを比較しています。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-743"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 13-1：</span></span><span class="sans_futura_std_book_oblique_i_">showmap.py</span><span class="sans_futura_std_book_">プログラムの有無による地図の表示手順比較</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">手動で地図を表示する</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_heavy_oblique_bi_">showmap.py</span><span class="sans_futura_std_bold_b_">を使う</span> </p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">1. 住所を選択する</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">1. 住所を選択する</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">2. 住所をコピーする</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">2. 住所をコピーする</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">3. ブラウザを開く</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">3. </span><span class="sans_futura_std_book_oblique_i_">showmap.py</span><span class="sans_futura_std_book_">を実行する</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">4. </span> <span class="sans_futura_std_book_oblique_i_"><a href="https://www.openstreetmap.org" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.openstreetmap<wbr></wbr>.org</a>に移動する</span></p></td>
<td class="tb"></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">5. 住所を入力するテキストフィールドをクリックする</span></p></td>
<td class="tb"></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">6. 住所を貼り付ける</span></p></td>
<td class="tb"></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">7. </span><span class="sans_futura_std_book_sc_">ENTER</span><span class="sans_futura_std_book_">を押す</span></p></td>
<td class="tbl"></td>
</tr>
</tbody>
</table>
<p class="tx">OpenStreetMapのウェブサイトは、住所の情報を直接URLに埋め込めたため、地図を表示するのに操作が不要だったのは幸運でした。<i class="calibre5">showmap.py</i>スクリプトのおかげで指定した住所の地図を表示するという作業が楽になりました。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1770"><span id="calibre_link-320"></span><span class="sans_futura_std_heavy_oblique_bi_">似たようなプログラムのアイデア</span></h4>
<p class="tni">URLさえあれば、<span class="thesansmonocd_w5regular_">webbrowser</span>モジュールでブラウザを操作してウェブサイトを開けます。この機能を利用した以下のようなプログラムが考えられます。</p>
<ul class="ul">
<li class="bl">あるページ上のすべてのリンクをブラウザの別タブで開く</li>
<li class="bl">地域の天気予報サイトのURLをブラウザで開く</li>
<li class="bl">日常的にチェックしているソーシャルネットワークのサイトやブックマークしたサイトを開く</li>
<li class="bl">ハードドライブ上のローカル<i class="calibre5">.html</i>ファイルを開く</li>
</ul>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1122" aria-label="294"></span>最後のものはヘルプファイルを表示するのに使えます。<span class="thesansmonocd_w5regular_">print()</span>でヘルプページを表示することもできますが、<span class="thesansmonocd_w5regular_">webbrowser.open()</span>を呼び出して<i class="calibre5">.html</i>ファイルを開くと、フォント、色、表、画像などを使ってヘルプ情報を伝えられます。<i class="calibre5">https://</i>ではなく<i class="calibre5">file://</i>を使ってください。例えば、<i class="calibre5">Desktop</i>フォルダに<i class="calibre5">help.html</i>ファイルがあるとしたら、Windowsでは<i class="calibre5">file:///C:/Users/al/Desktop/help.html</i>、macOSでは<i class="calibre5">file:///Users/al/Desktop/help.html</i>を開きます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec6">
<h3 class="h" id="calibre_link-1771"><span id="calibre_link-321"></span><span class="sans_futura_std_bold_b_">requestsモジュールでウェブからファイルをダウンロードする</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">requests</span>モジュールを使うと簡単にウェブからファイルをダウンロードできます。ネットワークエラー、接続のルーティング、データ圧縮といったややこしいことは考えずにすみます。このモジュールはPythonに付属していませんので、<span>付録A</span>の指示に従ってインストールします。</p>
<section type="division" aria-labelledby="sec7">
<h4 class="h1" id="calibre_link-1772"><span id="calibre_link-322"></span><span class="sans_futura_std_heavy_oblique_bi_">ウェブページをダウンロードする</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">requests.get()</span>関数はダウンロードするURLを表す文字列を取ります。この関数の返り値について<span class="thesansmonocd_w5regular_">type()</span>を呼び出すと、<span class="thesansmonocd_w5regular_">Response</span>ブジェクトが返されることがわかります。<span class="thesansmonocd_w5regular_">Response</span>オブジェクトには、ウェブサーバーからのリクエストに対する応答（レスポンス）が含まれています。<span class="thesansmonocd_w5regular_">Response</span>オブジェクトについてはあとで詳しく説明しますが、今のところはインターネットに接続しているコンピュータで以下の内容を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import requests</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">response = requests.get('https://automatetheboringstuff.com/files/rj.txt')</b>
&gt;&gt;&gt; <b class="calibre10">type(response)</b>
&lt;class 'requests.models.Response'&gt;
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">response.status_code == requests.codes.ok</b>
True
&gt;&gt;&gt; <b class="calibre10">len(response.text)</b>
178978
&gt;&gt;&gt; <b class="calibre10">print(response.text[:210])</b>
The Project Gutenberg EBook of Romeo and Juliet, by William Shakespeare

This eBook is for the use of anyone anywhere at no cost and with
almost no restrictions whatsoever.  You may copy it, give it away or
</code></pre>
<p class="tx">このURLは<i class="calibre5">『ロミオとジュリエット』</i>の全文のウェブページです(<span class="codeannotation" aria-label="annotation1">❶</span>)。<span class="thesansmonocd_w5regular_">Response</span>オブジェクトの<span class="thesansmonocd_w5regular_">status_code</span>属性をチェックすれば、そのウェブページへのリクエストが成功したかどうかがわかります。<span class="thesansmonocd_w5regular_">requests.codes.ok</span>の値と等しければ、うまくいっています(<span class="codeannotation" aria-label="annotation2">❷</span>)。（ちなみに、HTTPの成功のステータスコードは200です。Not Foundのステータスコードである404はおなじみかもしれません。）</p>
<p class="tx">リクエストが成功したら、ダウンロードしたウェブページは<span class="thesansmonocd_w5regular_">Response</span>オブジェクトの<span class="thesansmonocd_w5regular_">text</span>属性に文字列として保存されています。この大きな文字列には『ロミオとジュリエット』の全体が入っています。<span class="thesansmonocd_w5regular_">len(response.text)</span>を呼び出すと178,000文字以上であることがわかります。最後に<span class="thesansmonocd_w5regular_">print(response.text[:210])</span>を呼び出して最初の210文字だけを表示しています。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1278" aria-label="295"></span>リクエストが失敗して“Failed to establish a new connection”や“Max retries exceeded”のようなエラーメッセージが表示されたら、インターネット接続を確認してください。サーバーへの接続は非常に複雑であるため、あらゆる問題の可能性をここで挙げることはできません。クォートで囲まれたエラーメッセージをウェブで検索すれば、一般的なエラーの原因がわかるはずです。<span class="thesansmonocd_w5regular_">requests</span>でウェブページをダウンロードすると、HTMLの内容だけが取得されることを覚えておいてください。画像その他のメディアは別途ダウンロードする必要があります。</p>
</section>
<section type="division" aria-labelledby="sec8">
<h4 class="h1" id="calibre_link-1773"><span id="calibre_link-323"></span><span class="sans_futura_std_heavy_oblique_bi_">エラーをチェックする</span></h4>
<p class="tni">すでに見たように、<span class="thesansmonocd_w5regular_">Response</span>オブジェクトには<span class="thesansmonocd_w5regular_">status_code</span>属性があり、<span class="thesansmonocd_w5regular_">requests.codes.ok</span>と照合することで、ダウンロードが成功したかどうかを確認することができます。<span class="thesansmonocd_w5regular_">Response</span>オブジェクトの<span class="thesansmonocd_w5regular_">raise_for_status()</span>メソッドを呼び出すと、成功したかどうかをもっと簡単にチェックできます。このメソッドは、ファイルのダウンロード中にエラーが発生した場合に例外を送出し、ダウンロードが成功したら何もしません。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">response = requests.get('https://inventwithpython.com/page_that_does_not_exist')</b>
&gt;&gt;&gt; <b class="calibre10">response.raise_for_status()</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;

  File "C:\Users\Al\AppData\Local\Programs\Python\Python<var class="calibre20">XX</var>\lib\site-packages\
requests\models.py", line 940, in raise_for_status
    raise HTTPError(http_error_msg, response=self)
requests.exceptions.HTTPError: 404 Client Error: Not Found for url:
https://inventwithpython.com/page_that_does_not_exist.html
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">raise_for_status()</span>メソッドは、ダウンロードがうまくいかなかった場合にプログラムを停止させる簡単な方法です。一般的に、予期せぬエラーが発生したらすぐにプログラムを止めたいでしょう。ダウンロードが失敗しても構わないのであれば、<span class="thesansmonocd_w5regular_">raise_for_status()</span>の行を<span class="thesansmonocd_w5regular_">try</span>文と<span class="thesansmonocd_w5regular_">except</span>文ではさんでプログラムを止めずにエラーを処理できます。</p>
<pre class="pre"><code class="calibre9">import requests
response = requests.get('https://inventwithpython.com/page_that_does_not_exist')
try:
    response.raise_for_status()
except Exception as exc:
    print(f'There was a problem: {exc}')
</code></pre>
<p class="tx">この<span class="thesansmonocd_w5regular_">raise_for_status()</span>メソッド呼び出しは、以下のように出力します。</p>
<pre class="pre"><code class="calibre9">There was a problem: 404 Client Error: Not Found for url:
https://inventwithpython.com/page_that_does_not_exist.html
</code></pre>
<p class="tx">必ず<span class="thesansmonocd_w5regular_">requests.get()</span>を呼び出してから<span class="thesansmonocd_w5regular_">raise_for_status()</span>を呼び出してください。プログラムを継続する前にダウンロードがうまくいったかどうか確かめるようにしてください。</p>
</section>
<section type="division" aria-labelledby="sec9">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-990" aria-label="296"></span>
<h4 class="h1" id="calibre_link-1774"><span id="calibre_link-324"></span><span class="sans_futura_std_heavy_oblique_bi_">ダウンロードしたファイルをハードドライブに保存する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">open()</span>関数と<span class="thesansmonocd_w5regular_">write()</span>メソッドでウェブページをハードドライブに保存してみましょう。<span class="thesansmonocd_w5regular_">open()</span>の第二引数に文字列<span class="thesansmonocd_w5regular_">'wb'</span>を渡して<i class="calibre5">バイナリ書き込み</i>モードでファイルを開きます。 （先ほどダウンロードした<i class="calibre5">『ロミオとジュリエット』</i>のように）ページはプレーンテキストであっても、テキストのUnicodeエンコーディングを維持するためにテキストデータをバイナリデータで書き込む必要があります。</p>
<p class="tx">ウェブページをファイルに書き込むには、<span class="thesansmonocd_w5regular_">Response</span>オブジェクトの<span class="thesansmonocd_w5regular_">iter_content()</span>メソッドを<span class="thesansmonocd_w5regular_">for</span>ループで使います。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import requests</b>
&gt;&gt;&gt; <b class="calibre10">response = requests.get('https://automatetheboringstuff.com/files/rj.txt')</b>
&gt;&gt;&gt; <b class="calibre10">response.raise_for_status()</b>
&gt;&gt;&gt; <b class="calibre10">with open('RomeoAndJuliet.txt', 'wb') as play_file:</b>
...     <b class="calibre10">for chunk in response.iter_content(100000):</b>
...    <b class="calibre10">     play_file.write(chunk)</b>
...
100000
78978
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">iter_content()</span>メソッドはループの反復ごとに内容の「チャンク」（ひとかたまり）を返します。チャンクは<i class="calibre5">バイト</i>データ型で、一つのチャンクを何バイトにするか指定します。10万バイトがちょうどよいので<span class="thesansmonocd_w5regular_">iter_content()</span>に<span class="thesansmonocd_w5regular_">100000</span>を渡します。</p>
<p class="tx">ファイル<i class="calibre5">RomeoAndJuliet.txt</i>が現在の作業ディレクトリに現れます。ウェブサイト上のファイル名は<i class="calibre5">rj.txt</i>でしたが、ハードドライブ上では別の名前にしています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">write()</span>メソッドはファイルに書き込んだバイト数を返します。先の例では、最初のチャンクで100,000バイト書き込み、残りの部分は78,978バイトでした。</p>
<aside class="box" aria-label="box-15">
<p class="bt" id="calibre_link-1775"><span class="sans_futura_std_bold_b_">ファイルのダウンロードと保存のおさらい</span></p>
<p class="btni"><span class="sans_futura_std_book_">ファイルをダウンロードして保存する手順をおさらいします。</span></p>
<ul class="ul">
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">requests.get()</span><span class="sans_futura_std_book_">を呼び出してファイルをダウンロードする</span></li>
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">open()</span><span class="sans_futura_std_book_">を</span><span class="thesansmonocd_w5regular_">'wb'</span><span class="sans_futura_std_book_">で呼び出してバイナリ書き込みモードで新しいファイルを作成する</span></li>
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">Response</span><span class="sans_futura_std_book_">オブジェクトの</span> <span class="thesansmonocd_w5regular_">iter_content()</span><span class="sans_futura_std_book_">メソッドをループで反復処理する</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">反復ごとに</span><span class="thesansmonocd_w5regular_">write()</span><span class="sans_futura_std_book_">を呼び出して内容をファイルに書き込む</span></li>
</ul>
</aside>
<p class="tx">これで<span class="thesansmonocd_w5regular_">requests</span>モジュールの説明は終わりです。このモジュールの他の機能については<i class="calibre5"><a href="https://requests.readthedocs.io/en/latest/" class="calibre1">https://<wbr></wbr>requests<wbr></wbr>.readthedocs<wbr></wbr>.io<wbr></wbr>/en<wbr></wbr>/latest<wbr></wbr>/</a></i>をご参照ください。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-911" aria-label="297"></span>YouTube、Facebook、X（旧Twitter）その他のサイトから動画ファイルをダウンロードしたい場合は、<span>第24章</span>で取り上げる<span class="thesansmonocd_w5regular_">yt-dlp</span>モジュールを使ってください。</p>
</section>
</section>
<section type="division" aria-labelledby="sec10">
<h3 class="h" id="calibre_link-1776"><span id="calibre_link-325"></span><span class="sans_futura_std_bold_b_">天気APIにアクセスする</span></h3>
<p class="tni">アプリは人間のユーザー用に設計されています。ただし、<i class="calibre5">API（Application Programming Interface）</i>を通じて他のプログラムとやり取りをするプログラムを書くことができます。APIとは、あるソフトウェア（自分が書いたPythonプログラム）が別のソフトウェア（天気情報サイトのサーバー）とやり取りする方法を定義した仕様のことです。オンラインサービスにはAPIが用意されていることが多いです。例えば、（サービス側で用意されたAPIを活用して）ソーシャルメディアの自分のアカウントに投稿したり、新しい写真をダウンロードしたりするPythonスクリプトを書けます。この節では、無料のOpenWeatherサイトから天気情報にアクセスするスクリプトを書きます。</p>
<p class="tx">ほぼすべてのオンラインサービスでAPIを利用するのにメールアドレスの登録を求められます。APIの利用は無料であっても、1時間や1日あたりにリクエストできる回数に制限がある場合があります。スパムメールが気になるなら、<i class="calibre5"><a href="https://10minutemail.com" class="calibre1">https://<wbr></wbr>10minutemail<wbr></wbr>.com</a></i>などのサービスで使い捨てのメールアドレスを使うことができます。重要ではないオンラインアカウントにだけこうした使い捨てメールを使うようにしてください。悪質なメールサービスがパスワードリセットを要求してアカウントを乗っ取ることができてしまいますので。</p>
<p class="tx">最初に<i class="calibre5"><a href="https://openweathermap.org" class="calibre1">https://<wbr></wbr>openweathermap<wbr></wbr>.org</a></i>で無料アカウントを作成してください。無料アカウントには1分につき60APIリクエストという制限があります。小中規模のプログラミングプロジェクトにはこれで十分です。（自サイトを訪問する数百人が同時にリクエストするなど）この制限を超えてAPIリクエストが必要になれば、有料アカウントにすることができます。オンラインサービスは<i class="calibre5">APIキー</i>を発行します。これはAPIリクエストでアカウントを識別するパスワードのようなものです。このAPIキーは秘密にしておきます。このAPIキーを知っている人は誰でもそのアカウントでAPIリクエストができます。APIキーを使用するプログラムを書く場合は、ソースコードにキーを埋め込むのではなく、プログラムからキーが書かれたテキストファイルを読み込むようにしてください。こうすれば、自分のアカウントでのAPI制限の超過を気にすることなくプログラムを他の人と共有できます（他の人はその人自身のAPIキーを使います）。</p>
<p class="tx">HTTPのAPIはレスポンスを大きな文字列で返すことが多いです。この文字列はJSON形式かXML形式でフォーマットされているのがほとんどです。<span>第18章で</span>JSONとXMLについて詳しく説明しますが、今のところは、<span class="thesansmonocd_w5regular_">json.loads(response.text)</span>が、<span class="thesansmonocd_w5regular_">response.text</span>のJSONデータを、リストと辞書というPythonのデータ構造に変換して返すということさえ知っておけば十分です。本章の例では<span class="thesansmonocd_w5regular_">response_data</span>という名前の変数にこのデータを格納しますが、どのような名前でも構いません。</p>
<p class="tx">オンラインサービスごとにAPIの使い方を説明したドキュメントが提供されています。OpenWeatherは<i class="calibre5"><a href="https://openweathermap.org/api" class="calibre1">https://<wbr></wbr>openweathermap<wbr></wbr>.org<wbr></wbr>/api</a></i>でドキュメントを提供しています。自分のアカウントでログインして<i class="calibre5"><a href="https://home.openweathermap.org/api_keys" class="calibre1">https://<wbr></wbr>home<wbr></wbr>.openweathermap<wbr></wbr>.org<wbr></wbr>/api<wbr></wbr>_keys</a></i>の<i class="calibre5">My API keys</i>ページからAPIキーを取得してから、そのキーを以下の対話型シェルのコードで使ってください。私はこの例で<span class="thesansmonocd_w5regular_">'30ee784a80d81480dab1749d33980112'</span>をうそのAPIキーとして使います。このうそのAPIキーを使わないでください。このキーでは動作しません。</p>
<p class="tx">まず、OpenWeatherでサンフランシスコの緯度と経度を調べてみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import requests</b>
&gt;&gt;&gt; <b class="calibre10">city_name = 'San Francisco'</b>
&gt;&gt;&gt; <b class="calibre10">state_code = 'CA'</b>
&gt;&gt;&gt; <b class="calibre10">country_code = 'US'</b>
&gt;&gt;&gt; <b class="calibre10">API_key = '30ee784a80d81480dab1749d33980112'  </b># うそのAPIキー
&gt;&gt;&gt; <b class="calibre10">response = requests.get(f'https://api.openweathermap.org/geo/1.0/</b>
<b class="calibre10">direct?q={city_name},{state_code},{country_code}&amp;appid={API_key}')</b>
&gt;&gt;&gt; <b class="calibre10">response.text  </b># Pythonの文字列
'[{"name":"San Francisco","local_names":{"id":"San Francisco",
<var class="calibre20">--snip--</var>
,"lat":37.7790262,"lon":-122.419906,"country":"US","state":"California"}]'
&gt;&gt;&gt; <b class="calibre10">import json</b>
&gt;&gt;&gt; <b class="calibre10">response_data = json.loads(response.text)</b>
&gt;&gt;&gt; <b class="calibre10">response_data</b>  # Pythonのデータ構造
[{"name":"San Francisco","local_names":{"id":"San Francisco",
<var class="calibre20">--snip--</var>
,"lat":37.7790262,"lon":-122.419906,"country":"US","state":"California"}]
</code></pre>
<p class="tx">レスポンスのデータを理解するには、OpenWeatherのAPIのオンラインドキュメントを参照するか、対話型シェルで<span class="thesansmonocd_w5regular_">response_data</span>の辞書データを調べます。レスポンスはリストであり、その最初の要素（インデックス0）は<span class="thesansmonocd_w5regular_">'lat'</span>と<span class="thesansmonocd_w5regular_">'lon'</span>のキーがある辞書です。これらのキーの値は緯度と経度の浮動小数点数値です。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">response_data[0]['lat']</b>
37.7790262
&gt;&gt;&gt; <b class="calibre10">response_data[0]['lon']</b>
-122.419906
</code></pre>
<p class="tx">APIリクエストを行うためのURLは<i class="calibre5">エンドポイント</i>と呼ばれます。この例のf文字列は波かっこの部分を変数の値で置き換えます。先の例の<span class="thesansmonocd_w5regular_">direct?q={city_name},{state_code},{country_code}&amp;appid={API_key}'</span>は<span class="thesansmonocd_w5regular_">direct?q=San Francisco,CA,US&amp;appid=30ee784a80d81480dab1749d33980112'</span>になります。</p>
<p class="tx">次に、この緯度と経度を使ってサンフランシスコの現在の気温を調べましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">lat = json.loads(response.text)[0]['lat']</b>
&gt;&gt;&gt; <b class="calibre10">lon = json.loads(response.text)[0]['lon']</b>
&gt;&gt;&gt; <b class="calibre10">response = requests.get(f'https://api.openweathermap.org/data/2.5/</b>
<b class="calibre10">weather?lat={lat}&amp;lon={lon}&amp;appid={API_key}')</b>
&gt;&gt;&gt; <b class="calibre10">response_data = json.loads(response.text)</b>
&gt;&gt;&gt; <b class="calibre10">response_data</b>
{'coord': {'lon': -122.4199, 'lat': 37.779}, 'weather': [{'id': 803,
<var class="calibre20">--snip--</var>
'timezone': -25200, 'id': 5391959, 'name': 'San Francisco', 'cod': 200}
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1067" aria-label="299"></span>&gt;&gt;&gt; <b class="calibre10">response_data['main']['temp']</b>
285.44
&gt;&gt;&gt; <b class="calibre10">round(285.44 - 273.15, 1)</b>  # ケルビンから摂氏への変換
12.3
&gt;&gt;&gt; <b class="calibre10">round(285.44 * (9 / 5) - 459.67, 1)</b>  # ケルビンから華氏への変換
54.1
</code></pre>
<p class="tx">OpenWeatherはケルビン単位の気温を返すので、摂氏や華氏の気温を取得するには少し計算する必要があります。</p>
<p class="tx">先の例の位置情報エンドポイントのURLを分解します。</p>
<p class="listplain"><b class="calibre10"><i class="calibre5">https://</i></b> サーバーにアクセスする<i class="calibre5">スキーマ</i>です。プロトコル名（オンラインのAPIならほぼすべてHTTPSです）にコロンとスラッシュを2つつけます。</p>
<p class="listplain"><b class="calibre10"><i class="calibre5">api.openweathermap.org</i></b> APIリクエストを処理するウェブサーバーのドメイン名です。</p>
<p class="listplain"><b class="calibre10"><i class="calibre5">/geo/1.0/direct</i></b> APIのパスです。</p>
<p class="listplain"><b class="calibre10"><i class="calibre5">?q={city_name},{state_code},{country_code}&amp;appid={API_key}</i></b> URLクエリ文字列です。波かっこ内の部分は実際の値に置き換える必要があります。これらは関数呼び出しのパラメータのようなものです。URLエンコードでは、パラメータ名と引数値はイコール記号で区切られ、複数の引数はアンド記号で区切られます。</p>
<p class="tx">エンドポイントURL（とクエリ文字列）をコピーしてウェブブラウザに貼り付けると、レスポンスのテキストを直接見ることができます。APIの使い方を初めて調べるときに、そのようにしてレスポンスのテキストを直接見ると理解が進みます。ウェブベースのレスポンスのテキストはほとんどの場合でJSON形式またはXML形式にフォーマットされています。</p>
<p class="tx">APIを更新する際の混乱を避けるために、ほとんどのオンラインサービスのAPIではバージョン番号がURLに含まれています。時間が経つにつれてサービスは新しいバージョンのAPIをリリースし、古いバージョンが非推奨になることがあります。そうなると、APIを利用し続けるにはスクリプト中のコードを更新しなければなりません。</p>
<p class="tx">OpenWeatherの無料アカウントでは5日分の天気予報と、降水、風、大気汚染の情報が利用できます。そのデータを取得するのにアクセスするURLと、そのAPIを呼び出したJSONレスポンスの構造は、オンラインドキュメントに書かれています。以下の数節のコードでは、<span class="thesansmonocd_w5regular_">response_data</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">json.loads(response.text)</span>で、ウェブサイトから返されたテキストをPythonのデータ構造に変換したと仮定します。</p>
<section type="division" aria-labelledby="sec11">
<h4 class="h1" id="calibre_link-1777"><span id="calibre_link-326"></span><span class="sans_futura_std_heavy_oblique_bi_">緯度と経度を調べる</span></h4>
<p class="tni">指定した都市の緯度と経度を取得するエンドポイントは<i class="calibre5"><a href="https://api.openweathermap.org/geo/1.0/direct?q=%7Bcity_name%7D,%7Bstate_code%7D,%7Bcountry_code%7D&amp;appid=%7BAPI_key%7D" class="calibre1">https://<wbr></wbr>api<wbr></wbr>.openweathermap<wbr></wbr>.org<wbr></wbr>/geo<wbr></wbr>/1<wbr></wbr>.0<wbr></wbr>/direct<wbr></wbr>?q<wbr></wbr>={city<wbr></wbr>_name},{state<wbr></wbr>_code},{country<wbr></wbr>_code}&amp;appid<wbr></wbr>={API<wbr></wbr>_key}</a></i>です。州コードはその州の略称で、合衆国の都市の場合にのみ必要です。国コードはISO 3166コードの2, 3文字で、<i class="calibre5"><a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes" class="calibre1">https://<wbr></wbr>en<wbr></wbr>.wikipedia<wbr></wbr>.org<wbr></wbr>/wiki<wbr></wbr>/List<wbr></wbr>_of<wbr></wbr>_ISO<wbr></wbr>_3166<wbr></wbr>_country<wbr></wbr>_codes</a></i>に載っています。例えば、合衆国なら<span class="thesansmonocd_w5regular_">'US'</span>、ニュージーランドなら<span class="thesansmonocd_w5regular_">'NZ'</span>です。レスポンスのJSONテキストをPythonのデータ構造に変換して<span class="thesansmonocd_w5regular_">response_data</span>という名前の変数に格納したら、以下の情報を取得できます。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data[0]['lat'] </span>その都市の緯度を表す浮動小数点数値</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data[0]['lon'] </span>その都市の経度を表す浮動小数点数値</p>
<p class="tx">都市名が複数のレスポンスにマッチする場合は、リスト<span class="thesansmonocd_w5regular_">response_data</span>に<span class="thesansmonocd_w5regular_">response_data[0]</span>、<span class="thesansmonocd_w5regular_">response_data[1]</span>…という辞書が含まれます。OpenWeatherでその都市が見つからなければ、<span class="thesansmonocd_w5regular_">response_data</span>は空リストになります。</p>
</section>
<section type="division" aria-labelledby="sec12">
<h4 class="h1" id="calibre_link-1779"><span id="calibre_link-327"></span><span class="sans_futura_std_heavy_oblique_bi_">現在の天気を取得する</span></h4>
<p class="tni">緯度と経度をもとに現在の天気情報を取得するエンドポイントは<i class="calibre5"><a href="https://api.openweathermap.org/data/2.5/weather?lat=%7Blat%7D&amp;lon=%7Blon%7D%26appid=%7BAPI_key%7D" class="calibre1">https://<wbr></wbr>api<wbr></wbr>.openweathermap<wbr></wbr>.org<wbr></wbr>/data<wbr></wbr>/2<wbr></wbr>.5<wbr></wbr>/weather<wbr></wbr>?lat<wbr></wbr>={lat}&amp;lon<wbr></wbr>={lon}&amp;appid<wbr></wbr>={API<wbr></wbr>_key}</a></i>です。レスポンスのJSONテキストをPythonのデータ構造に変換して<span class="thesansmonocd_w5regular_">response_data</span>という名前の変数に格納したら、以下の情報を取得できます。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['weather'][0]['main'] </span><span class="thesansmonocd_w5regular_">'Clear'</span>、<span class="thesansmonocd_w5regular_">'Rain'</span>、<span class="thesansmonocd_w5regular_">'Snow'</span>など天気を説明する文字列</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['weather'][0]['description'] </span><span class="thesansmonocd_w5regular_">'light rain'</span>、<span class="thesansmonocd_w5regular_">'moderate rain'</span>、<span class="thesansmonocd_w5regular_">'extreme rain'</span>など天気を詳しく説明する文字列</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['main']['temp'] </span>ケルビン単位の現在の気温</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['main']['feels_like'] </span>ケルビン単位の体感気温</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['main']['humidity'] </span>湿度</p>
<p class="tx">正しくない緯度と経度を指定すると、<span class="thesansmonocd_w5regular_">response _data</span>は<span class="thesansmonocd_w5regular_">{"cod":"400","message":"wrong latitude"}</span>のような辞書になります。</p>
</section>
<section type="division" aria-labelledby="sec13">
<h4 class="h1" id="calibre_link-1780"><span id="calibre_link-328"></span><span class="sans_futura_std_heavy_oblique_bi_">天気予報を取得する</span></h4>
<p class="tni">緯度と経度をもとに5日間の天気予報を取得するエンドポイントは<i class="calibre5"><a href="https://api.openweathermap.org/data/2.5/forecast?lat=%7Blat%7D&amp;lon=%7Blon%7D%26appid=%7BAPI_key%7D" class="calibre1">https://<wbr></wbr>api<wbr></wbr>.openweathermap<wbr></wbr>.org<wbr></wbr>/data<wbr></wbr>/2<wbr></wbr>.5<wbr></wbr>/forecast<wbr></wbr>?lat<wbr></wbr>={lat}&amp;lon<wbr></wbr>={lon}&amp;appid<wbr></wbr>={API<wbr></wbr>_key}</a></i>です。レスポンスのJSONテキストをPythonのデータ構造に変換して<span class="thesansmonocd_w5regular_">response_data</span>という名前の変数に格納したら、以下の情報を取得できます。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['list'] </span>時間ごとの天気予報を含む辞書のリスト</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['list'][0]['dt'] </span>Unix時間形式のタイムスタンプ。この値を<span class="thesansmonocd_w5regular_">datetime.datetime.fromtimestamp()</span>に渡すと<span class="thesansmonocd_w5regular_">datetime</span>オブジェクトが得られます。<span>第19章</span>でPythonの<span class="thesansmonocd_w5regular_">datetime</span>モジュールについてもっと詳しく説明します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">response_data['list'][0]['main'] </span><span class="thesansmonocd_w5regular_">'temp'</span>、<span class="thesansmonocd_w5regular_">'feels_like'</span>、<span class="thesansmonocd_w5regular_">'humidity'</span>その他のキーがある辞書</p>
<p class="listplain"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-908" aria-label="301"></span><span class="sans_thesansmonocd_w7bold_b_">response_data['list'][0]['weather'][0] </span><span class="thesansmonocd_w5regular_">'main'</span>、<span class="thesansmonocd_w5regular_">'description'</span>その他のキーがある辞書</p>
<p class="tx">リスト<span class="thesansmonocd_w5regular_">response_data['list']</span>には、3時間ごとに5日間の予報を含む40の辞書があります。このAPIの将来のバージョンでは変更があるかもしれません。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1781"><span id="calibre_link-329"></span><span class="sans_futura_std_heavy_oblique_bi_">APIを探求する</span></h4>
<p class="tni"><i class="calibre5"><a href="https://weather.gov" class="calibre1">https://<wbr></wbr>weather<wbr></wbr>.gov</a></i>や<i class="calibre5"><a href="https://www.weatherapi.com/" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.weatherapi<wbr></wbr>.com<wbr></wbr>/</a></i>のような他のウェブサイトでも独自の無料天気APIが提供されています。APIごとに機能に違いがありますが、HTTPSでリクエストを送ってアクセスし（requestsライブラリを利用できます）、レスポンスはJSON形式かXML形式のテキストであることは共通しています。もっとも、これらのAPIを使いやすくするために、誰かがPythonの関数でエンドポイントにアクセスしてレスポンスを解析するサードパーティのPythonパッケージを作成しているかもしれません。そうしたパッケージは<i class="calibre5"><a href="https://pypi.org" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org</a></i>探すことができ、使い方のドキュメントを読めます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec15">
<h3 class="h" id="calibre_link-1782"><span id="calibre_link-330"></span><span class="sans_futura_std_bold_b_">HTMLを理解する</span></h3>
<p class="tni">ウェブページを分析する前に、<i class="calibre5">HTML（HyperText Markup Language）</i>の基礎を学ぶ必要があります。HTMLはウェブページを記述するフォーマットで、<i class="calibre5">CSS（Cascading Style Sheets）</i>はウェブページのHTML要素の見た目を変化させる方法です。この章では基本的なHTMLを扱った経験があることを前提とします。初心者向けのチュートリアルが必要なら、以下のサイトをおすすめします。</p>
<ul class="ul">
<li class="bl"><i class="calibre5"><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML" class="calibre1">https://<wbr></wbr>developer<wbr></wbr>.mozilla<wbr></wbr>.org<wbr></wbr>/en<wbr></wbr>-US<wbr></wbr>/docs<wbr></wbr>/Learn<wbr></wbr>/HTML</a></i></li>
<li class="bl"><i class="calibre5"><a href="https://www.freecodecamp.org/news/html-coding-introduction-course-for-beginners" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.freecodecamp<wbr></wbr>.org<wbr></wbr>/news<wbr></wbr>/html<wbr></wbr>-coding<wbr></wbr>-introduction<wbr></wbr>-course<wbr></wbr>-for<wbr></wbr>-beginners</a></i></li>
<li class="bl"><i class="calibre5"><a href="https://www.khanacademy.org/computing/computer-programming/html-css" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.khanacademy<wbr></wbr>.org<wbr></wbr>/computing<wbr></wbr>/computer<wbr></wbr>-programming<wbr></wbr>/html<wbr></wbr>-css</a></i></li>
</ul>
<p class="tx">この節では、ウェブブラウザの強力なデベロッパーツールの使い方も説明します。デベロッパーツールを活用すると、ウェブからの情報のスクレイピングがやりやすくなります。</p>
<section type="division" aria-labelledby="sec16">
<h4 class="h1" id="calibre_link-1783"><span id="calibre_link-331"></span><span class="sans_futura_std_heavy_oblique_bi_">フォーマットの説明</span></h4>
<p class="tni">HTMLファイルはファイル拡張子<i class="calibre5">.html</i>のプレーンテキストファイルです。テキストは、小なり記号と大なり記号（<span class="thesansmonocd_w5regular_">&lt;&gt;</span>）で囲まれたHTML<i class="calibre5">タグ</i>であふれています。タグがブラウザにウェブページのフォーマットを伝えます。開始タグと終了タグの間にテキストがあり、これらをまとめてHTML<i class="calibre5">要素</i>と呼びます。開始タグと終了タグの間のテキストがブラウザに表示されます。例えば、以下のHTMLは、ブラウザで<i class="calibre5">Hello</i>の部分が太字の<i class="calibre5">Hello, world!</i>を表示します。</p>
<pre class="pre"><code class="calibre9">&lt;b&gt;Hello&lt;/b&gt;, world!</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-940" aria-label="302"></span>ブラウザではこのHTMLが図13-1のように見えます。</p>
<figure class="img"><img class="img3" id="calibre_link-744" src="images/000011.jpg" alt="A screenshot of a browser open to “file:///C:/index.html”. The rendered content shows the text “Hello, world!” With “Hello” in bold." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 13-1:</span><span class="sans_futura_std_book_oblique_i_">ブラウザで表示された</span><span class="sans_futura_std_book_">Hello, world!</span></p></figcaption>
</figure>
<p class="tx">開始<span class="thesansmonocd_w5regular_">&lt;b&gt;</span>タグと終了<span class="thesansmonocd_w5regular_">&lt;/b&gt;</span>タグの間のテキストは太字で表示するようにブラウザに伝えられます。これが<span class="thesansmonocd_w5regular_">&lt;b&gt;Hello&lt;/b&gt;</span>という要素になります。</p>
<p class="tx">HTMLにはさまざまなタグがあります。小なり記号と大なり記号の間に<i class="calibre5">属性</i>と呼ばれるプロパティを持つタグもあります。例えば、<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>タグはリンクを表し、<span class="thesansmonocd_w5regular_">href</span>属性がリンク先のURLです。次に例を示します。</p>
<pre class="pre"><code class="calibre9">&lt;a href="https://inventwithpython.com”&gt;This text is a link&lt;/a&gt;</code></pre>
<p class="tx">そのページ内で要素を一意に識別するために<span class="thesansmonocd_w5regular_">id</span>属性を持つ要素があります。プログラムでは<span class="thesansmonocd_w5regular_">id</span>属性で要素を探し出すことが多いですから、ブラウザのデベロッパーツールでこの属性を見つけるのは、ウェブスクレイピングプログラムを書くときによく行う作業です。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h4 class="h1" id="calibre_link-1784"><span id="calibre_link-332"></span><span class="sans_futura_std_heavy_oblique_bi_">ウェブページのソースを見る</span></h4>
<p class="tni">プログラムが対象とするウェブページのHTML（<i class="calibre5">ソース</i>と呼ばれます）を見る必要があります。ウェブブラウザでソースを見たいページを開き、右クリック（macOSでは<small class="calibre4">CTRL</small>-クリック）して<b class="calibre10">「ソースを表示」</b>や<b class="calibre10">「ページのソースを表示」</b>を選びます（図13-2）。ソースはブラウザが実際に受け取っているテキストです。ブラウザはこのHTMLからウェブページを<i class="calibre5">表示（描画）</i>します。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-980" aria-label="303"></span>
<figure class="img"><img class="img1" id="calibre_link-745" src="images/000012.jpg" alt="At top, a screenshot of a web page with the right-click menu open and “View page source” highlighted. At bottom, a window containing HTML source code." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 13-2：ウェブページのソースを表示</span></p></figcaption>
</figure>
<p class="tx">お好きなサイトのHTMLのソースを表示してみてください。ソースを完全に理解できなくても大丈夫です。単純なウェブスクレイピングプログラムを書くのにHTMLをマスターする必要はありません。既存のサイトからデータを抜き出すために必要な知識があれば足ります。</p>
</section>
<section type="division" aria-labelledby="sec18">
<h4 class="h1" id="calibre_link-1785"><span id="calibre_link-333"></span><span class="sans_futura_std_heavy_oblique_bi_">ブラウザのデベロッパーツールを開く</span></h4>
<p class="tni">ブラウザのデベロッパーツールを使うと、ウェブページのソースを見るだけでなく、ページの表示と対応させてHTMLを確認できます。Firefox、Chrome、Microsoft Edgeでは、F12を押すとそのためのツールが開きます（図13-3）。もう一度F12押すとその画面が消えます。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1196" aria-label="304"></span>
<figure class="img"><img class="img1" id="calibre_link-746" src="images/000013.jpg" alt="A screenshot of the web page at weather.gov with the Developer tools open in a bottom pane showing the page’s HTML source code." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 13-3：Chromeブラウザのデベロッパーツールウィンドウ</span></p></figcaption>
</figure>
<p class="tx">ウェブページの任意の場所で右クリックをしてコンテキストメニューから<b class="calibre10">検証</b>を選ぶと、ページのその部分に対応するHTMLを確認できます。ウェブスクレイピングプログラムでHTMLを解析するのに役立ちます。</p>
<aside class="box" aria-label="box-16">
<p class="bt" id="calibre_link-1786"><span class="sans_futura_std_bold_b_">HTMLを解析するのに正規表現を使わないでください</span></p>
<p class="btni"><span class="sans_futura_std_book_">文字列中でHTML（XML、JSON、TOML、YAML）の一部を抜き出すのは、正規表現が使える場面であるように見えます。しかし正規表現を使うことはおすすめしません。正しいHTMLのフォーマットはさまざまであり、正規表現であらゆる可能性を網羅するのは面倒ですし、間違いが起こりやすいです。</span><span class="thesansmonocd_w5regular_">bs4</span><span class="sans_futura_std_book_">のような、HTML解析専用に開発されたモジュールを使うと、バグの可能性が減ります。</span></p>
<p class="boxb-last"><span class="sans_futura_std_book_">HTMLの解析に正規表現を使うべきではない理由についての詳細な議論が</span><span class="sans_futura_std_book_oblique_i_"><a href="https://stackoverflow.com/a/1732454/1893164." class="calibre1">https://<wbr></wbr>stackoverflow<wbr></wbr>.com<wbr></wbr>/a<wbr></wbr>/1732454<wbr></wbr>/1893164</a>で読めます。</span></p>
</aside>
</section>
<section type="division" aria-labelledby="sec19">
<h4 class="h1" id="calibre_link-1787"><span id="calibre_link-334"></span><span class="sans_futura_std_heavy_oblique_bi_">HTML要素を見つける</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">requests</span>モジュールでウェブページをダウンロードしたら、そのページのHTMLを一つの文字列値として取得できます。ほしい情報がそのHTMLのどの部分に対応するのか見つけ出す必要があります。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1788" aria-label="305"></span>ここでブラウザのデベロッパーツールが役立ちます。例えば、<i class="calibre5"><a href="https://weather.gov" class="calibre1">https://<wbr></wbr>weather<wbr></wbr>.gov</a></i>から天気予報を取り出すプログラムを書きたいとします。コードを書く前に調査を行います。サイトを訪問してZIPコード94105を検索すると、その地域の天気予報が表示されます。</p>
<p class="tx">そのZIPコードの天気予報をスクレイピングしたいとしたらどうすればいいでしょうか。ほしいページの情報の部分で右クリック（macOSでは<small class="calibre4">CTRL</small>-クリック）して、コンテキストメニューから<b class="calibre10">検証</b>を選びます。デベロッパーツールウィンドウが立ち上がり、その部分に対応するHTMLが表示されます。図13-4は直近の予報のHTMLを示しています。<i class="calibre5"><a href="https://weather.gov" class="calibre1">https://<wbr></wbr>weather<wbr></wbr>.gov</a></i>サイトがウェブページのデザインを変更したら、この手順をもう一度繰り返して新しい要素を見つけます。</p>
<figure class="img"><img class="img1" id="calibre_link-747" src="images/000014.jpg" alt="A screenshot of the webpage at weather.gov with the Developer tools open in a bottom pane showing the page’s HTML source code. In the developer tools, a &lt;div&gt; HTML element is highlighted, populating another pane with details about it." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 13-4：予報テキストに対応する要素を見つける</span></p></figcaption>
</figure>
<p class="tx">デベロッパーツールから、そのウェブページの天気予報の部分に対応するHTMLは、以下のものであることがわかります。</p>
<pre class="pre"><code class="calibre9">&lt;div class="col-sm-10 forecast-text"&gt;Sunny, with a high near 64.
West wind 11 to 16 mph, with gusts as high as 21 mph.&lt;/div&gt;
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-912" aria-label="306"></span>これがほしかった情報です。天気予報の情報は<span class="thesansmonocd_w5regular_">forecast-text</span>CSSクラスの<span class="thesansmonocd_w5regular_">&lt;div&gt;</span>要素の中にあります。</p>
<p class="tx">ブラウザのディベロッパーコンソールのこの要素を右クリックして、コンテキストメニューから<b class="calibre10">Copy</b><span class="listbullet_menuarrow"></span><b class="calibre10">Copy Selector</b>を選びます。これで<span class="thesansmonocd_w5regular_">'div.row-odd:nth-child(1) &gt; div:nth-child(2)'</span>のような文字列がクリップボードにコピーされます。あとで説明するように、それをBeautiful Soupの<span class="thesansmonocd_w5regular_">select()</span>メソッドや、Seleniumの<span class="thesansmonocd_w5regular_">find_element()</span>メソッドに渡せば、要素を見つけられます。</p>
<p class="tx">この文字列で用いられている<i class="calibre5">CSSセレクタ</i>構文により、ウェブページから取得するHTML要素を指定します。セレクタ構文を詳しく説明するのは本書の範囲外ですが、ここで示したようにブラウザのデベロッパーツールからセレクタを取得できます。HTML要素を指定する<i class="calibre5">XPath</i>という別の構文もありますが、これも本書の範囲外です。</p>
<p class="tx">ウェブサイトがレイアウトを変更したら、スクリプトが扱うHTMLタグにも変更の必要が生じるでしょう。こうした事態は警告なしに発生しますから、要素を見つけられないというエラーが発生していないかプログラムを注視してください。一般に、APIが提供されているならAPIを使うほうが望ましいです。ウェブサイトよりも変更される可能性はずっと低いです。</p>
</section>
</section>
<section type="division" aria-labelledby="sec20">
<h3 class="h" id="calibre_link-1789"><span id="calibre_link-335"></span><span class="sans_futura_std_bold_b_">Beautiful SoupでHTMLを解析する</span></h3>
<p class="tni">Beautiful SoupはHTMLページから情報を抽出するためのパッケージです。パッケージをインストールするときには<span class="thesansmonocd_w5regular_">beautifulsoup4</span>という名前を使いますが、インポートするモジュール名は<span class="thesansmonocd_w5regular_">bs4</span>です。この節では、Beautiful Soupで以下の内容のHTMLファイル（<i class="calibre5"><a href="https://autbor.com/example3.html" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/example3<wbr></wbr>.html</a></i>にあります）を<i class="calibre5">解析</i>（分析して内容を取得）します。</p>
<pre class="pre"><code class="calibre9">&lt;!-- This is an HTML comment. --&gt;

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Website Title&lt;/title&gt;
    &lt;style&gt;
        .slogan {
            color: gray;
            font-size: 2em;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Example Website&lt;/h1&gt;
    &lt;p&gt;This &lt;p&gt; tag puts &lt;b&gt;content&lt;/b&gt; into a &lt;i&gt;single&lt;/i&gt; paragraph.&lt;/p&gt;
    &lt;p&gt;&lt;a href="https://inventwithpython.com”&gt;This text is a link&lt;/a&gt; to books by &lt;span id=
"author"&gt;Al Sweigart&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;&lt;img src="wow_such_zophie_thumb.webp" alt="Close-up of my cat Zophie." /&gt;&lt;/p&gt;
    &lt;p class="slogan"&gt;Learn to program in Python!&lt;/p&gt;
    &lt;form&gt;
        &lt;p&gt;&lt;label&gt;Username: &lt;input id="login_user" placeholder="admin" /&gt;&lt;/label&gt;&lt;/p&gt;
        &lt;p&gt;&lt;label&gt;Password: &lt;input id="login_pass" type="password" placeholder="swordfish" /&gt;
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-957" aria-label="307"></span>    &lt;/form&gt;
&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Agree to disagree: &lt;input type="checkbox" /&gt;&lt;/label&gt;&lt;input type="submit"
value="Fake Button" /&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="tx">このページのログインフォームは見た目のためのもので動作しません。</p>
<p class="tx">シンプルなHTMLファイルでもいろいろなタグと属性があり、複雑なウェブサイトになるとすぐにとてもややこしくなります。ありがたいことに、Beautiful SoupはHTMLを扱いやすくしてくれます。</p>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1790"><span id="calibre_link-336"></span><span class="sans_futura_std_heavy_oblique_bi_">Beautiful Soupオブジェクトを作成する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">bs4.BeautifulSoup()</span>関数は解析対象のHTMLを含む文字列を取り、<span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトを返します。例えば、インターネットに接続しているコンピュータで、以下の内容を対話型シェルに入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import requests, bs4</b>
&gt;&gt;&gt; <b class="calibre10">res = requests.get('https://autbor.com/example3.html')</b>
&gt;&gt;&gt; <b class="calibre10">res.raise_for_status()</b>
&gt;&gt;&gt; <b class="calibre10">example_soup = bs4.BeautifulSoup(res.text, 'html.parser')</b>
&gt;&gt;&gt; <b class="calibre10">type(example_soup)</b>
&lt;class 'bs4.BeautifulSoup'&gt;
</code></pre>
<p class="tx">このコードでは、<span class="thesansmonocd_w5regular_">requests.get()</span>でAutomate the Boring Stuffウェブサイトのメインページをダウンロードし、レスポンスの<span class="thesansmonocd_w5regular_">text</span>属性を<span class="thesansmonocd_w5regular_">bs4.BeautifulSoup()</span>に渡しています。Beautiful Soupはさまざまなフォーマットを解析できますが、<span class="thesansmonocd_w5regular_">'html.parser'</span>を引数にするとHTMLを解析します。最後に、返された<span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトを<span class="thesansmonocd_w5regular_">example_soup</span>という名前の変数に格納しています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">bs4.BeautifulSoup()</span>に<span class="thesansmonocd_w5regular_">File</span>オブジェクトを渡せばハードドライブ上のHTMLファイルを読み込めます。（<i class="calibre5">example3.html</i>ファイルが現在の作業ディレクトリにあることを確認してから）対話型シェルに以下の内容を入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import bs4</b>
&gt;&gt;&gt; <b class="calibre10">with open('example3.html') as example_file:</b>
...     <b class="calibre10">example_soup = bs4.BeautifulSoup(example_file, 'html.parser')</b>
...
&gt;&gt;&gt; <b class="calibre10">type(example_soup)</b>
&lt;class 'bs4.BeautifulSoup'&gt;
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトを取得したら、メソッドを使ってHTML文書の特定の部分を見つけることができます。</p>
</section>
<section type="division" aria-labelledby="sec22">
<h4 class="h1" id="calibre_link-1791"><span id="calibre_link-337"></span><span class="sans_futura_std_heavy_oblique_bi_">要素を見つける</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトからウェブページの要素を取得するには、<span class="thesansmonocd_w5regular_">select()</span>メソッドを呼び出して目的の要素を表すCSSセレクタ文字列を渡します。このメソッドの返り値は、マッチしたHTML要素を表す<span class="thesansmonocd_w5regular_">Tag</span>オブジェクトです。表13-2は、<span class="thesansmonocd_w5regular_">select()</span>で使う一般的なCSSセレクタのパターン例を示しています。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-748"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 13-2：</span></span> <span class="sans_futura_std_book_">CSSセレクタの例</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">select()メソッドに渡されるセレクタ</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">マッチ対象</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">soup.select('div')</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">すべての</span><span class="thesansmonocd_w5regular_">&lt;div&gt;</span>要素</p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">soup.select('#author')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">id</span><span class="sans_futura_std_book_">属性が</span><span class="thesansmonocd_w5regular_">author</span>である要素</p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">soup.select('.notice')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">class</span><span class="sans_futura_std_book_">属性が</span> <span class="thesansmonocd_w5regular_">notice</span>である要素</p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">soup.select('div span')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;div&gt;</span>要素内の<span class="thesansmonocd_w5regular_">&lt;span&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">soup.select('div &gt; span')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;div&gt;</span><span class="sans_futura_std_book_">要素内で直下の</span> <span class="thesansmonocd_w5regular_">&lt;span&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">soup.select('input[name]')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">name</span>属性を持つ<span class="thesansmonocd_w5regular_">&lt;input&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">soup.select('input[type="button"]')</span></p></td>
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">type</span><span class="sans_futura_std_book_">属性の値が</span><span class="thesansmonocd_w5regular_">button</span>である<span class="thesansmonocd_w5regular_">&lt;input&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">細かくマッチさせるためにセレクタのパターンを組み合わせることができます。例えば、<span class="thesansmonocd_w5regular_">soup.select('p #author')</span>は<span class="thesansmonocd_w5regular_">&lt;p&gt;</span>要素内で<span class="thesansmonocd_w5regular_">id</span>属性が<span class="thesansmonocd_w5regular_">author</span>であるものにマッチします。</p>
<p class="tx">タグ値を<span class="thesansmonocd_w5regular_">str()</span>関数に渡すとHTMLタグを見ることができます。タグ値には<span class="thesansmonocd_w5regular_">attrs</span>属性があり、HTML属性を辞書として含んでいます。例えば、<i class="calibre5"><a href="https://autbor.com/example3.html" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/example3<wbr></wbr>.html</a></i>のページを<i class="calibre5">example3.html</i>という名前でダウンロードし、対話型シェルで以下の内容を入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import bs4</b>
&gt;&gt;&gt; <b class="calibre10">example_file = open('example3.html')</b>
&gt;&gt;&gt; <b class="calibre10">example_soup = bs4.BeautifulSoup(example_file.read(), 'html.parser')</b>
&gt;&gt;&gt; <b class="calibre10">elems = example_soup.select('#author')</b>
&gt;&gt;&gt; <b class="calibre10">type(elems)</b> # elemsはTagオブジェクトのリスト
&lt;class 'bs4.element.ResultSet'&gt;
&gt;&gt;&gt; <b class="calibre10">len(elems)</b>
1
&gt;&gt;&gt; <b class="calibre10">type(elems[0])</b>
&lt;class 'bs4.element.Tag'&gt;
&gt;&gt;&gt; <b class="calibre10">str(elems[0])</b>  # Tagオブジェクトを文字列に
'&lt;span id="author"&gt;Al Sweigart&lt;/span&gt;'
&gt;&gt;&gt; <b class="calibre10">elems[0].gettext()</b>  # 要素内のテキスト
'Al Sweigart'
&gt;&gt;&gt; <b class="calibre10">elems[0].attrs</b>
{'id': 'author'}
</code></pre>
<p class="tx">このコードは、先の例のHTMLから<span class="thesansmonocd_w5regular_">id="author"</span>の要素を見つけます。<span class="thesansmonocd_w5regular_">select('#author')</span>は<span class="thesansmonocd_w5regular_">id="author"</span>の要素すべてをリストで返します。その<span class="thesansmonocd_w5regular_">Tag</span>オブジェクトのリストを変数<span class="thesansmonocd_w5regular_">elems</span>に格納します。<span class="thesansmonocd_w5regular_">len(elems)</span>を実行すると（1と表示されたので）、リスト中には<span class="thesansmonocd_w5regular_">Tag</span>オブジェクトが一つあることがわかります。マッチしたのは1件です。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1177" aria-label="309"></span>この要素を<span class="thesansmonocd_w5regular_">str()</span>に渡すと開始タグと終了タグに囲まれたテキスト文字列が返ります。この要素の<span class="thesansmonocd_w5regular_">gettext()</span>を呼び出すと、その要素のテキスト、この例では<span class="thesansmonocd_w5regular_">'Al Sweigart'</span>が返ります。<span class="thesansmonocd_w5regular_">attrs</span>にはその要素の属性が辞書として保存されており、<span class="thesansmonocd_w5regular_">'id'</span>とその<span class="thesansmonocd_w5regular_">id</span>属性の値である<span class="thesansmonocd_w5regular_">'author'</span>があります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトから<span class="thesansmonocd_w5regular_">&lt;p&gt;</span>要素をすべて取得することもできます。以下の内容を対話型シェルに入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">p_elems = example_soup.select('p')</b>
&gt;&gt;&gt; <b class="calibre10">str(p_elems[0])</b>
'&lt;p&gt;This &lt;p&gt; tag puts &lt;b&gt;content&lt;/b&gt; into a &lt;i&gt;single&lt;/i&gt; paragraph.&lt;/p&gt;'
&gt;&gt;&gt; <b class="calibre10">p_elems[0].gettext()</b>
'This &lt;p&gt; tag puts content into a single paragraph.'
&gt;&gt;&gt; <b class="calibre10">str(p_elems[1])</b>
'&lt;p&gt; &lt;a href="https://inventwithpython.com/”&gt;This text is a link&lt;/a&gt; to books by
&lt;span id="author"&gt;Al Sweigart&lt;/span&gt;.&lt;/p&gt;'
&gt;&gt;&gt; <b class="calibre10">p_elems[1].gettext()</b>
'This text is a link to books by Al Sweigart.'
&gt;&gt;&gt; <b class="calibre10">str(p_elems[2])</b>
'&lt;p&gt;&lt;img alt="Close-up of my cat Zophie." src="wow_such_zophie_thumb.webp"/&gt;&lt;/p&gt;'
&gt;&gt;&gt; <b class="calibre10">p_elems[2].gettext()</b>
''
</code></pre>
<p class="tx">今回は<span class="thesansmonocd_w5regular_">select()</span>が3件マッチしました。その結果を<span class="thesansmonocd_w5regular_">p_elems</span>に格納します。<span class="thesansmonocd_w5regular_">p_elems[0]</span>、<span class="thesansmonocd_w5regular_">p_elems[1]</span>、<span class="thesansmonocd_w5regular_">p_elems[2]</span>に<span class="thesansmonocd_w5regular_">str()</span>を適用すると各要素の文字列が示され、各要素の<span class="thesansmonocd_w5regular_">gettext()</span>を使うとテキストが示されます。</p>
</section>
<section type="division" aria-labelledby="sec23">
<h4 class="h1" id="calibre_link-1792"><span id="calibre_link-338"></span><span class="sans_futura_std_heavy_oblique_bi_">要素の属性からデータを取得する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Tag</span>オブジェクトの<span class="thesansmonocd_w5regular_">get()</span>メソッドではHTML要素の属性の値にアクセスできます。このメソッドに属性名を文字列で渡すと、その属性の値を取得できます。<i class="calibre5"><a href="https://autbor.com/example3.html" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/example3<wbr></wbr>.html</a></i>のページを<i class="calibre5">example3.html</i>という名前でダウンロードし、対話型シェルで以下の内容を入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import bs4</b>
&gt;&gt;&gt; <b class="calibre10">soup = bs4.BeautifulSoup(open('example3.html'), 'html.parser')</b>
&gt;&gt;&gt; <b class="calibre10">span_elem = soup.select('span')[0]</b>
&gt;&gt;&gt; <b class="calibre10">str(span_elem)</b>
'&lt;span id="author"&gt;Al Sweigart&lt;/span&gt;'
&gt;&gt;&gt; <b class="calibre10">span_elem.get('id')</b>
'author'
&gt;&gt;&gt; <b class="calibre10">span_elem.get('some_nonexistent_addr') == None</b>
True
&gt;&gt;&gt; <b class="calibre10">span_elem.attrs</b>
{'id': 'author'}
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">select()</span>で<span class="thesansmonocd_w5regular_">&lt;span&gt;</span>要素をすべて探し、最初にマッチした要素を<span class="thesansmonocd_w5regular_">span_elem</span>に格納しています。<span class="thesansmonocd_w5regular_">get()</span>に属性名<span class="thesansmonocd_w5regular_">'id'</span>を渡すと、その属性の値である<span class="thesansmonocd_w5regular_">'author'</span>が返されます。</p>
<p class="ph"><span id="calibre_link-339"></span><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1251" aria-label="310"></span><span class="sans_futura_std_heavy_b_">プロジェクト7：検索結果をすべて開く</span></p>
<p class="tni">私は検索エンジンで調べ物をするときに、複数の検索結果を確認します。検索結果のリンクを<i class="calibre5">中クリック</i>して（あるいは<small class="calibre4">CTRL</small>を押しながらクリックして）、複数のリンクを新しいタブで開いてからそれらを読みます。インターネットで調べ物をすることはしょっちゅうですから、ブラウザを開いて、検索して、検索結果を一つずつ中クリックして、というこの作業フローが面倒です。コマンドラインで検索ワードを入力すれば自動的に検索結果を新しいブラウザのタブで開けるとしたら、素晴らしいことです。</p>
<p class="tx"><i class="calibre5"><a href="https://pypi.org" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org</a></i>のページの検索結果でそれを実現するスクリプトを書いてみましょう。このプログラムを他のウェブサイトでも応用できますが、Google、DuckDuckGo、Amazonなどの大手ウェブサイトでは検索結果ページのスクレイピングを困難にする手段が施されています。</p>
<p class="tx">このプログラムには以下の内容が必要です。

</p>
<ul class="ul">
<li class="bl">コマンドライン引数から検索ワードを取得する</li>
<li class="bl">検索結果ページを取得する</li>
<li class="bl">結果ごとにブラウザのタブを開く</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">sys.argv</span>からコマンドライン引数を読み取る</li>
<li class="bl"><span class="thesansmonocd_w5regular_">requests</span>モジュールで検索ページを取得する</li>
<li class="bl">検索結果の各リンクを見つける</li>
<li class="bl"><span class="thesansmonocd_w5regular_">webbrowser.open()</span>関数を呼び出してウェブブラウザを開く</li>
</ul>
<p class="tx">新しいファイルエディタタブを開いて、<i class="calibre5">searchpypi.py</i>という名前で保存します。</p>
</section>
<section type="division" aria-labelledby="sec24">
<h4 class="h1" id="calibre_link-1793"><span id="calibre_link-340"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：検索ページを取得する</span></h4>
<p class="tni">コードを書く前に、検索結果ページのURLを知る必要があります。検索実行後にブラウザのアドレスバーを見ると、結果のページは<i class="calibre5"><a href="https://pypi.org/search/?q=%3CSEARCH_TERM_HERE%3E" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org<wbr></wbr>/search<wbr></wbr>/<wbr></wbr>?q<wbr></wbr>=&lt;SEARCH<wbr></wbr>_TERM<wbr></wbr>_HERE&gt;</a></i>のようなURLになっていることがわかります。<span class="thesansmonocd_w5regular_">requests</span>モジュールでこのページをダウンロードできます。そして、そのHTML内から、Beautiful Soupを使って検索結果のリンクを見つけます。最後に、<span class="thesansmonocd_w5regular_">webbrowser</span>モジュールでそのリンクをブラウザのタブで開きます。</p>
<p class="tx">コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># searchpypi.py - pypi.orgの複数の検索結果を開く

import requests, sys, webbrowser, bs4

print('Searching...')  # 検索結果ページのダウンロード中にテキストを表示
res = requests.get('https://pypi.org/search/?q=' + ' '.join(sys.argv[1:]))
res.raise_for_status()

# TODO: 検索結果上位のリンクを取得

# TODO: 結果ごとにブラウザのタブを開く
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1794" aria-label="311"></span>ユーザーはコマンドライン引数で検索ワードを指定してプログラムを実行します。そのコマンドライン引数は、<span class="thesansmonocd_w5regular_">sys.argv</span>のリスト内に文字列として格納されています。</p>
</section>
<section type="division" aria-labelledby="sec25">
<h4 class="h1" id="calibre_link-1795"><span id="calibre_link-341"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：すべての結果を見つける</span></h4>
<p class="tni">Beautiful Soupを使って、ダウンロードしたHTMLから検索結果上位のリンクを抽出します。どのようにしてセレクタを指定すればよいでしょうか。例えば、単にすべての<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>タグを探すと、不要なリンクが混じってしまいます。そうではなく、検索結果ページをブラウザのデベロッパーツールで精査し、必要なリンクだけを選べるようなセレクタを見つけ出します。</p>
<p class="tx"><i class="calibre5">pyautogui</i>を検索して、ブラウザのデベロッパーツールを開いてそのページのリンクをいくつか調べます。複雑に見えますが、<span class="thesansmonocd_w5regular_">&lt;a class="package-snippet" href="/project/pyautogui" &gt;</span>のようなものがそれです。要素が非常に込み入っていても落ち着いてください。検索結果のリンクが共通に持っているパターンを見つければよいのです。</p>
<p class="tx">コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># searchpypi.py - pypi.orgの複数の検索結果を開く
import requests, sys, webbrowser, bs4
<var class="calibre20">--snip--</var>
# 検索結果上位のリンクを取得
<b class="calibre10">soup = bs4.BeautifulSoup(res.text, 'parser.html')</b>
# 結果ごとにブラウザのタブを開く
<b class="calibre10">link_elems = soup.select('.package-snippet')</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素を見ると、検索結果のリンクはすべて<span class="thesansmonocd_w5regular_">class="package-snippet"</span>を共通に持っていることがわかります。HTMLソースの残りの部分を見ると、<span class="thesansmonocd_w5regular_">package-snippet</span>クラスは検索結果のリンクにしか使われていないようです。CSSの<span class="thesansmonocd_w5regular_">package-snippet</span>クラスが何であり、どういう働きをしているかを知る必要はありません。探している<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素の印として使うのみです。</p>
<p class="tx">ダウンロードしたページのHTMLテキストから<span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトを作成し、<span class="thesansmonocd_w5regular_">'.package-snippet'</span>というセレクタを使ってCSSクラス<span class="thesansmonocd_w5regular_">package-snippet</span>を持つすべての<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素を見つけます。PyPIウェブサイトがレイアウトを変更したら、新しいCSSセレクタ文字列を<span class="thesansmonocd_w5regular_">soup.select()</span>に渡すように、このプログラムを変更しなければならないかもしれません。プログラムの残りの部分は変更不要なはずです。</p>
</section>
<section type="division" aria-labelledby="sec26">
<h4 class="h1" id="calibre_link-1796"><span id="calibre_link-342"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：結果ごとにウェブブラウザを開く</span></h4>
<p class="tni">最後に、その検索結果について、プログラムでウェブブラウザのタブを開く指示を出します。以下の内容をプログラムの末尾に追加してください。</p>
<pre class="pre"><code class="calibre9"># searchpypi.py - pypi.orgの複数の検索結果を開く
import requests, sys, webbrowser, bs4
--<var class="calibre20">snip</var>--
# 結果ごとにブラウザのタブを開く
link_elems = soup.select('.package-snippet')
<b class="calibre10">num_open = min(5, len(link_elems))</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1121" aria-label="312"></span><b class="calibre10">for i in range(num_open):</b>
<b class="calibre10">    url_to_open = 'https://pypi.org' + link_elems[i].get('href')</b>
<b class="calibre10">    print('Opening', url_to_open)</b>
<b class="calibre10">    webbrowser.open(url_to_open)</b>
</code></pre>
<p class="tx">このプログラムは、デフォルトで、検索結果のうち最初の5つの結果を<span class="thesansmonocd_w5regular_">webbrowser</span>モジュールを使って新しいタブで開きます。しかし、検索結果が5件よりも少ない場合もあります。<span class="thesansmonocd_w5regular_">soup.select()</span>を呼び出すと<span class="thesansmonocd_w5regular_">'.package-snippet'</span>セレクタにマッチしたすべての要素のリストが返されるので、開くタブの数は5かこのリストの要素数のいずれか小さいほうです。</p>
<p class="tx">Pythonの組み込み関数<span class="thesansmonocd_w5regular_">min()</span>は、渡された整数または浮動小数点数の中で最も小さいものを返します。（渡された引数の中で最も大きいものを返す組み込み関数の<span class="thesansmonocd_w5regular_">max()</span>もあります。）<span class="thesansmonocd_w5regular_">min()</span>を使ってリスト中のリンクが5よりも少ないかどうかを判断し、タブを開くリンクの数を<span class="thesansmonocd_w5regular_">num_open</span>という名前の変数に格納します。<span class="thesansmonocd_w5regular_">range(num_open)</span>で<span class="thesansmonocd_w5regular_">for</span>ループを反復します。</p>
<p class="tx">ループの反復ごとに、<span class="thesansmonocd_w5regular_">webbrowser.open()</span>でウェブブラウザの新しいタブを開きます。返される<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素の<span class="thesansmonocd_w5regular_">href</span>属性の値には最初の<i class="calibre5"><a href="https://pypi.org" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org</a></i>という部分がありませんから、これに<span class="thesansmonocd_w5regular_">href</span>属性の値を結合します。</p>
<p class="tx">これで例えばコマンドラインから<span class="thesansmonocd_w5regular_">searchpypi boring stuff</span>と実行すると、PyPIの<i class="calibre5">boring stuff</i>の検索結果から最初の5件をすぐに開くことができます。お使いのOSでプログラムを簡単に実行する方法につきましては、<span>第12章</span>をご参照ください。</p>
</section>
<section type="division" aria-labelledby="sec27">
<h4 class="h1"><span id="calibre_link-1797"></span><span id="calibre_link-343"></span><span class="sans_futura_std_heavy_oblique_bi_">似たようなプログラムのアイデア</span></h4>
<p class="tni">ウェブブラウザでタブを使うと、新しいタブでリンクを開き、あとでゆっくり読むことができます。一度で複数のリンクを自動的に開くプログラムがあれば、以下のような作業を短縮できます。</p>
<ul class="ul">
<li class="bl">Amazonなどのショッピングサイトを検索して商品ページをすべて開く</li>
<li class="bl">一つの商品についてのレビューリンクをすべて開く</li>
<li class="bl">FlickrやImgurのような写真サイトで検索を実行してから検索結果の写真のリンクを開く</li>
</ul>
<p class="ph"><span id="calibre_link-344"></span><span class="sans_futura_std_heavy_b_">プロジェクト8：XKCDコミックをダウンロードする</span></p>
<p class="tni">ブログ、ウェブコミック、その他の定期的に更新されるウェブサイトでは、たいてい、最初のページに最新の投稿が表示され、ボタンをクリックすると以前の投稿を遡って見ることができます。どんどん昔に遡ることができ、最新の投稿から一直線に並べられます。オフラインで読めるようにサイトのコンテンツをコピーしたければ、手動で1ページずつ移動しながら保存できます。しかしこれは退屈な作業ですから、プログラムを書きましょう。</p>
<p class="tx">図13-5に示したXKCDは、先に述べたような構造をした、人気のある技術オタクのウェブコミックです。最初のページは<i class="calibre5"><a href="https://xkcd.com" class="calibre1">https://<wbr></wbr>xkcd<wbr></wbr>.com</a></i>で、Prevボタンをクリックすると過去のコミックを読めます。手動でコミックをダウンロードすると非常に時間がかかりますが、数分で自動ダウンロードするスクリプトを書けます。</p>
<figure class="img"><img class="img1" id="calibre_link-749" src="images/000015.jpg" alt="An excerpt of a comic featuring simple stick figures and text." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 13-5：XKCD, “a webcomic of romance, sarcasm, math, and language”</span></p></figcaption>
</figure>
<p class="tx">このプログラムには以下の内容が必要です。</p>
<ul class="ul">
<li class="bl">XKCDのホームページを読み込む</li>
<li class="bl">そのページのコミック画像を保存する</li>
<li class="bl">過去のコミックをリンクでたどる</li>
<li class="bl">最初のコミックまで遡るかダウンロードの上限に達するまで繰り返す</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">requests</span>モジュールでページをダウンロードする</li>
<li class="bl">Beautiful Soupを使ってそのページのコミック画像のURLを見つける</li>
<li class="bl"><span class="thesansmonocd_w5regular_">iter_content()</span>でそのコミック画像をダウンロードしてハードドライブ上に保存する</li>
<li class="bl">過去のコミックへのリンクURLを見つけ、動作を繰り返す</li>
</ul>
<p class="tx">新しいファイルエディタタブを開いて、<i class="calibre5">downloadXkcdComics.py</i>という名前で保存します。</p>
</section>
<section type="division" aria-labelledby="sec28">
<h4 class="h1" id="calibre_link-1798"><span id="calibre_link-345"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：プログラムを設計する</span></h4>
<p class="tni">ブラウザのデベロッパーツールを開いてページの要素を調べると、以下の事実を発見するはずです。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">&lt;img&gt;</span>要素の<span class="thesansmonocd_w5regular_">src</span>属性にコミックの画像ファイルURLがある</li>
<li class="bl"><span class="thesansmonocd_w5regular_">&lt;img&gt;</span>要素は<span class="thesansmonocd_w5regular_">&lt;div id="comic"&gt;</span>要素内にある</li>
<li class="bl"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1799" aria-label="314"></span>Prevボタンには<span class="thesansmonocd_w5regular_">rel</span>というHTML属性があり、その値は<span class="thesansmonocd_w5regular_">prev</span></li>
<li class="bl">一番古いコミックのPrevボタンのリンクは<i class="calibre5"><a href="https://xkcd.com/#" class="calibre1">https://<wbr></wbr>xkcd<wbr></wbr>.com<wbr></wbr>/#</a></i>というURLで、これ以上前のページはない</li>
</ul>
<p class="tx">本書の読者がコードを実行してXKCDウェブサイトの帯域幅を使い過ぎてしまわないように、デフォルトで最大ダウンロード数を10に制限します。コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># downloadXkcdComics.py - XKCDコミックのダウンロード

import requests, os, bs4, time

url = 'https://xkcd.com'  # 開始URL
os.makedirs('xkcd', exist_ok=True)  # コミックを./xkcdに保存
num_downloads = 0
MAX_DOWNLOADS = 10
while not url.endswith('#') and num_downloads &lt; MAX_DOWNLOADS:
    # TODO: ページをダウンロード

    # TODO: コミック画像のURLを見つける

    # TODO: 画像をダウンロード

    # TODO: 画像を./xkcdに保存

    # TODO: PrevボタンのURLを取得

print('Done.')
</code></pre>
<p class="tx">このプログラムでは、変数<span class="thesansmonocd_w5regular_">url</span>を<span class="thesansmonocd_w5regular_">'https://xkcd.com'</span>という値で始めて、現在のページのPrevリンクのURLに（<span class="thesansmonocd_w5regular_">while</span>ループ内で）更新していきます。ループの各ステップでは、<span class="thesansmonocd_w5regular_">url</span>からコミックをダウンロードします。<span class="thesansmonocd_w5regular_">url</span>が<span class="thesansmonocd_w5regular_">'#'</span>で終わるか<span class="thesansmonocd_w5regular_">MAX_DOWNLOADS</span>回コミックをダウンロードしたらループは終了します。</p>
<p class="tx">現在の作業ディレクトリ内の<i class="calibre5">xkcd</i>という名前のフォルダに画像ファイルをダウンロードします。<span class="thesansmonocd_w5regular_">os.makedirs()</span>を呼び出して確実にそのフォルダが存在するようにし、<span class="thesansmonocd_w5regular_">exist_ok=True</span>キーワード引数を指定してそのフォルダがすでに存在しても例外を送出しないようにします。</p>
</section>
<section type="division" aria-labelledby="sec29">
<h4 class="h1" id="calibre_link-1800"><span id="calibre_link-346"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：ウェブページをダウンロードする</span></h4>
<p class="tni">ページをダウンロードするコードを実装しましょう。コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># downloadXkcdComics.py - XKCDコミックのダウンロード

import requests, os, bs4, time

url = 'https://xkcd.com'  # 開始URL
os.makedirs('xkcd', exist_ok=True)  #  コミックを./xkcdに保存
num_downloads = 0
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1801" aria-label="315"></span>MAX_DOWNLOADS = 10
while not url.endswith('#') and num_downloads &lt; MAX_DOWNLOADS:
    # ページをダウンロード
<b class="calibre10">    print(f'Downloading page {url}...')</b>
<b class="calibre10">    res = requests.get(url)</b>
<b class="calibre10">    res.raise_for_status()</b>

<b class="calibre10">  </b>  <b class="calibre10">soup = bs4.BeautifulSoup(res.text, 'html.parser')</b>

    # TODO: コミック画像のURLを見つける

    # TODO: 画像をダウンロード

    # TODO: 画像を./xkcdに保存

    # TODO: PrevボタンのURLを取得

print('Done.')
</code></pre>
<p class="tx">まず、どのURLをダウンロードしようとしているかユーザーにわかるように、<span class="thesansmonocd_w5regular_">url</span>を表示します。次に、<span class="thesansmonocd_w5regular_">requests</span>モジュールの<span class="thesansmonocd_w5regular_">requests.get()</span>関数を使ってそのURLをダウンロードします。いつもの要領で、<span class="thesansmonocd_w5regular_">Response</span>オブジェクトの<span class="thesansmonocd_w5regular_">raise_for_status()</span>メソッドを呼び出し、ダウンロードに不具合があれば例外を送出してプログラムを終了します。ダウンロードが成功すれば、ダウンロードしたページのテキストから<span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトを作成します。</p>
</section>
<section type="division" aria-labelledby="sec30">
<h4 class="h1" id="calibre_link-1802"><span id="calibre_link-347"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：コミック画像を見つけてダウンロードする</span></h4>
<p class="tni">各ページのコミックをダウンロードするコードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># downloadXkcdComics.py - XKCDコミックのダウンロード

import requests, os, bs4, time

--<var class="calibre20">snip</var>--

    # コミック画像のURLを見つける
<b class="calibre10">    comic_elem = soup.select('#comic img')</b>
<b class="calibre10">    if comic_elem == []:</b>
<b class="calibre10">        print('Could not find comic image.')</b>
<b class="calibre10">    else:</b>
<b class="calibre10">        comic_URL = 'https:' + comic_elem[0].get('src')</b>
        # 画像をダウンロード
<b class="calibre10">        print(f'Downloading image {comic_URL}...')</b>
<b class="calibre10">        res = requests.get(comic_URL)</b>
<b class="calibre10">        res.raise_for_status()</b>

    # TODO: 画像を./xkcdに保存

    # TODO: PrevボタンのURLを取得

print('Done.')
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1803" aria-label="316"></span>XKCDホームページをデベロッパーツールで調べて、コミック画像の<span class="thesansmonocd_w5regular_">&lt;img&gt;</span>要素は<span class="thesansmonocd_w5regular_">id</span>属性が<span class="thesansmonocd_w5regular_">comic</span>である要素内にあることがわかっています。よって、セレクタ<span class="thesansmonocd_w5regular_">'#comic img'</span>により<span class="thesansmonocd_w5regular_">BeautifulSoup</span>オブジェクトから正しい<span class="thesansmonocd_w5regular_">&lt;img&gt;</span>要素を取得できます。</p>
<p class="tx">XKCDページの中には、単純な画像ファイルではない特別なコンテンツがあるページが少数あります。そのようなページはスキップしましょう。先ほどのセレクタで要素を見つけることができなければ、<span class="thesansmonocd_w5regular_">soup.select('#comic img')</span>は空リストの<span class="thesansmonocd_w5regular_">ResultSet</span>オブジェクトを返します。その場合、プログラムはエラーメッセージを表示し、画像をダウンロードせずに次に進みます。</p>
<p class="tx">要素を見つけることができれば、<span class="thesansmonocd_w5regular_">&lt;img&gt;</span>要素を一つ含むリストを返します。この<span class="thesansmonocd_w5regular_">&lt;img&gt;</span>要素の<span class="thesansmonocd_w5regular_">src</span>属性を取得し、それを<span class="thesansmonocd_w5regular_">requests .get()</span>に渡せば、コミックの画像ファイルをダウンロードできます。</p>
</section>
<section type="division" aria-labelledby="sec31">
<h4 class="h1" id="calibre_link-1804"><span id="calibre_link-348"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ4：画像を保存して前のコミックを見つける</span></h4>
<p class="tni">ここまでで、コミックの画像ファイルが変数<span class="thesansmonocd_w5regular_">res</span>に格納されます。この画像データをハードドライブ上のファイルに書き込みます。コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># downloadXkcdComics.py - XKCDコミックのダウンロード

import requests, os, bs4, time

--<var class="calibre20">snip</var>--

    # 画像を./xkcdに保存
<b class="calibre10">        image_file = open(os.path.join('xkcd', os.path.basename(comic_URL)), 'wb')</b>
<b class="calibre10">            for chunk in res.iter_content(100000):</b>
<b class="calibre10">               image_file.write(chunk)</b>
<b class="calibre10">            image_file.close()</b>

    # PrevボタンのURLを取得
<b class="calibre10">      prev_link = soup.select('a[rel="prev"]')[0]</b>
<b class="calibre10">      url = 'https://xkcd.com' + prev_link.get('href')</b>
<b class="calibre10">      num_downloads += 1</b>
<b class="calibre10">      time.sleep(1)  </b># ウェブサーバーに負荷をかけすぎないように待機

print('Done.')
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">open()</span>に渡す画像ファイルの名前が必要です。<span class="thesansmonocd_w5regular_">comic_URL</span>は<span class="thesansmonocd_w5regular_">'https://imgs.xkcd.com/comics/heartbleed_explanation.png'</span>のような値であり、ファイルパスに似ています。実際に、<span class="thesansmonocd_w5regular_">comic_URL</span>について<span class="thesansmonocd_w5regular_">os.path.basename()</span>を呼び出すと、<span class="thesansmonocd_w5regular_">'heartbleed_explanation.png'</span>のようなURLの最後の部分だけが返されます。これを画像をハードドライブ上に保存するときのファイル名として利用します。<span class="thesansmonocd_w5regular_">os.path.join()</span>を使ってこの名前を<span class="thesansmonocd_w5regular_">xkcd</span>フォルダの名前と連結します。そうすれば、Windowsではバックスラッシュ（<span class="thesansmonocd_w5regular_">\</span>）、macOSとLinuxではスラッシュ（<span class="thesansmonocd_w5regular_">/</span>）でつないでくれます。これでファイル名が用意できましたから、<span class="thesansmonocd_w5regular_">open()</span>を呼び出して新しいファイルを<span class="thesansmonocd_w5regular_">'wb'</span>モードで開きます。</p>
<p class="tx">本章の最初のほうで説明したように、<span class="thesansmonocd_w5regular_">requests</span>でダウンロードしたファイルを保存するには、<span class="thesansmonocd_w5regular_">iter_content()</span>メソッドの返り値をループで反復処理します。<span class="thesansmonocd_w5regular_">for</span>ループ内のコードで画像データのチャンクをファイルに書き込みます。それから、ファイルを閉じ、画像をハードドライブ上に保存します。</p>
<p class="tx">それから、セレクタ<span class="thesansmonocd_w5regular_">'a[rel="prev"]'</span>により、<span class="thesansmonocd_w5regular_">rel</span>属性の値が<span class="thesansmonocd_w5regular_">prev</span>である<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素を特定します。この<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素の<span class="thesansmonocd_w5regular_">href</span>属性を使って前のコミックのURLを取得でき、それを<span class="thesansmonocd_w5regular_">url</span>に格納します。</p>
<p class="tx">ループのコードの最後の部分では、デフォルトでコミックをすべてダウンロードしないように、<span class="thesansmonocd_w5regular_">num_downloads</span>を<span class="thesansmonocd_w5regular_">1</span>ずつ増やしています。また、スクリプトがサイトに高頻度でアクセスしないように、<span class="thesansmonocd_w5regular_">time.sleep(1)</span>で1秒待機しています。（コミックを最大速度でダウンロードすると、他のサイト閲覧者のパフォーマンス問題を引き起こす可能性があります。）それから、<span class="thesansmonocd_w5regular_">while</span>ループがダウンロードをもう一度開始します。</p>
<p class="tx">このプログラムの出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">Downloading page https://xkcd.com...
Downloading image https://imgs.xkcd.com/comics/phone_alarm.png...
Downloading page https://xkcd.com/1358/...
Downloading image https://imgs.xkcd.com/comics/nro.png...
Downloading page https://xkcd.com/1357/...
Downloading image https://imgs.xkcd.com/comics/free_speech.png...
Downloading page https://xkcd.com/1356/...
Downloading image https://imgs.xkcd.com/comics/orbital_mechanics.png...
Downloading page https://xkcd.com/1355/...
Downloading image https://imgs.xkcd.com/comics/airplane_message.png...
Downloading page https://xkcd.com/1354/...
Downloading image https://imgs.xkcd.com/comics/heartbleed_explanation.png...
--<var class="calibre20">snip</var>--
</code></pre>
<p class="tx">このプログラムは、リンクをたどって自動的にウェブから大量のデータをスクレイピングするプログラムの好例です。Beautiful Soupの他の機能については<i class="calibre5"><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.crummy<wbr></wbr>.com<wbr></wbr>/software<wbr></wbr>/BeautifulSoup<wbr></wbr>/bs4<wbr></wbr>/doc<wbr></wbr>/</a></i>のドキュメントで説明されています。</p>
</section>
<section type="division" aria-labelledby="sec32">
<h4 class="h1"><span id="calibre_link-1806"></span><span id="calibre_link-349"></span><span class="sans_futura_std_heavy_oblique_bi_">似たようなプログラムのアイデア</span></h4>
<p class="tni">ウェブをクロールするプログラムでは、ページをダウンロードしてリンクをたどることが多いです。以下のような内容が考えられます。</p>
<ul class="ul">
<li class="bl">すべてのリンクをたどりサイトを丸ごとバックアップする</li>
<li class="bl">ウェブフォーラムのメッセージをすべてコピーする</li>
<li class="bl">オンラインストアの販売商品カタログを複製する</li>
</ul>
<p class="tx"><span class="thesansmonocd_w5regular_">requests.get()</span>に渡すURLがわかるのであれば、<span class="thesansmonocd_w5regular_">requests</span>モジュールと<span class="thesansmonocd_w5regular_">bs4</span>モジュールが大いに役立ちます。しかし、URLがいつもそれほど簡単に見つけられるとは限りません。あるいは、対象とするウェブサイトでは最初にログインしなければならないかもしれません。Seleniumを使えばそうした高度な作業を行う力を得られます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec33">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-982" aria-label="318"></span>
<h3 class="h" id="calibre_link-1807"><span id="calibre_link-350"></span><span class="sans_futura_std_bold_b_">Seleniumでブラウザを制御する</span></h3>
<p class="tni">Seleniumでは、人間がリンクをクリックしたりフォームを入力したりするのと同じことをプログラムで行うことができ、Pythonが直接ブラウザを制御できます。Seleniumを使うと、<span class="thesansmonocd_w5regular_">requests</span>やBeautiful Soupよりも高度な方法でウェブページとやり取りできます。他方でSeleniumはウェブブラウザを立ち上げますから、ウェブからファイルをダウンロードするだけであっても、少し遅く、バッググラウンドで実行するのは難しいです。</p>
<p class="tx">それでも、例えばJavaScriptのコードがページを更新するようなウェブサイトとやり取りするためには、<span class="thesansmonocd_w5regular_">requests</span>ではなくSeleniumが必要になります。AmazonのようなEコマースの大手は、スクリプトが情報を集めようとしたり多数のアカウントを作成しようとしているのを検知するソフトウェアシステムを導入しています。これらのサイトでは、スクリプトが検知されると、一定の間ページが表示されなくなり、スクリプトが機能しなくなります。これらのサイトでは、Seleniumのほうが<span class="thesansmonocd_w5regular_">requests</span>よりもうまく動作する可能性がはるかに高いです。</p>
<p class="tx">スクリプトがウェブサイトにアクセスしているのだとわかる主な印は、<i class="calibre5">ユーザーエージェント</i>文字列です。これはHTTPリクエストに含まれる、ウェブブラウザを識別する文字列です。例えば、<span class="thesansmonocd_w5regular_">requests</span>モジュールのユーザーエージェント文字列は<span class="thesansmonocd_w5regular_">'python-requests/</span><span class="sans_thesansmonocd_w5regular_italic_">X.XX.X</span><span class="thesansmonocd_w5regular_">'</span>のようになります。<i class="calibre5"><a href="https://www.whatsmyua.info" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.whatsmyua<wbr></wbr>.info</a></i>を訪問すればアクセスしたユーザーエージェント文字列を確かめられます。Seleniumを使うと、人間だと判断される可能性が高いです。というのも、Seleniumのユーザーエージェントは通常のブラウザと同じ（例：<span class="thesansmonocd_w5regular_">' Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0'</span>）であることに加えて、画像、広告、クッキー、トラッカーなどをダウンロードするトラフィックのパターンも同じだからです。それでも、Seleniumを判別する方法はあり、主要なEコマースサイトは、自分たちのサイトをスクレイピングされないようにSeleniumをブロックしています。</p>
<section type="division" aria-labelledby="sec34">
<h4 class="h1" id="calibre_link-1808"><span id="calibre_link-351"></span><span class="sans_futura_std_heavy_oblique_bi_">Seleniumで制御されたブラウザを立ち上げる</span></h4>
<p class="tni">以下の例ではFirefoxウェブブラウザを制御する方法を示します。Firefoxがなければ<i class="calibre5"><a href="https://getfirefox.com" class="calibre1">https://<wbr></wbr>getfirefox<wbr></wbr>.com</a></i>から無料でダウンロードできます。</p>
<p class="tx">Seleniumのモジュールのインポートは少しややこしいです。<span class="thesansmonocd_w5regular_">import selenium</span>ではなく<b class="calibre10">from selenium import webdriver</b>としなければなりません（その理由の正確な説明は本書の範囲外です）。そうすると、SeleniumでFirefoxを立ち上げられます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from selenium import webdriver</b>
&gt;&gt;&gt; <b class="calibre10">browser = webdriver.Firefox()</b>
&gt;&gt;&gt; <b class="calibre10">type(browser)</b>
&lt;class 'selenium.webdriver.firefox.webdriver.WebDriver'&gt;
&gt;&gt;&gt; <b class="calibre10">browser.get('https://inventwithpython.com')</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">webdriver.Firefox()</span>を呼び出すと、Firefoxウェブブラウザが起動します。<span class="thesansmonocd_w5regular_">webdriver.Firefox()</span>の値について<span class="thesansmonocd_w5regular_">type()</span>を呼び出すと、<span class="thesansmonocd_w5regular_">WebDriver</span>データ型であることがわかります。<span class="thesansmonocd_w5regular_">browser.get('https://inventwithpython.com')</span>を呼び出すと、ブラウザが<i class="calibre5"><a href="https://inventwithpython.com" class="calibre1">https://<wbr></wbr>inventwithpython<wbr></wbr>.com</a></i>に移動します。図13-6のように見えるはずです。</p>
<figure class="img"><img class="img1" id="calibre_link-750" src="images/000016.jpg" alt="A screenshot of a web browser open to the web page at inventwithpython.com. Superimposed onto it is the Mu console." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 13-6：</span><span class="sans_thesansmonocd_w5regular_italic_">webdriver.Firefox</span><span class="sans_futura_std_book_oblique_i_">()と</span><span class="sans_thesansmonocd_w5regular_italic_">get()</span><span class="sans_futura_std_book_oblique_i_">をMuで呼び出したあとのFirefoxブラウザの状態</span></p></figcaption>
</figure>
<p class="tx">“geckodriver executable needs to be in PATH”というエラーメッセージが表示されたら、Seleniumで制御できるように、Firefoxのウェブドライバを手動でダウンロードする必要があります。ウェブドライバをインストールすればFirefox以外のブラウザも制御できます。手動でウェブドライバをインストールしなくても、<i class="calibre5"><a href="https://pypi.org/project/webdriver-manager/" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org<wbr></wbr>/project<wbr></wbr>/webdriver<wbr></wbr>-manager<wbr></wbr>/</a></i>からウェブドライバ管理パッケージを利用できます。</p>
</section>
<section type="division" aria-labelledby="sec35">
<h4 class="h1" id="calibre_link-1809"><span id="calibre_link-352"></span><span class="sans_futura_std_heavy_oblique_bi_">ブラウザのボタンをクリックする</span></h4>
<p class="tni">Seleniumでは、以下のメソッドで、ブラウザの各種ボタンのクリックをシミュレートできます。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">browser.back() </span>戻るボタンのクリック</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">browser.forward() </span>進むボタンのクリック</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">browser.refresh() </span>更新ボタンのクリック</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">Browser.quit() </span>ウィンドウを閉じるボタンのクリック</p>
</section>
<section type="division" aria-labelledby="sec36">
<h4 class="h1" id="calibre_link-1810"><span id="calibre_link-353"></span><span class="sans_futura_std_heavy_oblique_bi_">ページの要素を見つける</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">WebDriver</span>オブジェクトには、ウェブページの要素を見つけるための<span class="thesansmonocd_w5regular_">find_element()</span>メソッドと<span class="thesansmonocd_w5regular_">find_elements()</span>メソッドがあります。<span class="thesansmonocd_w5regular_">find_element()</span>メソッドは、そのページでクエリにマッチする最初の要素を表す、一つの<span class="thesansmonocd_w5regular_">WebElement</span>オブジェクトを返します。<span class="thesansmonocd_w5regular_">find_elements()</span>メソッドは、そのページでマッチする<i class="calibre5">すべての</i>要素の<span class="thesansmonocd_w5regular_">WebElement</span>オブジェクトのリストを返します。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-989" aria-label="320"></span>クラス名、CSSセレクタ、IDその他の手段で要素を探せます。最初に<span class="sans_thesansmonocd_w7bold_b_">from selenium.webdriver.common.by import By</span>を実行して、<span class="thesansmonocd_w5regular_">By</span>オブジェクトを取得してください。<span class="thesansmonocd_w5regular_">By</span>オブジェクトは、<span class="thesansmonocd_w5regular_">find_element()</span>メソッドと<span class="thesansmonocd_w5regular_">find_elements()</span>メソッドに渡すことのできる定数を持っています。表13-3でその定数を一覧にまとめました。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-751"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 13-3：</span></span> <span class="sans_futura_std_book_">要素を見つけるためのSeleniumの</span><span class="thesansmonocd_w5regular_">By</span><span class="sans_futura_std_book_">定数</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">定数名</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_thesansmonocd_w7bold_b_">返されるWebElementオブジェクト/リスト</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">By.CLASS_NAME</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">指定したCSSクラス名の要素</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">By.CSS_SELECTOR</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">指定したCSSセレクタの要素</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">By.ID</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">指定した</span><span class="sans_thesansmonocd_w5regular_italic_">id</span><span class="sans_futura_std_book_">の値の要素</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">By.LINK_TEXT</span></p></td>
<td class="tb"><p class="tch1">指定したテキストに完全一致する<span class="thesansmonocd_w5regular_">&lt;a&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">By.PARTIAL_LINK_TEXT</span></p></td>
<td class="tb"><p class="tch1">指定したテキストを含む<span class="thesansmonocd_w5regular_">&lt;a&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">By.NAME</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">指定した</span><span class="sans_thesansmonocd_w5regular_italic_">name</span><span class="sans_futura_std_book_">属性の値の要素</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">By.TAG_NAME</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">指定したタグの要素（大文字と小文字を区別しないので</span><span class="thesansmonocd_w5regular_">'a'</span><span class="sans_futura_std_book_">でも</span><span class="thesansmonocd_w5regular_">'A'</span><span class="sans_futura_std_book_">でも</span><span class="thesansmonocd_w5regular_">&lt;a&gt;</span>にマッチします）</p></td>
</tr>
</tbody>
</table>
<p class="tx">そのページにマッチする要素が存在しなければ、<span class="thesansmonocd_w5regular_">NoSuchElement</span>例外が送出されます。この例外によりプログラムをクラッシュさせたくなければ、<span class="thesansmonocd_w5regular_">try</span>文と<span class="thesansmonocd_w5regular_">except</span>文で処理してください。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">WebElement</span>オブジェクトを取得したら、表13-4の属性やメソッドからその要素についての情報が得られます。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-752"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 13-4:</span></span> <span class="thesansmonocd_w5regular_">WebElement</span><span class="sans_futura_std_book_">の属性とメソッド</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">属性またはメソッド</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_"></span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">tag_name</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素では<span class="thesansmonocd_w5regular_">'a'</span><span class="sans_futura_std_book_">のようなタグ名</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">get_attribute(</span><span class="sans_thesansmonocd_w5regular_italic_">name</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;a&gt;</span><span class="sans_futura_std_book_">要素の</span><span class="thesansmonocd_w5regular_">href</span> <span class="sans_futura_std_book_">のようにその要素の属性名を指定したときのその属性の値</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">get_property(</span><span class="sans_thesansmonocd_w5regular_italic_">name</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">innerHTML</span><span class="sans_futura_std_book_">や</span> <span class="thesansmonocd_w5regular_">innerText</span><span class="sans_futura_std_book_">など</span><span class="sans_futura_std_book_">HTMLコードに現れない要素のプロパティの値</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">text</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;span&gt;hello</span><span class="thesansmonocd_w5regular_">&lt;/span&gt;では<span class="thesansmonocd_w5regular_">'hello'</span></span><span class="sans_futura_std_book_">のような要素内のテキスト</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">clear()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">テキストフィールドやテキストエリアの要素で入力されたテキストを消去する</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">is_displayed()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">要素が見える状態なら</span><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">を返し、見えない状態なら</span><span class="thesansmonocd_w5regular_">False</span><span class="sans_futura_std_book_">を返す</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">is_enabled()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">input要素が有効なら</span><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">を返し、無効なら</span><span class="thesansmonocd_w5regular_">False</span><span class="sans_futura_std_book_">を返す</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">is_selected()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">チェックボックスやラジオボタンの要素で選択された状態なら</span><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">を返し、選択されていない状態なら</span><span class="thesansmonocd_w5regular_">False</span><span class="sans_futura_std_book_">を返す</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">location</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">ページ内でその要素の位置を表す</span> <span class="thesansmonocd_w5regular_">'x'</span><span class="sans_futura_std_book_">と</span><span class="thesansmonocd_w5regular_">'y'</span><span class="sans_futura_std_book_">のキーを持つ辞書</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">size</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">ページ内でその要素のサイズを表す</span><span class="thesansmonocd_w5regular_">'width'</span><span class="sans_futura_std_book_">と</span><span class="thesansmonocd_w5regular_">'height'</span><span class="sans_futura_std_book_">のキーを持つ辞書</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1022" aria-label="321"></span>例えば、新しいファイルエディタのタブを開いて、次のプログラムを入力してください。</p>
<pre class="pre"><code class="calibre9">from selenium import webdriver
from selenium.webdriver.common.by import By
browser = webdriver.Firefox()
browser.get('https://autbor.com/example3.html')
elems = browser.find_elements(By.CSS_SELECTOR, 'p')
print(elems[0].text)
print(elems[0].get_property('innerHTML'))
</code></pre>
<p class="tx">Firefoxを開いて指定したURLに移動します。このページで<span class="thesansmonocd_w5regular_">&lt;p&gt;</span>要素のリストを取得し、インデックス<span class="thesansmonocd_w5regular_">0</span>でその最初の要素の<span class="thesansmonocd_w5regular_">&lt;p&gt;</span>要素内のテキストを取得します。次に<span class="thesansmonocd_w5regular_">innerHTML</span>プロパティの文字列を取得します。このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">This &lt;p&gt; tag puts content into a single paragraph.
This &lt;p&gt; tag puts &lt;b&gt;content&lt;/b&gt; into a &lt;i&gt;single&lt;/i&gt; paragraph.
</code></pre>
<p class="tx">要素の<span class="thesansmonocd_w5regular_">text</span>属性はウェブブラウザで見ているテキスト“This <span class="thesansmonocd_w5regular_">&lt;p&gt;</span> tag puts content into a single paragraph.”です。要素の<span class="thesansmonocd_w5regular_">innerHTML</span>プロパティを<span class="thesansmonocd_w5regular_">get_property()</span>メソッドを呼び出して調べると、タグとHTMLエンティティ（<span class="thesansmonocd_w5regular_">&lt;</span>と<span class="thesansmonocd_w5regular_">&gt;</span>は小なり記号と大なり記号を表すHTMLエスケープ文字です）を含むHTMLのソースコードになっています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">text</span>属性は<span class="thesansmonocd_w5regular_">get_property('innerText')</span>を呼び出すのと同じ意味のショートカットです。<i class="calibre5">innerHTML</i>と<i class="calibre5">innerText</i>は、HTML要素のプロパティの標準の名前です。こうしたHTML要素のプロパティはJavaScriptのコードやウェブドライバでアクセスされるものであるのに対し、<span class="thesansmonocd_w5regular_">&lt;a href="https://inventwithpython.com"&gt;</span>のようなHTML要素の<span class="thesansmonocd_w5regular_">href</span> 属性はHTMLソースコードの一部です。</p>
</section>
<section type="division" aria-labelledby="sec37">
<h4 class="h1" id="calibre_link-1811"><span id="calibre_link-354"></span><span class="sans_futura_std_heavy_oblique_bi_">ページの要素をクリックする</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">find_element()</span>メソッド及び<span class="thesansmonocd_w5regular_">find_elements()</span>メソッドから返される<span class="thesansmonocd_w5regular_">WebElement</span>オブジェクトには、その要素のクリックをシミュレートする<span class="thesansmonocd_w5regular_">click()</span>メソッドがあります。このメソッドを使うと、リンクをクリックしてたどったり、ラジオボタンの選択をしたり、送信ボタンのクリックをしたり、その他マウスで要素をクリックしたら起こることを何でもシミュレートできます。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from selenium import webdriver</b>
&gt;&gt;&gt; <b class="calibre10">from selenium.webdriver.common.by import By</b>
&gt;&gt;&gt; <b class="calibre10">browser = webdriver.Firefox()</b>
&gt;&gt;&gt; <b class="calibre10">browser.get('https://autbor.com/example3.html')</b>
&gt;&gt;&gt; <b class="calibre10">link_elem = browser.find_element(By.LINK_TEXT, 'This text is a link')</b>
&gt;&gt;&gt; <b class="calibre10">type(link_elem)</b>
&lt;class 'selenium.webdriver.remote.webelement.WebElement'&gt;
&gt;&gt;&gt; <b class="calibre10">link_elem.click()  </b># "This text is a link"リンクをたどる
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-948" aria-label="322"></span>このコードはFirefoxを開いて<i class="calibre5"><a href="https://autbor.com/example3.html" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/example3<wbr></wbr>.html</a></i>に移動し、<i class="calibre5">This is a link</i>というテキストの<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素の<span class="thesansmonocd_w5regular_">WebElement</span>オブジェクトを取得して、人間がそのリンクをクリックしたかのように<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素をクリックすることにより、リンクをたどります。</p>
</section>
<section type="division" aria-labelledby="sec38">
<h4 class="h1" id="calibre_link-1812"><span id="calibre_link-355"></span><span class="sans_futura_std_heavy_oblique_bi_">フォームに入力して送信する</span></h4>
<p class="tni">ウェブページ上のテキストフィールドへの入力は、テキストフィールドの<span class="thesansmonocd_w5regular_">&lt;input&gt;</span>要素ないし<span class="thesansmonocd_w5regular_">&lt;textarea&gt;</span>要素を見つけて、<span class="thesansmonocd_w5regular_">send_keys()</span>メソッドを呼び出すという方法で行います。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from selenium import webdriver</b>
&gt;&gt;&gt; <b class="calibre10">from selenium.webdriver.common.by import By</b>
&gt;&gt;&gt; <b class="calibre10">browser = webdriver.Firefox()</b>
&gt;&gt;&gt; <b class="calibre10">browser.get('https://autbor.com/example3.html')</b>
&gt;&gt;&gt; <b class="calibre10">user_elem = browser.find_element(By.ID, 'login_user')</b>
&gt;&gt;&gt; <b class="calibre10">user_elem.send_keys('</b><b class="calibre10"><var class="calibre20">your_real_username_here</var></b><b class="calibre10">')</b>
&gt;&gt;&gt; <b class="calibre10">password_elem = browser.find_element(By.ID, 'login_pass')</b>
&gt;&gt;&gt; <b class="calibre10">password_elem.send_keys('</b><b class="calibre10"><var class="calibre20">your_real_password_here</var></b><b class="calibre10">')</b>
&gt;&gt;&gt; <b class="calibre10">password_elem.submit()</b>
</code></pre>
<p class="tx">ログインページのユーザー名とパスワードの<span class="thesansmonocd_w5regular_">&lt;input&gt;</span>要素の<span class="thesansmonocd_w5regular_">id</span>が変更されない限り、このコードはそれらのテキストフィールドを見つけます（ブラウザの検証を活用して対象となる<span class="thesansmonocd_w5regular_">id</span>を検証できます）。フォーム内の任意の要素について<span class="thesansmonocd_w5regular_">submit()</span>メソッドを呼び出すと、そのフォームの送信ボタンをクリックするのと同じ結果を得られます（<span class="thesansmonocd_w5regular_">user_elem.submit()</span>を呼び出しても<span class="thesansmonocd_w5regular_">password_elem.submit()</span>を呼び出すのと同じです）。
</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_1">警告</span></p>
</blockquote>
<p class="note-txt"><i class="calibre5">できるだけパスワードをソースコードに書かないようにしてください。暗号化しないでいると誤ってパスワードが流出する事態につながりやすいです。</i></p>
</section>
<section type="division" aria-labelledby="sec39">
<h4 class="h1" id="calibre_link-1813"><span id="calibre_link-356"></span><span class="sans_futura_std_heavy_oblique_bi_">特別なキーを入力する</span></h4>
<p class="tni">Seleniumには<span class="thesansmonocd_w5regular_">selenium.webdriver.common.keys</span>というモジュールがあり、その属性でキーボードのキーを表せます。このモジュール名は長いですから、プログラムの冒頭で<span class="thesansmonocd_w5regular_">from selenium.webdriver.common.keys import Keys</span>を実行しておくと、<span class="thesansmonocd_w5regular_">selenium.webdriver.common.keys</span>と書かなければならないところで<span class="thesansmonocd_w5regular_">Keys</span>と短く書けます。</p>
<p class="tx">以下の定数を<span class="thesansmonocd_w5regular_">send_keys()</span>に渡せます。</p>
<pre class="pre1"><code class="calibre9">Keys.ENTER  Keys.PAGE_UP       Keys.DOWN
Keys.RETURN  Keys.ESCAPE        Keys.LEFT
Keys.HOME    Keys.BACK_SPACE    Keys.RIGHT
Keys.END     Keys.DELETE        Keys.TAB
Keys.PAGE_DOWN   Keys.UP        Keys.F1 to Keys.F12
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">'hello'</span>や<span class="thesansmonocd_w5regular_">'?'</span>のような文字列を渡すこともできます。</p>
<p class="tx">例えば、現在カーソルがテキストフィールドにないとして、<small class="calibre4">HOME</small>キーを押せばページの最上部に、<small class="calibre4">END</small>キーを押せばページの最下部に、ブラウザがスクロールします。以下の内容を対話型シェルに入力して、<span class="thesansmonocd_w5regular_">send_keys()</span>呼び出しがページをスクロールさせる様子を確認してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from selenium import webdriver</b>
&gt;&gt;&gt; <b class="calibre10">from selenium.webdriver.common.by import By</b>
&gt;&gt;&gt; <b class="calibre10">from selenium.webdriver.common.keys import Keys</b>
&gt;&gt;&gt; <b class="calibre10">browser = webdriver.Firefox()</b>
&gt;&gt;&gt; <b class="calibre10">browser.get('https://nostarch.com')</b>
&gt;&gt;&gt; <b class="calibre10">html_elem = browser.find_element(By.TAG_NAME, 'html')</b>
&gt;&gt;&gt; <b class="calibre10">html_elem.send_keys(Keys.END)</b>  # 最下部にスクロール
&gt;&gt;&gt; <b class="calibre10">html_elem.send_keys(Keys.HOME)</b>  # 最上部ににスクロール
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">&lt;html</span>&gt;タグはHTMLのベースタグです。HTMLファイルのすべての内容は<span class="thesansmonocd_w5regular_">&lt;html&gt;</span>と<span class="thesansmonocd_w5regular_">&lt;/html&gt;</span>で囲まれています。<span class="thesansmonocd_w5regular_">&lt;html&gt;</span>タグを通じてウェブページ全体にキー入力を送るには、<span class="thesansmonocd_w5regular_">browser.find_element(By.TAG_NAME, 'html')</span>を呼び出すのがよいです。例えば、ページの最下部までスクロールしたらコンテンツが読み込まれる場合に、この方法が使えます。</p>
<p class="tx">Seleniumにはここで紹介したよりもたくさんの機能があります。ブラウザのクッキーを操作したり、ウェブページのスクリーンショットを取得したり、任意のJavaScriptを実行したりできます。これらの機能につきましては、<i class="calibre5"><a href="https://selenium-python.readthedocs.io" class="calibre1">https://<wbr></wbr>selenium<wbr></wbr>-python<wbr></wbr>.readthedocs<wbr></wbr>.io</a></i>のSeleniumのドキュメントを参照してください。<i class="calibre5"><a href="https://pyvideo.org" class="calibre1">https://<wbr></wbr>pyvideo<wbr></wbr>.org</a></i>でSeleniumについてのPythonカンファレンストークを探すこともできます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec40">
<h3 class="h" id="calibre_link-1814"><span id="calibre_link-357"></span><span class="sans_futura_std_bold_b_">Playwrightでブラウザを制御する</span></h3>
<p class="tni">Playwrightは、Seleniumと似た、より新しいブラウザ制御ライブラリです。今のところはSeleniumほど広く使われてはいませんが、学習する価値のある機能を備えています。画面上に実際のブラウザウィンドウを開かずにブラウザをシミュレートする、<i class="calibre5">ヘッドレスモード</i>での実行がその一つです。バックグラウンドでウェブスクレイピングの自動作業を実行するときなどに使えます。Playwrightのドキュメントは<i class="calibre5"><a href="https://playwright.dev/python/docs/intro" class="calibre1">https://<wbr></wbr>playwright<wbr></wbr>.dev<wbr></wbr>/python<wbr></wbr>/docs<wbr></wbr>/intro</a></i>にあります。</p>
<p class="tx">Playwrightでは、Seleniumと比べて、個々のブラウザのウェブドライバをインストールするのが簡単です。Windowsでは<span class="sans_thesansmonocd_w7bold_b_">python -m playwright install</span>、macOSとLinuxでは<span class="sans_thesansmonocd_w7bold_b_">python3 –m playwright install</span>を、ターミナルウィンドウから実行すれば、Firefox、Chrome、Safariのウェブドライバをインストールできます。PlaywrightはSeleniumと似ていますから、この節ではウェブスクレイピングとCSSセレクタ一般については説明しません。</p>
<section type="division" aria-labelledby="sec41">
<h4 class="h1" id="calibre_link-1815"><span id="calibre_link-358"></span><span class="sans_futura_std_heavy_oblique_bi_">Playwrightで制御されたブラウザを立ち上げる</span></h4>
<p class="tni">Playwrightをインストールしたら、以下のプログラムを試してください。</p>
<pre class="pre"><code class="calibre9">from playwright.sync_api import sync_playwright
with sync_playwright() as playwright:
    browser = playwright.firefox.launch()
    page = browser.new_page()
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-985" aria-label="324"></span>    page.goto('https://autbor.com/example3.html')
    print(page.title())
    browser.close()
</code></pre>
<p class="tx">このプログラムを実行すると、Firefoxブラウザを立ち上げて<i class="calibre5"><a href="https://autbor.com/example3.html" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/example3<wbr></wbr>.html</a></i>のウェブサイトを読み込み、そのタイトル“Example Website.”を表示します。ブラウザにChromeを使うなら<span class="thesansmonocd_w5regular_">playwright.chromium.launch()</span>、Safariを使うなら<span class="thesansmonocd_w5regular_">playwright.webkit.launch()</span>とします。</p>
<p class="tx">Playwrightは、実行が<span class="thesansmonocd_w5regular_">with</span>文のブロックに入るときに<span class="thesansmonocd_w5regular_">start()</span>メソッドを、出るときに<span class="thesansmonocd_w5regular_">stop()</span>メソッドを、自動的に呼び出します。Playwrightには、操作が完了するまで関数が値を返さない同期モードがあります。このモードでは、ページの読み込みが終わる前に要素を見つけようとする事態を防げます。Playwrightの非同期機能は本書の範囲外です。</p>
<p class="tx">Playwrightは、デフォルトで、ヘッドレスモードで実行されるため、ブラウザウィンドウが現れません。ブラウザウィンドウが現れず、またPlaywrightでは<span class="thesansmonocd_w5regular_">with</span>文内にコードを書くために、デバッグがやりにくいです。Playwrightをステップごとに実行するには、対話型シェルに以下の内容を入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from playwright.sync_api import sync_playwright</b>
&gt;&gt;&gt; <b class="calibre10">playwright = sync_playwright().start()</b>
&gt;&gt;&gt; <b class="calibre10">browser = playwright.firefox.launch(headless=False, slow_mo=50)</b>
&gt;&gt;&gt; <b class="calibre10">page = browser.new_page()</b>
&gt;&gt;&gt; <b class="calibre10">page.goto('https://autbor.com/example3.html')</b>
&lt;Response url='https://autbor.com/example3.html' request=&lt;Request
 url='https://autbor.com/example3.html' method='GET'&gt;&gt;
&gt;&gt;&gt; <b class="calibre10">browser.close()</b>
&gt;&gt;&gt; <b class="calibre10">playwright.stop()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">playwright.firefox.launch()</span>のキーワード引数に<span class="thesansmonocd_w5regular_">headless=False</span>と<span class="thesansmonocd_w5regular_">slow_mo=50</span>を指定しています。これにより、ブラウザウィンドウが画面上に現れるようになり、何が起こっているのかを確かめやすくするために操作ごとに50ミリ秒遅延させます。ウェブページを読み込むための停止を考える必要はありません。Playwrightは、一つの操作が終わる前に次の操作に移らないという点で、Seleniumよりも優れています。</p>
<p class="tx">Browserメソッドの<span class="thesansmonocd_w5regular_">new_page()</span>が返す<span class="thesansmonocd_w5regular_">Page</span>オブジェクトは、新しいブラウザウィンドウの新しいタブを表しています。Playwrightでは複数のブラウザウィンドウを同時に開くことができます。</p>
</section>
<section type="division" aria-labelledby="sec42">
<h4 class="h1"><span id="calibre_link-1816"></span><span id="calibre_link-359"></span><span class="sans_futura_std_heavy_oblique_bi_">ブラウザのボタンをクリックする</span></h4>
<p class="tni">Playwrightでは、<span class="thesansmonocd_w5regular_">browser.new_page()</span>が返す<span class="thesansmonocd_w5regular_">Page</span>オブジェクトの以下の<span class="thesansmonocd_w5regular_">Page</span>メソッドで、ブラウザのボタンのクリックをシミュレートできます。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">page.go_back()</span> 戻るボタンのクリック</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">page.go_forward()</span> 進むボタンのクリック</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">page.reload()</span> 更新ボタンのクリック</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">page.close()</span> ウィンドウを閉じるボタンのクリック</p>
</section>
<section type="division" aria-labelledby="sec43">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-880" aria-label="325"></span>
<h4 class="h1"><span id="calibre_link-1817"></span><span id="calibre_link-360"></span><span class="sans_futura_std_heavy_oblique_bi_">ページの要素を見つける</span></h4>
<p class="tni">Playwrightには、俗に<i class="calibre5">ロケーター</i>と呼ばれる<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトを返す、<span class="thesansmonocd_w5regular_">Page</span>オブジェクトメソッドがあります。<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトはウェブページの「あり得る」HTML要素を表します。<i class="calibre5">「あり得る」</i>というのは、Seleniumでは要素が見つからなければすぐにエラーを送出するのに対し、Playwrightではページが要素をあとで動的に作成する可能性があることが考慮されるからです。これは役立ちますが、悪影響もあります。要素が存在しなければ、Playwrightは要素が現れるのを待って30秒停止します。</p>
<p class="tx">単に書き間違えただけの場合は、この30秒の停止はうっとうしいです。ページに要素が存在して見えているかどうかを即座にチェックするには、ロケーターが返す<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトの<span class="thesansmonocd_w5regular_">is_visible()</span>メソッドを呼び出します。<span class="thesansmonocd_w5regular_">page.query_selector('</span><span class="sans_thesansmonocd_w5regular_italic_">selector</span><span class="thesansmonocd_w5regular_">')</span>を呼び出すこともできます。<span class="sans_thesansmonocd_w5regular_italic_">selector</span>の部分には要素のCSSセレクタまたはXPathセレクタの文字列を指定します。<span class="thesansmonocd_w5regular_">page.query_selector()</span>メソッドは即座に値を返します。<span class="thesansmonocd_w5regular_">None</span>が返されたら、その時点で指定した要素がページに存在しないということです。<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトはウェブページの複数のHTML要素にマッチする可能性があります。表13-5にPlaywrightのロケーターをまとめました。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-753"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 13-5：</span></span><span class="sans_futura_std_book_">要素を見つけるためのPlaywrightのロケーター</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">ロケーター</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_thesansmonocd_w7bold_b_">返されるLocatorオブジェクト</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">page.get_by_role(</span><span class="sans_thesansmonocd_w5regular_italic_">role</span><span class="thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">name</span><span class="thesansmonocd_w5regular_">=</span><span class="sans_futura_std_book_oblique_i_">label</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">指定したroleの要素（オプションでlabelも指定可能）</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">page.get_by_text(</span><span class="sans_thesansmonocd_w5regular_italic_">text</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">要素内に指定したテキストを含む要素</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">page.get_by_label(</span><span class="sans_thesansmonocd_w5regular_italic_">label</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tb"><p class="tch1"> <span class="sans_thesansmonocd_w5regular_italic_">&lt;label&gt;</span><span class="sans_futura_std_book_">にテキストがマッチする要素</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">page.get_by_placeholder(</span><span class="sans_thesansmonocd_w5regular_italic_">text</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">プレースホルダーのテキストがマッチする</span><span class="thesansmonocd_w5regular_">&lt;input&gt;</span><span class="sans_futura_std_book_">と</span> <span class="thesansmonocd_w5regular_">&lt;textarea&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">page.get_by_alt_text(</span><span class="sans_thesansmonocd_w5regular_italic_">text</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">alt</span><span class="sans_futura_std_book_">属性の値がマッチする</span><span class="thesansmonocd_w5regular_">&lt;img&gt;</span><span class="sans_futura_std_book_">要素</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">page.locator(</span><span class="sans_thesansmonocd_w5regular_italic_">selector</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">CSSセレクタまたはXPathセレクタがマッチする要素</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span class="thesansmonocd_w5regular_">get_by_role()</span>メソッドは<i class="calibre5">ARIA（Accessible Rich Internet Applications）</i>を利用します。ARIAとは、視覚などの障がいを持つユーザーのために調整するために、ソフトウェアがウェブページのコンテンツを識別する一連の標準です。例えば、“heading”ロールは<span class="thesansmonocd_w5regular_">&lt;h1&gt;</span>から<span class="thesansmonocd_w5regular_">&lt;h6&gt;</span>のタグに適用され、<span class="thesansmonocd_w5regular_">&lt;h1&gt;</span>と<span class="thesansmonocd_w5regular_">&lt;/h1&gt;</span>で囲まれたテキストを<span class="thesansmonocd_w5regular_">get_by_role()</span>メソッドの<span class="thesansmonocd_w5regular_">name</span>キーワード引数で特定できます。（ARIAはこれだけにとどまりませんが、それを説明するのは本書の範囲を超えます。）</p>
<p class="tx">開始タグと終了タグの間のテキストにより要素を特定することもできます。<span class="thesansmonocd_w5regular_">page.get_by_text('is a link')</span>を呼び出すと、<span class="thesansmonocd_w5regular_">&lt;a href="https://inventwithpython.com”&gt;This text is a link&lt;/a&gt;</span><span class="thesansmonocd_w5regular_">&lt;a&gt;</span>要素を特定します。要素を特定するには、大文字と小文字を区別しない部分文字列でマッチさせれば十分であることが多いです。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">page.get_by_label()</span>メソッドは<span class="thesansmonocd_w5regular_">&lt;label&gt;</span>タグと<span class="thesansmonocd_w5regular_">&lt;/label&gt;</span>タグの間にあるテキストで要素を特定します。例えば、<span class="thesansmonocd_w5regular_">page.get_by_label('Agree')</span>は<span class="thesansmonocd_w5regular_">&lt;label&gt;Agree to disagree: &lt;input type="checkbox" /&gt;&lt;/label&gt;</span>の<span class="thesansmonocd_w5regular_">&lt;input&gt;</span>チェックボックス要素を特定します。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-897" aria-label="326"></span><span class="thesansmonocd_w5regular_">&lt;input&gt;</span>タグと<span class="thesansmonocd_w5regular_">&lt;textarea&gt;</span>タグには、ユーザーが実際のテキストを入力するまで表示されるプレースホルダーを表す<span class="thesansmonocd_w5regular_">placeholder</span>属性があります。例えば、<span class="thesansmonocd_w5regular_">page.get_by_placeholder('admin')</span>は<span class="thesansmonocd_w5regular_">&lt;input id="login_user" placeholder="admin" /&gt;</span>の<span class="thesansmonocd_w5regular_">&lt;input&gt;</span>要素を特定します。</p>
<p class="tx">ウェブページ上の画像には、目の不自由なユーザーのためなどに利用する、その画像について<span class="thesansmonocd_w5regular_">alt</span>属性に記述する代替テキストがあります。ブラウザによっては、マウスカーソルを画像にホバーすると、ツールチップで代替テキストが表示されます。<span class="thesansmonocd_w5regular_">page.get_by_alt_text('Zophie')</span>を呼び出すと、<span class="thesansmonocd_w5regular_">&lt;img src="wow_such_zophie_thumb.webp" alt="Close-up of my cat Zophie." /&gt;</span>の<span class="thesansmonocd_w5regular_">&lt;img&gt;</span> 要素が返されます。</p>
<p class="tx">CSSセレクタで<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトを取得するなら、<span class="thesansmonocd_w5regular_">locator()</span>を呼び出してセレクタ文字列を渡してください。これはSeleniumの<span class="thesansmonocd_w5regular_">find_elements()</span>メソッドで<span class="thesansmonocd_w5regular_">By.CSS_SELECTOR</span>定数を使うのと似ています。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-754"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 13-6：</span></span><span class="thesansmonocd_w5regular_">Locator</span><span class="sans_futura_std_book_">メソッド</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">メソッド</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">説明</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">get_attribute(</span><span class="sans_thesansmonocd_w5regular_italic_">name</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;a href="https://nostarch.com"&gt;</span>では<span class="thesansmonocd_w5regular_">href</span><span class="sans_futura_std_book_">属性の値</span><span class="thesansmonocd_w5regular_">'https://nostarch.com'</span><span class="sans_futura_std_book_">を返すように、その要素の指定した名前の属性の値を返す</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">count()</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">Locator</span><span class="sans_futura_std_book_">オブジェクトのマッチした要素数を返す</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">nth(</span><span class="sans_thesansmonocd_w5regular_italic_">index</span><span class="thesansmonocd_w5regular_">)</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">nth(3)</span><span class="sans_futura_std_book_">が4番目にマッチした要素を返すように、</span><span class="thesansmonocd_w5regular_">Locator</span><span class="sans_futura_std_book_">オブジェクトのマッチしたn番目の要素を返す（最初の要素は0番目）</p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">first</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">最初にマッチした</span><span class="thesansmonocd_w5regular_">Locator</span><span class="sans_futura_std_book_">オブジェクトを返す（</span><span class="thesansmonocd_w5regular_">nth(0)</span><span class="sans_futura_std_book_">と同じ）</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">last</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">最後にマッチした</span><span class="thesansmonocd_w5regular_">Locator</span><span class="sans_futura_std_book_">オブジェクトを返す（マッチした要素が5つなら</span><span class="thesansmonocd_w5regular_">nth(4)</span><span class="sans_futura_std_book_">と同じ）</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">all()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">個々のマッチした要素を含む</span><span class="thesansmonocd_w5regular_">Locator</span><span class="sans_futura_std_book_">オブジェクトのリストを返す</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">inner_text()</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;b&gt;hello&lt;/b&gt;</span>なら<span class="thesansmonocd_w5regular_">'hello'</span> </span><span class="sans_futura_std_book_">のように要素内のテキストを返す</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">inner_html()</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">&lt;b&gt;hello&lt;/b&gt;</span><span class="sans_futura_std_book_">なら</span><span class="thesansmonocd_w5regular_">'&lt;b&gt;hello&lt;/b&gt;'</span><span class="sans_futura_std_book_">のように要素内のHTMLソースを返す</span> </p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">click()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">リンク、チェックボックス、ボタンなどの要素で、その要素のクリックをシミュレートする</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">is_visible()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">要素が見える状態なら</span><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">を返し、見えない状態なら</span><span class="thesansmonocd_w5regular_">False</span><span class="sans_futura_std_book_">を返す</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">is_enabled()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">input要素が有効なら</span><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">を返し、無効なら</span><span class="thesansmonocd_w5regular_">False</span><span class="sans_futura_std_book_">を返す</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">is_checked()</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">チェックボックスやラジオボタンの要素で選択された状態なら</span><span class="thesansmonocd_w5regular_">True</span><span class="sans_futura_std_book_">を返し、選択されていない状態なら</span><span class="thesansmonocd_w5regular_">False</span><span class="sans_futura_std_book_">を返す</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">bounding_box()</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">ページ内でその要素の位置を表す</span><span class="thesansmonocd_w5regular_">'x'</span> <span class="sans_futura_std_book_">と</span> <span class="thesansmonocd_w5regular_">'y'</span><span class="sans_futura_std_book_">、その要素のサイズを表す</span> <span class="thesansmonocd_w5regular_">'width'</span><span class="sans_futura_std_book_">と</span><span class="thesansmonocd_w5regular_">'height'</span> <span class="sans_futura_std_book_">のキーを持つ辞書を返す</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span class="thesansmonocd_w5regular_">Locator</span>オブジェクトは複数の要素を表すことがありますから、ゼロ始まりの<span class="thesansmonocd_w5regular_">nth()</span>メソッドで個々の要素を表す<span class="thesansmonocd_w5regular_">Locator</span> オブジェクトを取得します。例えば、新しいファイルエディタのタブを開いて、次のプログラムを入力してください。</p>
<pre class="pre"><code class="calibre9">from playwright.sync_api import sync_playwright
with sync_playwright() as playwright:
    browser = playwright.firefox.launch(headless=False, slow_mo=50)
    page = browser.new_page()
    page.goto('https://autbor.com/example3.html')
    elems = page.locator('p')
    print(elems.nth(0).inner_text())
    print(elems.nth(0).inner_html())
</code></pre>
<p class="tx">Seleniumの例と同じように、このプログラムは以下のように出力します。</p>
<pre class="pre"><code class="calibre9">This &lt;p&gt; tag puts content into a single paragraph.
This &lt;p&gt; tag puts &lt;b&gt;content&lt;/b&gt; into a &lt;i&gt;single&lt;/i&gt; paragraph.
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">page.locator('p')</span>は、そのウェブページのすべての<span class="thesansmonocd_w5regular_">&lt;p&gt;</span>要素の<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトを返し、<span class="thesansmonocd_w5regular_">nth(0)</span>メソッド呼び出しで最初の<span class="thesansmonocd_w5regular_">&lt;p&gt;</span>要素の<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトだけを返すようにしています。<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトには、マッチした要素数を返す<span class="thesansmonocd_w5regular_">count()</span>メソッドがあります（Pythonのリストに対して<span class="thesansmonocd_w5regular_">len()</span>関数を適用するのと似ています）。マッチした最初の要素を含む<span class="thesansmonocd_w5regular_">first</span>属性と、最後の要素を含む<span class="thesansmonocd_w5regular_">last</span>属性もあります。マッチした要素についての<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトのリストがほしければ、<span class="thesansmonocd_w5regular_">all()</span>メソッドを呼び出します。</p>
<p class="tx">要素の<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトがあれば、以下の節で説明するように、マウスのクリックやキーの入力ができます。</p>
</section>
<section type="division" aria-labelledby="sec44">
<h4 class="h1"><span id="calibre_link-1818"></span><span id="calibre_link-361"></span><span class="sans_futura_std_heavy_oblique_bi_">ページの要素をクリックする</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Page</span>オブジェクトには、リンクやボタンやチェックボックス要素をクリックする、<span class="thesansmonocd_w5regular_">click()</span>、<span class="thesansmonocd_w5regular_">check()</span>、<span class="thesansmonocd_w5regular_">uncheck()</span>、<span class="thesansmonocd_w5regular_">set_checked()</span>メソッドがあります。これらのメソッドに要素のCSSセレクタまたはXPathセレクタを渡して呼び出すこともできますし、表13-6にまとめたPlaywrightの<span class="thesansmonocd_w5regular_">Locator</span>メソッドを使うこともできます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from playwright.sync_api import sync_playwright</b>
&gt;&gt;&gt; <b class="calibre10">playwright = sync_playwright().start()</b>
&gt;&gt;&gt; <b class="calibre10">browser = playwright.firefox.launch(headless=False, slow_mo=50)</b>
&gt;&gt;&gt; <b class="calibre10">page = browser.new_page()</b>
&gt;&gt;&gt; <b class="calibre10">page.goto('https://autbor.com/example3.html')</b>
&lt;Response url='https://autbor.com/example3.html' request=&lt;Request
 url='https://autbor.com/example3.html' method='GET'&gt;&gt;
&gt;&gt;&gt; <b class="calibre10">page.click('input[type=checkbox]')</b>  # チェックボックスのチェック
&gt;&gt;&gt; <b class="calibre10">page.click('input[type=checkbox]')</b>  # チェックボックスのチェックを外す
&gt;&gt;&gt; <b class="calibre10">page.click('a')</b>  # リンクをクリック
&gt;&gt;&gt; <b class="calibre10">page.go_back()</b>
&gt;&gt;&gt; <b class="calibre10">checkbox_elem = page.get_by_role('checkbox')</b>  # Locatorメソッドの呼び出し
&gt;&gt;&gt; <b class="calibre10">checkbox_elem.check()</b>  # チェックボックスのチェック
&gt;&gt;&gt; <b class="calibre10">checkbox_elem.uncheck()</b>  # チェックボックスのチェックを外す
&gt;&gt;&gt; <b class="calibre10">checkbox_elem.set_checked(True)</b>  # チェックボックスのチェック
&gt;&gt;&gt; <b class="calibre10">checkbox_elem.set_checked(False)</b>  # チェックボックスのチェックを外す
&gt;&gt;&gt; <b class="calibre10">page.get_by_text('is a link').click()</b>  # Locatorメソッドを使う
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1161" aria-label="328"></span>&gt;&gt;&gt; <b class="calibre10">browser.close()</b>
&gt;&gt;&gt; <b class="calibre10">playwright.stop()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">check()</span>メソッドと<span class="thesansmonocd_w5regular_">uncheck()</span>メソッドは、チェックボックスに対して<span class="thesansmonocd_w5regular_">click()</span>を呼び出すよりも信頼性が高いです。<span class="thesansmonocd_w5regular_">click()</span>メソッドはチェックボックスを反対の状態にトグルしますが、<span class="thesansmonocd_w5regular_">check()</span>と<span class="thesansmonocd_w5regular_">uncheck()</span>は現在の状態が何であれ指定した状態にします。<span class="thesansmonocd_w5regular_">set_checked()</span>メソッドに<span class="thesansmonocd_w5regular_">True</span> または<span class="thesansmonocd_w5regular_">False</span>を渡して呼び出しても同じです。</p>
</section>
<section type="division" aria-labelledby="sec45">
<h4 class="h1"><span id="calibre_link-1819"></span><span id="calibre_link-362"></span><span class="sans_futura_std_heavy_oblique_bi_">フォームに入力して送信する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Locator</span>オブジェクトには、文字列を取りそのテキストで<span class="thesansmonocd_w5regular_">&lt;input&gt;</span>要素または<span class="thesansmonocd_w5regular_">&lt;textarea&gt;</span>要素を埋める<span class="thesansmonocd_w5regular_">fill()</span>メソッドがあります。<i class="calibre5">example3.html</i>ウェブページのログインフォームのようなオンラインフォームに入力するのに便利です。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from playwright.sync_api import sync_playwright</b>
&gt;&gt;&gt; <b class="calibre10">playwright = sync_playwright().start()</b>
&gt;&gt;&gt; <b class="calibre10">browser = playwright.firefox.launch(headless=False, slow_mo=50)</b>
&gt;&gt;&gt; <b class="calibre10">page = browser.new_page()</b>
&gt;&gt;&gt; <b class="calibre10">page.goto('https://autbor.com/example3.html')</b>
&lt;Response url='https://autbor.com/example3.html' request=&lt;Request
url='https://autbor.com/example3.html' method='GET'&gt;&gt;
&gt;&gt;&gt; <b class="calibre10">page.locator('#login_user').fill('</b><b class="calibre10"><var class="calibre20">your_real_username_here</var></b><b class="calibre10">')</b>
&gt;&gt;&gt; <b class="calibre10">page.locator('#login_pass').fill('</b><b class="calibre10"><var class="calibre20">your_real_password_here</var></b><b class="calibre10">')</b>
&gt;&gt;&gt; <b class="calibre10">page.locator('input[type=submit]').click()</b>
&gt;&gt;&gt; <b class="calibre10">browser.close()</b>
&gt;&gt;&gt; <b class="calibre10">playwright.stop()</b>
</code></pre>
<p class="tx">現在要素に入力されているテキストをすべて消去する<span class="thesansmonocd_w5regular_">clear()</span>メソッドもあります。Seleniumとは異なり、Playwrightには<span class="thesansmonocd_w5regular_">submit()</span>メソッドがありません。よって、送信ボタンの要素にマッチする<span class="thesansmonocd_w5regular_">Locator</span>オブジェクトについて<span class="thesansmonocd_w5regular_">click()</span>を呼び出す必要があります。</p>
</section>
<section type="division" aria-labelledby="sec46">
<h4 class="h1"><span id="calibre_link-1820"></span><span id="calibre_link-363"></span><span class="sans_futura_std_heavy_oblique_bi_">特別なキーを入力する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Locator</span>オブジェクトの<span class="thesansmonocd_w5regular_">press()</span>メソッドでウェブページの要素にキー入力をシミュレートできます。例えば、現在カーソルがテキストフィールドにないとして、<small class="calibre4">HOME</small>キーを押せばページの最上部に、<small class="calibre4">END</small>キーを押せばページの最下部に、ブラウザがスクロールします。以下の内容を対話型シェルに入力して、<span class="thesansmonocd_w5regular_">press()</span>呼び出しがページをスクロールさせる様子を確認してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from playwright.sync_api import sync_playwright</b>
&gt;&gt;&gt; <b class="calibre10">playwright = sync_playwright().start()</b>
&gt;&gt;&gt; <b class="calibre10">browser = playwright.firefox.launch(headless=False, slow_mo=50)</b>
&gt;&gt;&gt; <b class="calibre10">page = browser.new_page()</b>
&gt;&gt;&gt; <b class="calibre10">page.goto('https://autbor.com/example3.html')</b>
&lt;Response url='https://autbor.com/example3.html' request=&lt;Request
url='https://autbor.com/example3.html' method='GET'&gt;&gt;
&gt;&gt;&gt; <b class="calibre10">page.locator('html').press('End')  </b># 最下部にスクロール
&gt;&gt;&gt; <b class="calibre10">page.locator('html').press('Home')  </b># 最上部ににスクロール
&gt;&gt;&gt; <b class="calibre10">browser.close()</b>
&gt;&gt;&gt; <b class="calibre10">playwright.stop()</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1821" aria-label="329"></span><span class="thesansmonocd_w5regular_">press()</span>には、<span class="thesansmonocd_w5regular_">'a'</span>や<span class="thesansmonocd_w5regular_">'?'</span>のような文字列を渡せますし、<span class="thesansmonocd_w5regular_">'Shift'</span>、<span class="thesansmonocd_w5regular_">'Control'</span>、<span class="thesansmonocd_w5regular_">'Alt'</span>、<span class="thesansmonocd_w5regular_">'Meta'</span>、<span class="thesansmonocd_w5regular_">'Control+A'</span>や以下の特別なキーの文字列も渡せます。</p>
<pre class="pre1"><code class="calibre9">'Backquote'    'Escape'    'ArrowDown'
'Minus'     'End'       'ArrowRight'
'Equal'     'Enter'     'ArrowUp'
'Backslash' 'Home'      'F1' to 'F12'
'Backspace' 'Insert'    'Digit0' to 'Digit9'
'Tab'       'PageUp'    'KeyA' to 'KeyZ'
'Delete'    'PageDown'  
</code></pre>
<p class="tx">Playwrightにはここで紹介したよりもたくさんの機能があります。詳しくは<i class="calibre5"><a href="https://playwright.dev" class="calibre1">https://<wbr></wbr>playwright<wbr></wbr>.dev</a></i>のPlaywrightのドキュメントを参照してください。<i class="calibre5"><a href="https://pyvideo.org" class="calibre1">https://<wbr></wbr>pyvideo<wbr></wbr>.org</a></i>でPlaywrightについてのPythonカンファレンストークを探すこともできます。</p>
</section>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec47">
<h3 class="h" id="calibre_link-1822"><span id="calibre_link-364"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">退屈な作業は自分のコンピュータ上のファイルに限られません。プログラム的にウェブページをダウンロードできると、プログラムをインターネットに拡張できます。<span class="thesansmonocd_w5regular_">requests</span>モジュールを使うとダウンロードを簡単にできますし、HTMLの概念やセレクタの基本知識があれば、ダウンロードしたページを<span class="thesansmonocd_w5regular_">BeautifulSoup</span>モジュールで解析できます。</p>
<p class="tx">しかしウェブベースの作業を完全に自動化するには、SeleniumパッケージやPlaywrightパッケージを通じてウェブブラウザを直接制御する必要があります。これらのパッケージを使うと、ウェブサイトにログインしてフォームを自動的に埋められます。ウェブブラウザはインターネットで情報をやり取りする最も一般的な方法ですから、これはプログラマの道具の中でも大きな力になります。</p>
</section>
<section type="division" aria-labelledby="sec48">
<h3 class="h" id="calibre_link-1823"><span id="calibre_link-365"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. <span class="thesansmonocd_w5regular_">webbrowser</span>モジュールと<span class="thesansmonocd_w5regular_">requests</span>モジュールと<span class="thesansmonocd_w5regular_">bs4</span>モジュールの違いを簡単に説明してください。</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">requests.get()</span>が返すのはどのような型のオブジェクトですか？　ダウンロードしたコンテンツに文字列値としてアクセスするにはどうすればよいですか？</p>
<p class="listnumber">  3. ダウンロードが成功したかどうかを判定する<span class="thesansmonocd_w5regular_">requests</span>メソッドは何ですか？</p>
<p class="listnumber">  4. <span class="thesansmonocd_w5regular_">requests</span>レスポンスのステータスコードを取得する方法を教えてください。</p>
<p class="listnumber">  5. <span class="thesansmonocd_w5regular_">requests</span>レスポンスをファイルに保存する方法を教えてください。</p>
<p class="listnumber">  6. オンラインAPIがレスポンスで返す代表的な2つのフォーマットは何ですか？</p>
<p class="listnumber">  7. ブラウザのデベロッパーツールを開くキーボードショートカットは何ですか？</p>
<p class="listnumber">  8. （デベロッパーツールで）ウェブページ上の特定の要素のHTMLを確認するにはどうすればよいですか？</p>
<p class="listnumber">  9. <span class="thesansmonocd_w5regular_">id</span>属性の値が<span class="thesansmonocd_w5regular_">main</span>である要素を見つけるCSSセレクタを記述してください。</p>
<p class="listnumber"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1192" aria-label="330"></span>10. <span class="thesansmonocd_w5regular_">class</span>属性の値が<span class="thesansmonocd_w5regular_">highlight</span>である要素を見つけるCSSセレクタを記述してください。</p>
<p class="listnumber">11. 変数<span class="thesansmonocd_w5regular_">spam</span>に要素<span class="thesansmonocd_w5regular_">&lt;div&gt;Hello, world!&lt;/div&gt;</span>のBeautiful Soupの<span class="thesansmonocd_w5regular_">Tag</span>オブジェクトを格納しているとします。その<span class="thesansmonocd_w5regular_">Tag</span>オブジェクトから<span class="thesansmonocd_w5regular_">'Hello, world!'</span>という文字列をどのように取得しますか？</p>
<p class="listnumber">12. <span class="thesansmonocd_w5regular_">link_elem</span>という名前の変数にBeautiful Soupの<span class="thesansmonocd_w5regular_">Tag</span>オブジェクトのすべての属性を格納するにはどうしますか？</p>
<p class="listnumber">13. <span class="thesansmonocd_w5regular_">import selenium</span>を実行してもうまくいきませんでした。Seleniumをインポートする正しい方法を教えてください。</p>
<p class="listnumber">14. Seleniumの<span class="thesansmonocd_w5regular_">find_element()</span>メソッドと<span class="thesansmonocd_w5regular_">find_elements()</span>メソッドの違いは何ですか？</p>
<p class="listnumber">15. マウスのクリックやキーボードの入力をシミュレートする、Seleniumの<span class="thesansmonocd_w5regular_">WebElement</span>オブジェクトのメソッドは何ですか？</p>
<p class="listnumber">16. Playwrightで、ページのすべてのテキストを選択するために<small class="calibre4">CTRL</small>-A を押すのをシミュレートするロケーターメソッド呼び出しは何ですか？</p>
<p class="listnumber">17. Seleniumでブラウザの進む、戻る、更新ボタンをシミュレートする方法を教えてください。</p>
<p class="listnumber">18. Playwrightでブラウザの進む、戻る、更新ボタンをシミュレートする方法を教えてください。</p>
</section>
<section type="division" aria-labelledby="sec49">
<h3 class="h" id="calibre_link-1824"><span id="calibre_link-366"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec50">
<h4 class="h1" id="calibre_link-1825"><span id="calibre_link-367"></span><span class="sans_futura_std_heavy_oblique_bi_">画像サイトダウンローダー</span></h4>
<p class="tni">FlickrやImgurのような写真共有サイトに移動し、検索結果の画像をすべてダウンロードするプログラムを書いてください。検索機能のある写真サイトならどこでも機能するプログラムを書けます。</p>
</section>
<section type="division" aria-labelledby="sec51">
<h4 class="h1" id="calibre_link-1826"><span id="calibre_link-368"></span><span class="sans_futura_std_heavy_oblique_bi_">2048</span></h4>
<p class="tni">2048は、矢印キーでタイルを上下左右にスライドさせるシンプルなゲームです。ランダムな方向にタイルをスライドさせても高得点になることがあります。<i class="calibre5"><a href="https://play2048.co" class="calibre1">https://<wbr></wbr>play2048<wbr></wbr>.co</a></i>でそのゲームを開き、上下左右のキー入力を送って自動的にゲームをプレイするプログラムを書いてください。</p>
</section>
<section type="division" aria-labelledby="sec52">
<h4 class="h1" id="calibre_link-1827"><span id="calibre_link-369"></span><span class="sans_futura_std_heavy_oblique_bi_">リンクの検証</span></h4>
<p class="tni">ウェブページのURLを与えると、そのページのすべての<span class="thesansmonocd_w5regular_">&lt;a&gt;</span>リンクを見つけて、そのリンク先のURLが“404 Not Found”ステータスコードになるかを確認するプログラムを書いてください。壊れているリンクを出力してください。</p>
<ol class="footnotes">
<li class="calibre22"><p class="fn"><span class="epub-sup"><a id="calibre_link-742" href="chapter13.html#calibre_link-755" class="calibre1">1</a></span>答えはノーです。</p></li>
</ol>
</section>
</section>
</section>
</div>



</div>



</body></html>