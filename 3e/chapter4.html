<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-74">
<section type="chapter" role="doc-chapter" aria-labelledby="ch4">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1170" aria-label="73"></span>
<hgroup>
<h2 class="title" id="calibre_link-1480">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">4</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">関数</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni"><i class="calibre18">関数</i>は、プログラム内のミニプログラムのようなものです。
Pythonには、前章までに紹介した<span class="sans_thesansmonocd_w5regular_">print()</span>関数、<span class="sans_thesansmonocd_w5regular_">input()</span>関数、<span class="sans_thesansmonocd_w5regular_">len()</span> 関数のような組み込み関数がありますが、自分で関数を作ることもできます。本章では、関数を作成し、ブログラム内で関数の実行順を決める呼び出しスタックを調べ、関数内外での変数のスコープについて説明します。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1481"><span id="calibre_link-75"></span><span class="sans_futura_std_bold_b_">関数の作成</span></h3>
<p class="tni">関数の働きを理解するために一つ作ってみましょう。次のコードを<i class="calibre5">helloFunc.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def hello():
    # 3つのあいさつを表示
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1101" aria-label="74"></span>    print('Good morning!')
    print('Good afternoon!')
    print('Good evening!')

hello()
hello()
print('ONE MORE TIME!')
hello()
</code></pre>
<p class="tx">1行目は<span class="thesansmonocd_w5regular_">def</span>文です。<span class="thesansmonocd_w5regular_">hello()</span>という名前の関数を定義しています。<span class="thesansmonocd_w5regular_">def</span>文に続くブロックのコードは関数の本体です。関数が呼び出されたときにこのコードが実行されます。関数の定義時に実行されるのではありません。</p>
<p class="tx">関数を定義したあとの<span class="thesansmonocd_w5regular_">hello()</span>の行が関数の呼び出しです。関数名のあとにかっこをつけて関数を呼び出します。かっこ内に引数があることもあります。プログラム実行が関数呼び出しにたどり着くと、関数本体の最初の行からコードを実行し始めます。関数本体の最後まで実行すると、関数が呼び出された行に戻り、そこからコードの実行を続けます。</p>
<p class="tx">このプログラムでは <span class="thesansmonocd_w5regular_">hello()</span>を3回呼び出していますから、<span class="thesansmonocd_w5regular_">hello()</span>関数が3回実行されます。このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">Good morning!
Good afternoon!
Good evening!
Good morning!
Good afternoon!
Good evening!
ONE MORE TIME!
Good morning!
Good afternoon!
Good evening!
</code></pre>
<p class="tx">関数を作る主な目的は、何回も実行されるコードをまとめることです。関数を作らなければ、次のようにその都度コピーアンドペーストすることになります。</p>
<pre class="pre"><code class="calibre9">print('Good morning!')
print('Good afternoon!')
print('Good evening!')
print('Good morning!')
print('Good afternoon!')
print('Good evening!')
print('ONE MORE TIME!')
print('Good morning!')
print('Good afternoon!')
print(' Good evening!')
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-925" aria-label="75"></span>一般に、コードをコピーアンドペーストすることは避けたほうがよいです。バグを発見したなどの理由でコードを更新するときに、コピーしたコードを全部更新するのは大変だからです。</p>
<p class="tx">プログラミングの経験を積むと、<i class="calibre5">重複排除</i>コードを書くようになります。コードのコピーアンドペーストをしないということです。重複を避けると、プログラムが短くなり、読みやすくて更新しやすくなります。</p>
</section>
<section type="division" aria-labelledby="sec2">
<h3 class="h" id="calibre_link-1482"><span id="calibre_link-76"></span><span class="sans_futura_std_bold_b_">引数とパラメータ（仮引数）</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">print()</span>関数や<span class="thesansmonocd_w5regular_">len()</span>関数を呼び出すときに、かっこ内に<i class="calibre5">引数</i>と呼ばれる値を渡すことがあります。それと同じように引数を取る関数を定義できます。次のコードを<i class="calibre5">helloFunc2.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> def say_hello_to(name):
    # 与えられた名前に対して3つのあいさつを表示
  <span class="code_codeannotation" aria-label="annotation2">❷</span> print('Good morning, ' + name)
    print('Good afternoon, ' + name)
    print('Good evening, ' + name)

<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> say_hello_to('Alice')
say_hello_to('Bob')
</code></pre>
<p class="tx">このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">Good morning, Alice
Good afternoon, Alice
Good evening, Alice
Good morning, Bob
Good afternoon, Bob
Good evening, Bob
</code></pre>
<p class="tx">このプログラムでの<span class="thesansmonocd_w5regular_">say_hello_to()</span>関数の定義には、<span class="thesansmonocd_w5regular_">name</span>というパラメータ（仮引数）があります（<span class="codeannotation" aria-label="annotation1">➊</span>）。<i class="calibre5">パラメータ</i>とは、引数（真引数）を受け取る変数のことです。引数を渡して関数を呼び出したときに、パラメータが引数を受け取ります。<span class="thesansmonocd_w5regular_">say_hello_to()</span> 関数の1回目の呼び出しでは、<span class="thesansmonocd_w5regular_">'Alice'</span>という引数が渡されています（<span class="codeannotation" aria-label="annotation3">➌</span>）。プログラム実行は関数を実行し、パラメータ<span class="thesansmonocd_w5regular_">name</span>に<span class="thesansmonocd_w5regular_">'Alice'</span>という引数が設定されます。そして、その引数とあいさつが<span class="thesansmonocd_w5regular_">print()</span>文で表示されます（<span class="codeannotation" aria-label="annotation2">➋</span>）。関数呼び出しに渡した値に応じて微妙に異なる命令を実行したい場合には、関数内でパラメータを使います</p>
<p class="tx">パラメータに格納される値は関数の呼び出しが終わると失われます。例えば、先のプログラムで<span class="thesansmonocd_w5regular_">say_hello_to('Bob')</span> のあとに<span class="thesansmonocd_w5regular_">print(name)</span>を書き加えても、エラーになります。変数<span class="thesansmonocd_w5regular_">name</span>に値が入っていないからです。<span class="thesansmonocd_w5regular_">say_hello_to('Bob')</span>の呼び出し後にパラメータの変数は破棄されるので、<span class="thesansmonocd_w5regular_">print(name)</span>に使われている変数<span class="thesansmonocd_w5regular_">name</span>は存在しないのです。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1100" aria-label="76"></span><i class="calibre5">定義する</i>、<i class="calibre5">呼び出す</i>、<i class="calibre5">渡す</i>、<i class="calibre5">引数</i>、<i class="calibre5">パラメータ</i>という用語は混乱しがちです。これらの用語をおさらいするためにコード例を見てみましょう。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> def say_hello_to(name):
    # 与えられた名前に対して3つのあいさつを表示
    print('Good morning, ' + name)
    print('Good afternoon, ' + name)
    print('Good evening, ' + name)
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> say_hello_to('Al')
</code></pre>
<p class="tx">関数を<i class="calibre5">定義する</i>ということは関数を作ることです。 <span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">42</span> のような文で変数<span class="thesansmonocd_w5regular_">spam</span>を作るのと同じです。<span class="thesansmonocd_w5regular_">def</span>文で<span class="thesansmonocd_w5regular_">say_hello_to()</span>関数を定義しています（<span class="codeannotation" aria-label="annotation1">➊</span>）。<span class="thesansmonocd_w5regular_">say_hello_to('Al')</span>の行は、先ほど作った関数を<i class="calibre5">呼び出し</i>、 関数のコードを実行します（<span class="codeannotation" aria-label="annotation2">➋</span>）。この関数呼び出しでは、<span class="thesansmonocd_w5regular_">'Al'</span>という文字列値を関数に<i class="calibre5">渡し</i>ています。呼び出し時に関数に渡される値は<i class="calibre5">引数</i>です。引数<i class="calibre5">'Al'</i>がローカル変数に割り当てられます。引数<span class="thesansmonocd_w5regular_">'Al'</span>が割り当てられる変数は<span class="thesansmonocd_w5regular_">パラメータ</span>です。</p>
<p class="tx">これらの用語を混同しがちですが、ここで正しく理解しておくと、この章の内容を正確に把握できるようになります。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h3 class="h" id="calibre_link-1483"><span id="calibre_link-77"></span><span class="sans_futura_std_bold_b_">返り値とreturn文</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">'Hello'</span>のような引数を渡して<span class="thesansmonocd_w5regular_">len()</span>関数を呼び出すと、その文字数である<span class="thesansmonocd_w5regular_">5</span>のような整数に評価されます。一般化して言うと、関数呼び出しにより評価される値を、関数の<i class="calibre5">返り値（戻り値）</i>と呼びます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">def</span>文により自分で関数を作るときに、<span class="thesansmonocd_w5regular_">return</span>文で返り値を指定できます。次のような形になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">return</span>というキーワード</li>
<li class="bl">関数が返す値または式</li>
</ul>
<p class="tx">式を使うと、その式が評価する値が返り値になります。例えば、次のプログラムは、渡された引数の数字によって別々の文字列を返す関数を定義しています。次のコードを<i class="calibre5">magic8Ball.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> import random

<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> def get_answer(answer_number):
    # answer_numberの値1から9に応じて答えを返す
  <span class="code_codeannotation" aria-label="annotation3">❸</span> if answer_number == 1:
        return 'It is certain'
    elif answer_number == 2:
        return 'It is decidedly so'
    elif answer_number == 3:
        return 'Yes'
    elif answer_number == 4:
        return 'Reply hazy try again'
    elif answer_number == 5:
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1247" aria-label="77"></span>        return 'Ask again later'
    elif answer_number == 6:
        return 'Concentrate and ask again'
    elif answer_number == 7:
        return 'My reply is no'
    elif answer_number == 8:
        return 'Outlook not so good'
    elif answer_number == 9:
        return 'Very doubtful'

print('Ask a yes or no question:')
input('&gt;')
<span class="codeannotated_codeannotation" aria-label="annotation4">❹</span> r = random.randint(1, 9)
<span class="codeannotated_codeannotation" aria-label="annotation5">❺</span> fortune = get_answer(r)
<span class="codeannotated_codeannotation" aria-label="annotation6">❻</span> print(fortune)
</code></pre>
<p class="tx">最初に<span class="thesansmonocd_w5regular_">random</span>モジュールをインポートしています（<span class="codeannotation" aria-label="annotation1">➊</span>）。次に<span class="thesansmonocd_w5regular_">get_answer()</span>関数を定義しています（<span class="codeannotation" aria-label="annotation2">➋</span>）。関数の呼び出しではなく定義ですから、この時点でコードが実行されるわけではありません。次に、<span class="thesansmonocd_w5regular_">1</span>と<span class="thesansmonocd_w5regular_">9</span>という2つの引数を渡して<span class="thesansmonocd_w5regular_">random.randint()</span>関数を呼び出します（<span class="codeannotation" aria-label="annotation4">➍</span>）。<span class="thesansmonocd_w5regular_">1</span>から<span class="thesansmonocd_w5regular_">9</span>までの整数（<span class="thesansmonocd_w5regular_">1</span>と<span class="thesansmonocd_w5regular_">9</span>を含む）に評価され、変数<span class="thesansmonocd_w5regular_">r</span>に格納されます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">r</span>を引数として<span class="thesansmonocd_w5regular_">get_answer()</span>関数を呼び出します（<span class="codeannotation" aria-label="annotation5">➎</span>）。プログラム実行はこの関数の最初に移動し、<span class="thesansmonocd_w5regular_">r</span>の値がパラメータ<span class="thesansmonocd_w5regular_">answer_number</span>に格納されます（<span class="codeannotation" aria-label="annotation3">➌</span>）。この関数は、<span class="thesansmonocd_w5regular_">answer_number</span>の値に応じて文字列を返します。プログラム実行は<span class="thesansmonocd_w5regular_">get_answer()</span>を呼び出した行に戻ります（<span class="codeannotation" aria-label="annotation5">➎</span>）。変数<span class="thesansmonocd_w5regular_">fortune</span>に返り値が代入され、<span class="thesansmonocd_w5regular_">print()</span>の呼び出しに渡され、画面に表示されます（<span class="codeannotation" aria-label="annotation6">➏</span>）。</p>
<p class="tx">返り値を別の関数呼び出しの引数として渡すことができますから、次の3行を縮めて書くことができます。</p>
<pre class="pre"><code class="calibre9">r = random.randint(1, 9)
fortune = get_answer(r)
print(fortune)
</code></pre>
<p class="tni">この3行は次の1行と同じです。</p>
<pre class="pre"><code class="calibre9">print(get_answer(random.randint(1, 9)))</code></pre>
<p class="tx">式は値と演算子から成り立っていることを思い出してください。関数呼び出しは返り値に評価されますから、式中で使うことができます。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h3 class="h" id="calibre_link-1484"><span id="calibre_link-78"></span><span class="sans_futura_std_bold_b_">None値</span></h3>
<p class="tni">Pythonには<span class="thesansmonocd_w5regular_">None</span>値という値が存在します。値がないことを表します。<span class="thesansmonocd_w5regular_">None</span>値は<span class="thesansmonocd_w5regular_">NoneType</span>データ型の唯一の値です。（値がないことを表す値として、ほかのプログラミング言語では、<span class="thesansmonocd_w5regular_">null</span>、<span class="thesansmonocd_w5regular_">nil</span>、<span class="thesansmonocd_w5regular_">undefined</span>という値があったりします。）ブール値の<span class="thesansmonocd_w5regular_">True</span>と<span class="thesansmonocd_w5regular_">False</span>と同じように、<span class="thesansmonocd_w5regular_">None</span>は大文字の<i class="calibre5">N</i>で始めます。</p>
<p class="tx">値がないことを表すこの値は、変数に何らかの値を格納しなければならないのだけれども実際的な値を格納したくないときに便利です。<span class="thesansmonocd_w5regular_">print()</span>の返り値は<span class="thesansmonocd_w5regular_">None</span>です。<span class="thesansmonocd_w5regular_">print()</span>関数は画面にテキストを表示しますが、<span class="thesansmonocd_w5regular_">len()</span>関数や<span class="thesansmonocd_w5regular_">input()</span>関数のように返り値は必要ありません。しかし、関数はすべて値を返さなければならないので、<span class="thesansmonocd_w5regular_">print()</span>関数は<span class="thesansmonocd_w5regular_">None</span>を返します。これを確認するために、次のコードを対話型シェルに入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = print('Hello!')</b>
Hello!
&gt;&gt;&gt; <b class="calibre10">None == spam</b>
True
</code></pre>
<p class="tx">Pythonは、明示的な<span class="thesansmonocd_w5regular_">return</span>文がなくても、関数の定義の最後に<span class="thesansmonocd_w5regular_">return None</span>を付け加えます。<span class="thesansmonocd_w5regular_">while</span>や<span class="thesansmonocd_w5regular_">for</span>のループで最後に到達すると<span class="thesansmonocd_w5regular_">continue</span>文が書かれていなくても最初に戻るのと似ています。また、<span class="thesansmonocd_w5regular_">return</span>文を値なしで使うと（<span class="thesansmonocd_w5regular_">return</span>というキーワードだけを書くと）、<span class="thesansmonocd_w5regular_">None</span>が返されます。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h3 class="h" id="calibre_link-1485"><span id="calibre_link-79"></span><span class="sans_futura_std_bold_b_">名前付きパラメータ</span></h3>
<p class="tni">Pythonの関数呼び出しでは、引数を位置によって特定することが多いです。例えば、<span class="thesansmonocd_w5regular_">random.randint(1, 10)</span>は<span class="thesansmonocd_w5regular_">random.randint(10, 1)</span>とは異なります。前者は<span class="thesansmonocd_w5regular_">1</span>から<span class="thesansmonocd_w5regular_">10</span>までの整数をランダムに返します。第一引数が範囲の始まりで第二引数が範囲の終わりです。後者はエラーになります。</p>
<p class="tx">位置引数とは異なり、<i class="calibre5">名前付きパラメータ</i>は、関数の呼び出し時の引数の前の名前によって特定されます。名前付きパラメータは、キーワードパラメータやキーワード引数と呼ばれることもありますが、Pythonのキーワードとは関係ありません。名前付きパラメータはオプションの引数として使われることが多いです。例えば、<span class="thesansmonocd_w5regular_">print()</span>関数には<span class="thesansmonocd_w5regular_">end</span>と<span class="thesansmonocd_w5regular_">sep</span>というオプションのパラメータがあります。それぞれ、出力の終わりをどうするか、引数の間（区切り）をどうするかを指定するパラメータです。次のコードを実行するとします。</p>
<pre class="pre"><code class="calibre9">print('Hello')
print('World')
</code></pre>
<p class="tni">出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">Hello
World
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">print()</span>関数は自動的に改行文字を追加するので、2つの出力が別々の行に現れます。<span class="thesansmonocd_w5regular_">end</span>名前付きパラメータを設定すると、改行文字から変更できます。例えば、次のコードを実行するとします。</p>
<pre class="pre"><code class="calibre9">print('Hello', end='')
print('World')
</code></pre>
<p class="tni">出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">HelloWorld</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">'Hello'</span>のあとに改行がなくなるので、一行で出力されます。改行文字の代わりに空文字列が出力されています。<span class="thesansmonocd_w5regular_">print()</span>関数を呼び出すたびに付け加えられる改行を無効にできます。コイン投げの結果を表示したいとします。 <i class="calibre5">coinflip.py</i>プログラムのように、出力を1行で表示したほうが見やすいです。</p>
<pre class="pre"><code class="calibre9">import random
for i in range(100):  # コイン投げを100回実行
    if random.randint(0, 1) == 0:
        print('H', end=' ')
    else:
        print('T', end=' ')
print()  # 最後に1つ改行
</code></pre>
<p class="tx">このプログラムを実行すると、H（head、表）とT（Tail、裏）の結果が1行でコンパクトに表示されます。1行に1回の結果を表示するよりも見やすいです。</p>
<pre class="pre"><code class="calibre9">T H T T T H H T T T T H H H H T H H T T T T T H T T T T T H T T T T T H T H T
H H H T T H T T T T H T H H H T H H T H T T T T T H T T H T T T T H T H H H T
T T T H T T T T H H H T H T H H H H T H H T
</code></pre>
<p class="tx">また、<span class="thesansmonocd_w5regular_">print()</span>関数に複数の文字列を渡すと、自動的に半角スペースで区切られます。それを確かめるために、以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">print('cats', 'dogs', 'mice')</b>
cats dogs mice
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">sep</span>名前付きパラメータに区切り文字を渡すと、そのデフォルトの挙動を変更できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">print('cats', 'dogs', 'mice', sep=',')</b>
cats,dogs,mice
</code></pre>
<p class="tx">自分で作る関数にキーワード引数を設けることもできます。しかしその前に<span>第6章</span>と<span>第7章</span>でリストと辞書のデータ型を学ぶ必要があります。今のところは、関数の呼び出し時にオプションのキーワード引数を渡せる関数があるということを知っておいてください。</p>
</section>
<section type="division" aria-labelledby="sec6">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-994" aria-label="80"></span>
<h3 class="h" id="calibre_link-1486"><span id="calibre_link-80"></span><span class="sans_futura_std_bold_b_">呼び出しスタック</span></h3>
<p class="tni">誰かととりとめのない会話をしている場面を想像してください。友人のAliceの話をしたら同僚のBobのことを思い出しましたが、その前にいとこのCarolのことを説明しなければなりません。Carolの説明をしてBobの話に戻り、Bobの話をしてからAliceの話に戻ります。しかしその前に兄のDavidことを思い出したのでその話をしてから、Aliceの話に戻ります。この会話は図4-1のような<i class="calibre5">スタック</i>構造をしています。スタックでは、項目（先ほどの会話の例で言うと話題）を一番上に追加するか一番上から削除するかのどちらかしかできません。現在の項目（話題）が常にスタックの一番上にあります。</p>
<figure class="img"><img class="img1" id="calibre_link-693" src="images/000091.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 4-1：とりとめのない会話のスタック</span></p></figcaption>
</figure>
<p class="tx">こうしたとりとめのない会話と同じように、関数呼び出しはプログラム実行を関数の最初に移動させてから元の呼び出し場所に戻って来ます。Pythonは関数が呼び出された行を覚えていて、<span class="thesansmonocd_w5regular_">return</span>文に到達するとその行に戻ります。最初に実行した関数内で別の関数を呼び出すと、プログラム実行は<i class="calibre5">別の</i>関数を呼び出してから、最初の関数の実行に戻ります。スタックの一番上にある関数呼び出しがプログラム実行の現在位置です。</p>
<p class="tx">次のコードを<i class="calibre5">abcdCallStack.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def a():
    print('a() starts')
  <span class="code_codeannotation" aria-label="annotation1">❶</span> b()
  <span class="code_codeannotation" aria-label="annotation2">❷</span> d()
    print('a() returns')

def b():
    print('b() starts')
  <span class="code_codeannotation" aria-label="annotation3">❸</span> c()
    print('b() returns')

def c():
  <span class="code_codeannotation" aria-label="annotation4">❹</span> print('c() starts')
    print('c() returns')

def d():
    print('d() starts')
    print('d() returns')

<span class="codeannotated_codeannotation" aria-label="annotation5">❺</span> a()
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1487" aria-label="81"></span>この関数を実行すると、出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">a() starts
b() starts
c() starts
c() returns
b() returns
d() starts
d() returns
a() returns
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">a()</span>が呼び出されると（<span class="codeannotation" aria-label="annotation5">➎</span>）、<span class="thesansmonocd_w5regular_">b()</span>を呼び出し（<span class="codeannotation" aria-label="annotation1">➊</span>）、続いて<span class="thesansmonocd_w5regular_">c()</span>を呼び出します（<span class="codeannotation" aria-label="annotation3">➌</span>）。<span class="thesansmonocd_w5regular_">c()</span>はほかの関数を呼び出さず、<span class="thesansmonocd_w5regular_">c() starts</span>と<span class="thesansmonocd_w5regular_">c() returns</span>を表示します（<span class="codeannotation" aria-label="annotation4">➍</span>）。そして、<span class="thesansmonocd_w5regular_">c()</span>を呼び出した<span class="thesansmonocd_w5regular_">b()</span>の行に戻ります（<span class="codeannotation" aria-label="annotation3">➌</span>）。<span class="thesansmonocd_w5regular_">c()</span>を呼び出した<span class="thesansmonocd_w5regular_">b()</span>の行に戻り、<span class="thesansmonocd_w5regular_">b()</span>の実行を終えると、<span class="thesansmonocd_w5regular_">b()</span>を呼び出した<span class="thesansmonocd_w5regular_">a()</span>の行に戻ります（<span class="codeannotation" aria-label="annotation1">➊</span>）。<span class="thesansmonocd_w5regular_">b()</span>を呼び出した次の行、つまり<span class="thesansmonocd_w5regular_">d()</span>を呼び出す行に進みます（<span class="codeannotation" aria-label="annotation2">➋</span>）。<span class="thesansmonocd_w5regular_">c()</span>と同様<span class="thesansmonocd_w5regular_">d()</span>もほかの関数を呼び出しません。<span class="thesansmonocd_w5regular_">d() starts</span>と<span class="thesansmonocd_w5regular_">d() returns</span>を表示し、<span class="thesansmonocd_w5regular_">d()</span>を呼び出した<span class="thesansmonocd_w5regular_">a()</span>の行に戻ります(<span class="codeannotation" aria-label="annotation2">❷</span>)。<span class="thesansmonocd_w5regular_">a()</span>の最終行で<span class="thesansmonocd_w5regular_">a() returns</span>を表示し、<span class="thesansmonocd_w5regular_">a()</span>を呼び出した元の行に戻ります（<span class="codeannotation" aria-label="annotation5">➎</span>）。</p>
<p class="tx"><i class="calibre5">呼び出しスタック</i>は、Pythonが関数を呼び出したあとに戻る場所を覚えておく仕組みです。呼び出しスタックはプログラム中の変数に保存されているのではなくコンピュータのメモリに保存されていて、Pythonが背後で処理しています。プログラムが関数を呼び出すと、Pythonは呼び出しスタックの一番上に<i class="calibre5">フレームオブジェクト</i>を作成します。フレームオブジェクトが関数を呼び出した行番号を保存することにより、Pythonが関数の実行後に戻る場所がわかります。さらに関数を呼び出すと、呼び出しスタックの一番上に別のフレームオブジェクトを作成します。</p>
<p class="tx">関数の呼び出しが終わると、Pythonはスタックの一番上のフレームオブジェクトを削除し、そのフレームオブジェクトに保存されている行番号に戻ります。フレームオブジェクトは必ず一番上から処理されます。図4-2は<i class="calibre5">abcdCallStack.py</i>で関数の実行ごとに呼び出しスタックがどうなっているかを示しています。</p>
<figure class="img"><img class="img1" id="calibre_link-695" src="images/000092.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 4-2：</span><span class="sans_futura_std_book_">abcdCallStack.py</span><span class="sans_futura_std_book_oblique_i_">における関数の実行ごとの呼び出しスタックのフレームオブジェクト</span></p></figcaption>
</figure>
<p class="tx">呼び出しスタックの一番上には現在実行されている関数があります。呼び出しスタックが空になると、プログラム実行は関数外にあります。</p>
<p class="tx">プログラムを書くのに呼び出しスタックの技術的な細部まで知る必要はありません。関数を呼び出したあとには呼び出し行に戻ることを理解していれば十分です。呼び出しスタックを理解すると、次のセクションで説明するローカルスコープとグローバルスコープを理解する助けになります。</p>
</section>
<section type="division" aria-labelledby="sec7">
<h3 class="h" id="calibre_link-1488"><span id="calibre_link-81"></span><span class="sans_futura_std_bold_b_">ローカルスコープとグローバルスコープ</span></h3>
<p class="tni">呼び出された関数内のコードだけが、その関数内のパラメータと変数にアクセスできます。関数内の変数は、その関数の<i class="calibre5">ローカルスコープ</i>の中にあります。逆に、すべての関数の外にある変数には、プログラムのどこからでもアクセスできます。関数外の変数は、<i class="calibre5">グローバルスコープ</i>の中にあります。ローカルスコープの中にある変数を<i class="calibre5">ローカル変数</i>と呼び、グローバルスコープの中にある変数を<i class="calibre5">グローバル変数</i>と呼びます。変数は必ずローカル変数かグローバル変数のどちらかになります。</p>
<p class="tx"><i class="calibre5">スコープ</i>は変数を入れている容器だと考えてください。グローバルスコープは、プログラムの実行開始時に作られ、一つだけ存在します。プログラムが終了すると、グローバルスコープは破棄され、その中に入っている変数もすべて破棄されます。ローカルスコープは関数の呼び出し時に新しく作られます。関数内の変数はすべてその関数のローカルスコープ内にあります。関数の実行が終わると、ローカルスコープは破棄され、その中にある変数も破棄されます。</p>
<p class="tx">Pythonでは、関数がパラメータと返り値を通じてのみ変数を変更できるようにするために、スコープが存在しています。そうすることでバグの原因となる可能性のあるコードの行数を絞り込めます。もしグローバル変数しかなかったとすると、変数におかしな値が設定されているせいでバグが発生したら、どこでその値が設定されたかを追いかけるのが大変です。プログラムのどこからでも変数に値を設定できることになるからです。得てしてプログラムは数千行に及びます。これに対し、ローカル変数におかしな値が設定されているせいでバグが発生したら、その1つの関数を追うだけですみます。</p>
<p class="tx">そのため、小さなプログラムでグローバル変数を使っても構いませんが、大きなプログラムでグローバル変数に頼るのは悪い習慣です。</p>
<section type="division" aria-labelledby="sec8">
<h4 class="h1" id="calibre_link-1489"><span id="calibre_link-82"></span><span class="sans_futura_std_heavy_oblique_bi_">スコープのルール</span></h4>
<p class="tni">ローカル変数とグローバル変数を使うときには、以下のルールを意識してください。</p>
<ul class="ul">
<li class="bl">すべての関数の外側であるグローバルスコープでローカル変数は使用不可</li>
<li class="bl">関数内のローカルスコープで別のローカルスコープ内の変数は使用不可</li>
<li class="bl">ローカルスコープでグローバル変数は使用可</li>
<li class="bl">スコープが異なれば同じ名前を別々の変数に使える（ローカル変数<span class="thesansmonocd_w5regular_">spam</span>とグローバル変数<span class="thesansmonocd_w5regular_">spam</span>は別物）</li>
</ul>
<p class="tx">これらのルールを例で確かめてみましょう。</p>
<section type="division" aria-labelledby="sec9">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1490" aria-label="83"></span>
<h5 class="h2" id="calibre_link-1491"><span class="sans_futura_std_bold_b_">グローバルスコープでローカル変数は使用不可</span></h5>
<p class="tni">次のコードを実行するとエラーが発生します。</p>
<pre class="pre"><code class="calibre9">def spam():
  <span class="code_codeannotation" aria-label="annotation1">❶</span> eggs = 'sss'
spam()
print(eggs)
</code></pre>
<p class="tx">このプログラムの出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">Traceback (most recent call last):
  File "C:/test1.py", line 4, in &lt;module&gt;
    print(eggs)
NameError: name 'eggs' is not defined
</code></pre>
<p class="tx">変数<span class="thesansmonocd_w5regular_">eggs</span>は<span class="thesansmonocd_w5regular_">spam()</span>が呼び出されて変数が作成されたローカルスコープ内に存在します（<span class="codeannotation" aria-label="annotation1">➊</span>）。<span class="thesansmonocd_w5regular_">spam()</span>の実行後にそのローカルスコープは破棄され、変数<span class="thesansmonocd_w5regular_">eggs</span>は存在しなくなります。よって、<span class="thesansmonocd_w5regular_">print(eggs)</span>を実行しようとすると、<span class="thesansmonocd_w5regular_">eggs</span>が定義されていないというエラーが発生します。プログラム実行がグローバルスコープにあるときは、ローカルスコープは存在しませんから、ローカル変数もありません。グローバルスコープではグローバル変数しか使えないのです。</p>
</section>
<section type="division" aria-labelledby="sec10">
<h5 class="h2" id="calibre_link-1492"><span class="sans_futura_std_bold_b_">ローカルスコープでほかのローカルスコープの変数は使用不可</span></h5>
<p class="tni">関数が呼び出されるたびに新しいローカルスコープが作られます。ある関数内で別の関数を呼び出すときもそうです。次のプログラムを見てください。</p>
<pre class="pre"><code class="calibre9">def spam():
    eggs = 'SPAMSPAM'
  <span class="code_codeannotation" aria-label="annotation1">❶</span> bacon()
  <span class="code_codeannotation" aria-label="annotation2">❷</span> print(eggs)  # 'SPAMSPAM'が表示される

def bacon():
    ham = 'hamham'
    eggs = 'BACONBACON'

<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> spam()
</code></pre>
<p class="tx">プログラムの実行を開始すると、<span class="thesansmonocd_w5regular_">spam()</span>関数が呼び出され（<span class="codeannotation" aria-label="annotation3">❸</span>）、ローカルスコープが作られます。<span class="thesansmonocd_w5regular_">spam()</span>関数が、ローカル変数<span class="thesansmonocd_w5regular_">eggs</span>に <span class="thesansmonocd_w5regular_">'SPAMSPAM'</span>を設定し、<span class="thesansmonocd_w5regular_">bacon()</span>関数を呼び出して（<span class="codeannotation" aria-label="annotation1">➊</span>）、2つ目のローカルスコープを作成します。同時に複数のローカルスコープが存在します。この新しいローカルスコープ内で、ローカル変数<span class="thesansmonocd_w5regular_">ham</span>に <span class="thesansmonocd_w5regular_">'hamham'</span>が設定され、ローカル変数<span class="thesansmonocd_w5regular_">eggs</span>に <span class="thesansmonocd_w5regular_">'BACONBACON'</span>が設定されます。これは<span class="thesansmonocd_w5regular_">spam()</span>のローカル変数<span class="thesansmonocd_w5regular_">eggs</span>とは別物です。この時点で、プログラムには、2つの<span class="thesansmonocd_w5regular_">eggs</span>という名前のローカル変数が同時に存在します。1つは<span class="thesansmonocd_w5regular_">spam()</span>のローカル変数で、もう1つは<span class="thesansmonocd_w5regular_">bacon()</span>のローカル変数です。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">bacon()</span>の実行が終わると、そのローカルスコープは破棄され、そのローカル変数<span class="thesansmonocd_w5regular_">eggs</span>も破棄されます。<span class="thesansmonocd_w5regular_">spam()</span>関数のプログラム実行が継続し、<span class="thesansmonocd_w5regular_">eggs</span>の値を表示します（<span class="codeannotation" aria-label="annotation2">❷</span>）。<span class="thesansmonocd_w5regular_">spam()</span>のローカルスコープはまだ存在しており、変数<span class="thesansmonocd_w5regular_">eggs</span>は<span class="thesansmonocd_w5regular_">spam()</span>関数のローカルスコープにだけあります。その値は<span class="thesansmonocd_w5regular_">'SPAMSPAM'</span>です。プログラムはこれを表示します。</p>
</section>
<section type="division" aria-labelledby="sec11">
<h5 class="h2" id="calibre_link-1493"><span class="sans_futura_std_bold_b_">ローカルスコープでグローバル変数は使用可</span></h5>
<p class="tni">ここまで、グローバルスコープでローカル変数は使用不可であることと、ローカルスコープでほかのローカルスコープの変数は使用不可であることを示してきました。次のプログラムを見てください。</p>
<pre class="pre"><code class="calibre9">def spam():
    print(eggs)  # 'GLOBALGLOBAL'が表示される
eggs = 'GLOBALGLOBAL'
spam()
print(eggs)
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">eggs</span>という名前のパラメータも、変数<span class="thesansmonocd_w5regular_">eggs</span>に値を代入しているコードも、<span class="thesansmonocd_w5regular_">spam()</span>関数にはありませんから、<span class="thesansmonocd_w5regular_">spam()</span>で<span class="thesansmonocd_w5regular_">eggs</span>が使われると、グローバル変数の<span class="thesansmonocd_w5regular_">eggs</span>だとPythonは解釈します。よって、このプログラムを実行すると、<span class="thesansmonocd_w5regular_">'GLOBALGLOBAL'</span>が表示されます。</p>
</section>
<section type="division" aria-labelledby="sec12">
<h5 class="h2" id="calibre_link-1494"><span class="sans_futura_std_bold_b_">同名のローカル変数とグローバル変数は別物</span></h5>
<p class="tni">同名のグローバル変数とローカル変数を別物として使うことがPythonでは技術的に可能です。技術的に可能だからといってそのようなことはしないでください。同名のグローバル変数とローカル変数を使うとどうなるかを確認するために、次のコードを<i class="calibre5">localGlobalSameName.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def spam():
  <span class="code_codeannotation" aria-label="annotation1">❶</span> eggs = 'spam local'
    print(eggs)  # 'spam local'が表示される

def bacon():
  <span class="code_codeannotation" aria-label="annotation2">❷</span> eggs = 'bacon local'
    print(eggs)  # 'bacon local'が表示される
    spam()
    print(eggs)  # 'bacon local'が表示される

<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> eggs = 'global'
bacon()
print(eggs)  # 'global'が表示される
</code></pre>
<p class="tx">このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">bacon local
spam local
bacon local
global
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1179" aria-label="85"></span>このプログラムには3つの異なる変数がありますが、まぎらわしいことに全部同じ<span class="thesansmonocd_w5regular_">eggs</span>という名前です。3つの変数は次のとおりです。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">spam()</span>ローカルスコープ内の変数<span class="thesansmonocd_w5regular_">eggs</span>(<span class="codeannotation" aria-label="annotation1">❶</span>)</li>
<li class="bl"><span class="thesansmonocd_w5regular_">bacon()</span>ローカルスコープ内の変数<span class="thesansmonocd_w5regular_">eggs</span>(<span class="codeannotation" aria-label="annotation2">❷</span>)</li>
<li class="bl">グローバルスコープ内の変数<span class="thesansmonocd_w5regular_">eggs</span>(<span class="codeannotation" aria-label="annotation3">❸</span>)</li>
</ul>
<p class="tx">この3つの別々の変数が同じ名前ですから、どの変数が使われているかを見極めるのが困難です。スコープが別々でも変数には一意に識別できる名前を付けてください。</p>
</section>
</section>
<section type="division" aria-labelledby="sec13">
<h4 class="h1" id="calibre_link-1495"><span id="calibre_link-83"></span><span class="sans_futura_std_heavy_oblique_bi_">グローバル文</span></h4>
<p class="tni">関数内からグローバル変数を変更する場合は、<span class="thesansmonocd_w5regular_">global</span>文を使います。<span class="thesansmonocd_w5regular_">global eggs</span>のような行が関数の冒頭にあると、「この関数では<span class="thesansmonocd_w5regular_">eggs</span>はグローバル変数なのでこの名前のローカル変数を作らないでください」という意味になります。次のコードを<i class="calibre5">globalStatement.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def spam():
  <span class="code_codeannotation" aria-label="annotation1">❶</span> global eggs
  <span class="code_codeannotation" aria-label="annotation2">❷</span> eggs = 'spam'

eggs = 'global'
spam()
print(eggs)  # 'spam'が表示される
</code></pre>
<p class="tx">このコードを実行すると、最後の<span class="thesansmonocd_w5regular_">print()</span>により次のように表示されます。</p>
<pre class="pre"><code class="calibre9">spam</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">spam()</span>関数の冒頭で<span class="thesansmonocd_w5regular_">eggs</span>が<span class="thesansmonocd_w5regular_">global</span>文で宣言されていますから（<span class="codeannotation" aria-label="annotation1">❶</span>）、<span class="thesansmonocd_w5regular_">eggs</span>に<span class="thesansmonocd_w5regular_">'spam'</span>が代入されたときに（<span class="codeannotation" aria-label="annotation2">➋</span>）、グローバルスコープの<span class="thesansmonocd_w5regular_">eggs</span>に代入されます。ローカル変数の<span class="thesansmonocd_w5regular_">eggs</span>は作成されません。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1496"><span id="calibre_link-84"></span><span class="sans_futura_std_heavy_oblique_bi_">スコープの識別</span></h4>
<p class="tni">以下の4つのルールで、変数がローカル変数なのかグローバル変数なのかを見分けられます。</p>
<p class="listnumberf">  1. グローバルスコープの変数（すべての関数の外で使われている変数）は、間違いなくグローバル変数です。</p>
<p class="listnumber">  2. 関数にglobal文があれば、それも間違いなくグローバル変数です。</p>
<p class="listnumber">  3. 関数内にglobal文がなくて変数が代入文で使われていたら、ローカル変数になります。</p>
<p class="listnumberl">  4. 関数内にglobal文がなくても代入文で使われていなければ、グローバル変数です。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1293" aria-label="86"></span>このルールになじむために、もう一つプログラム例を挙げます。次のコードを<i class="calibre5">sameNameLocalGlobal.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def spam():
  <span class="code_codeannotation" aria-label="annotation1">❶</span> global eggs
    eggs = 'spam'  # グローバル変数

def bacon():
  <span class="code_codeannotation" aria-label="annotation2">❷</span> eggs = 'bacon'  # ローカル変数

def ham():
  <span class="code_codeannotation" aria-label="annotation3">❸</span> print(eggs)  # グローバル変数

eggs = 'global'  # グローバル変数
spam()
print(eggs)
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">spam()</span>関数内では、<span class="thesansmonocd_w5regular_">eggs</span>の<span class="thesansmonocd_w5regular_">global</span>文がありますから、<span class="thesansmonocd_w5regular_">eggs</span>はグローバル変数です（<span class="codeannotation" aria-label="annotation1">➊</span>）。<span class="thesansmonocd_w5regular_">bacon()</span>関数内では、代入文があるので、<span class="thesansmonocd_w5regular_">eggs</span>はローカル変数です（<span class="codeannotation" aria-label="annotation2">➋</span>）。<span class="thesansmonocd_w5regular_">ham()</span>関数内では、<span class="thesansmonocd_w5regular_">global</span>文はありませんが代入文で使われていないので、<span class="thesansmonocd_w5regular_">eggs</span>はグローバル変数です（<span class="codeannotation" aria-label="annotation3">➌</span>）。<i class="calibre5">sameNameLocalGlobal.py</i>を実行すると、出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">spam</code></pre>
<p class="tx">次のプログラムのように、関数内で変数に値を代入する前にその変数（ローカル変数）を使おうとすると、エラーが発生します。次のコードを<i class="calibre5">sameNameError.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def spam():
    print(eggs)  # エラー
  <span class="code_codeannotation" aria-label="annotation1">❶</span> eggs = 'spam local'
   
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> eggs = 'global'
spam()
</code></pre>
<p class="tx">このプログラムを実行すると、エラーメッセージが表示されます。</p>
<pre class="pre"><code class="calibre9">Traceback (most recent call last):
  File "C:/sameNameError.py", line 6, in &lt;module&gt;
    spam()
  File "C:/sameNameError.py", line 2, in spam
    print(eggs)  # エラー
UnboundLocalError: local variable 'eggs' referenced before assignment
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">spam()</span>関数には<span class="thesansmonocd_w5regular_">eggs</span>の代入文がありますから（<span class="codeannotation" aria-label="annotation1">➊</span>）、<span class="thesansmonocd_w5regular_">spam()</span>内の<span class="thesansmonocd_w5regular_">eggs</span>はローカル変数です。しかし<span class="thesansmonocd_w5regular_">eggs</span>に値が代入される前に<span class="thesansmonocd_w5regular_">print(eggs)</span>を実行しているので、ローカル変数<span class="thesansmonocd_w5regular_">eggs</span>はまだ存在しません。グローバル変数の<span class="thesansmonocd_w5regular_">eggs</span>が参照されることはありません（<span class="codeannotation" aria-label="annotation2">➋</span>）。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-933" aria-label="87"></span><span class="thesansmonocd_w5regular_">UnboundLocalError</span>というエラー名はややわかりづらいです。Pythonでは、<i class="calibre5">（boundの原形である）bind</i>が<i class="calibre5">代入</i>と同じ意味で、代入前にローカル変数を使ったことを示しています。</p>
<aside class="box" aria-label="box-10">
<p class="bt" id="calibre_link-1497"><span class="sans_futura_std_bold_b_">関数はブラックボックス</span></p>
<p class="btni"><span class="sans_futura_std_book_">関数では入力（パラメータ）と出力値さえわかれば十分なことが多いです。関数のコードがどのように動作するかを必ず理解しなければならないわけではありません。このように抽象化して捉えると、関数はブラックボックスだと言えます。</span></p>
<p class="boxb-last"><span class="sans_futura_std_book_">この考え方は現代のプログラミングの基礎になっています。本書の後半の章ではほかの人が書いたモジュールの関数を紹介します。興味があればソースコードを覗いてみることはできますが、関数を使うのにそこまでする必要はありません。関数ではグローバル変数を使わないことが推奨されていますから、関数が自分の書いたプログラムに干渉する心配は普通しなくてよいです。</span></p>
</aside>
</section>
</section>
<section type="division" aria-labelledby="sec15">
<h3 class="h" id="calibre_link-1498"><span id="calibre_link-85"></span><span class="sans_futura_std_bold_b_">例外処理</span></h3>
<p class="tni">これまでの知識では、エラー、すなわち<i class="calibre5">例外</i>が発生すると、プログラム全体がクラッシュします。実務で使うプログラムではそれは避けたいでしょう。クラッシュさせずにエラーを検知して、しかるべき処理を行い、プログラムの実行を続けたい場面があるはずです。</p>
<p class="tx">例えば、次に紹介するプログラムでは、0で割り算をするとエラーが発生します。次のコードを<i class="calibre5">zeroDivide.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def spam(divide_by):
    return 42 / divide_by

print(spam(2))
print(spam(12))
print(spam(0))
print(spam(1))
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">spam</span>関数を定義して、いろいろなパラメータを渡してその関数を実行した結果を表示しています。このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">21.0
3.5
Traceback (most recent call last):
  File "C:/zeroDivide.py", line 6, in &lt;module&gt;
    print(spam(0))
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1499" aria-label="88"></span>  File "C:/zeroDivide.py", line 2, in spam
    return 42 / divide_by
ZeroDivisionError: division by zero
</code></pre>
<p class="tx">0で割り算しようとすると<span class="thesansmonocd_w5regular_">ZeroDivisionError</span>が発生します。エラーメッセージ中に示されている行番号から、<span class="thesansmonocd_w5regular_">spam()</span>の<span class="thesansmonocd_w5regular_">return</span>文でエラーが発生していることがわかります。</p>
<p class="tx">ほとんどの場合、例外が発生するのはバグがコードに混入しているせいで、そのバグを修正する必要があります。しかし、（コードのバグではない何らかの事情により）例外の発生が想定され、例外から回復することが求められる場合もあります。例えば、<span>第10章</span>では、ファイルからテキストを読み取ります。存在しないファイルのファイル名を指定すると、<span class="thesansmonocd_w5regular_">FileNotFoundError</span>例外が送出されます。プログラムをクラッシュさせるのではなく、例外を処理してユーザーにファイル名をもう一度入力してもらう動作を期待するかもしれません。</p>
<p class="tx">エラーは<span class="thesansmonocd_w5regular_">try</span>文と<span class="thesansmonocd_w5regular_">except</span>文で処理できます。エラーが発生する可能性のあるコードを<span class="thesansmonocd_w5regular_">try</span>節に入れます。エラーが発生するとプログラム実行が<span class="thesansmonocd_w5regular_">except</span>節に移ります。</p>
<p class="tx">先の0で割り算をするコードを<span class="thesansmonocd_w5regular_">try</span>節に入れ、エラー発生時の処理をするコードを<span class="thesansmonocd_w5regular_">except</span>節に書きます。</p>
<pre class="pre"><code class="calibre9">def spam(divide_by):
    try:
        # このブロックでZeroDivisionErrorが発生してもプログラムはクラッシュしない
        return 42 / divide_by
    except ZeroDivisionError:
        # ZeroDivisionErrorが発生するとこのブロックのコードが実行される
        print('Error: Invalid argument.')

print(spam(2))
print(spam(12))
print(spam(0))
print(spam(1))
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">try</span>節のコードでエラーが発生すると、直ちにプログラム実行は<span class="thesansmonocd_w5regular_">except</span>節に移ります。そして、通常どおりプログラム実行が継続します。<span class="thesansmonocd_w5regular_">try</span>節で例外が送出されなければ、<span class="thesansmonocd_w5regular_">except</span> 節は飛ばされます。先のプログラムの出力は次のとおりです。</p>
<pre class="pre"><code class="calibre9">21.0
3.5
Error: Invalid argument.
None
42.0
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">try</span>節の関数内で発生するエラーが捕捉されます。<span class="thesansmonocd_w5regular_">spam()</span>関数の呼び出しを<span class="thesansmonocd_w5regular_">try</span>節のブロックに入れた次のプログラムを見てみましょう。</p>
<pre class="pre"><code class="calibre9">def spam(divide_by):
    return 42 / divide_by

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1297" aria-label="89"></span>try:
    print(spam(2))
    print(spam(12))
    print(spam(0))
    print(spam(1))
except ZeroDivisionError:
    print('Error: Invalid argument.')
</code></pre>
<p class="tx">このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">21.0
3.5
Error: Invalid argument.
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">print(spam(1))</span>が実行されないのは、プログラム実行が<span class="thesansmonocd_w5regular_">except</span>節に移ると<span class="thesansmonocd_w5regular_">try</span>節には戻って来ないからです。<span class="thesansmonocd_w5regular_">except</span>節のあとから通常どおりプログラム実行を続けます。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h3 class="h" id="calibre_link-1500"><span id="calibre_link-86"></span><span class="sans_futura_std_bold_b_">短いプログラム：ジグザグ</span></h3>
<p class="tni">これまでに学んだ内容を活かしてちょっとしたアニメーションプログラムを書いてみましょう。停止ボタンを押すか<small class="calibre4">CTRL</small>-Cキーを押すかして実行を止めるまでジグザグのアニメーションを表示します。このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">    ********
   ********
  ********
 ********
********
 ********
  ********
   ********
    ********
</code></pre>
<p class="tx">次のコードをファイルエディタに入力して<i class="calibre5">zigzag.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import time, sys
indent = 0  # インデントさせるスペースの個数
indent_increasing = True  # インデントを増やしていくか減らしていくか

try:
    while True:  # メインプログラムループ
        print(' ' * indent, end='')
        print('********')
        time.sleep(0.1) # 0.1秒停止

        if indent_increasing
            # スペースの個数を増やす
            indent = indent + 1
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1208" aria-label="90"></span>            if indent == 20:
                # 方向転換
                indent_increasing = False
        else:
            # スペースの個数を減らす
            indent = indent - 1
            if indent == 0:
                # 方向転換
                indent_increasing = True
except KeyboardInterrupt:
    sys.exit()
</code></pre>
<p class="tx">このコードを最初から一行ずつ見ていきましょう。</p>
<pre class="pre"><code class="calibre9">import time, sys
indent = 0 # インデントさせるスペースの個数
indent_increasing = True  # インデントを増やしていくか減らしていくか
</code></pre>
<p class="tx">最初に<span class="thesansmonocd_w5regular_">time</span>モジュールと<span class="thesansmonocd_w5regular_">sys</span>モジュールをインポートしています。このプログラムには2つの変数があります。変数<span class="thesansmonocd_w5regular_">indent</span>は8個のアスタリスクの前のスペースの個数で、変数<span class="thesansmonocd_w5regular_">indent_increasing</span>はインデントを増やすか減らすかを示すブール値です。</p>
<pre class="pre"><code class="calibre9">try:
    while True:  # メインプログラムループ
        print(' ' * indent, end='')
        print('********')
        time.sleep(0.1) # 0.1秒停止
</code></pre>
<p class="tx">残りのプログラムは<span class="thesansmonocd_w5regular_">try</span>節に入れています。プログラムの実行中に<small class="calibre4">CTRL</small>-Cが押されると、Pythonが<span class="thesansmonocd_w5regular_">KeyboardInterrupt</span>例外を送出します。<span class="thesansmonocd_w5regular_">try</span>-<span class="thesansmonocd_w5regular_">except</span>文がなければ、プログラムはクラッシュして見苦しいエラーメッセージが表示されます。このプログラムでは、<span class="thesansmonocd_w5regular_">sys.exit()</span>を呼び出して<span class="thesansmonocd_w5regular_">KeyboardInterrupt</span>例外をきれいに処理しています。（プログラムの最後の<span class="thesansmonocd_w5regular_">except</span>文でその処理をしています。）</p>
<p class="tx"><span class="thesansmonocd_w5regular_">while True:</span>の無限ループによりプログラムは永久に繰り返されます。その無限ループ内で <span class="thesansmonocd_w5regular_">' ' * indent</span>により、スペースを適当な分量だけ入れています。これらのスペースのあとに改行してほしくありませんから、最初の<span class="thesansmonocd_w5regular_">print()</span>の呼び出しでは<span class="thesansmonocd_w5regular_">end=''</span>を指定しています。2つ目の<span class="thesansmonocd_w5regular_">print()</span>の呼び出しでアスタリスクを表示します。<span class="thesansmonocd_w5regular_">time.sleep()</span>関数をこれまでに説明していませんでしたが、ここでプログラムが0.1秒停止することがわかれば十分です。</p>
<pre class="pre"><code class="calibre9">        if indent_increasing:
            # スペースの個数を増やす
            indent = indent + 1
            if indent == 20:
                indent_increasing = False  # 方向転換
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1209" aria-label="91"></span>それから、次にアスタリスクを表示するときのインデントの量を調整します。<span class="thesansmonocd_w5regular_">indent_increasing</span>が<span class="thesansmonocd_w5regular_">True</span>なら、<span class="thesansmonocd_w5regular_">indent</span>を<span class="thesansmonocd_w5regular_">1</span>増やします。インデントが<span class="thesansmonocd_w5regular_">20</span>に達したら、インデントを減らすようにします。</p>
<pre class="pre"><code class="calibre9">        else:
            # スペースの個数を減らす
            indent = indent - 1
            if indent == 0:
                indent_increasing = True  # 方向転換
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">indent_increasing</span>が<span class="thesansmonocd_w5regular_">False</span>なら、<span class="thesansmonocd_w5regular_">indent</span>を1減らします。インデントが<span class="thesansmonocd_w5regular_">0</span>に達したら、またインデントを増やすようにします。インデントを増やそうが減らそうが、メインのループの最初に戻り、アスタリスクを表示します。</p>
<p class="tx">プログラムが<span class="thesansmonocd_w5regular_">try</span>ブロックを実行中に<small class="calibre4">CTRL</small>-Cが押されると、<span class="thesansmonocd_w5regular_">except</span>文が<span class="thesansmonocd_w5regular_">KeyboardInterrrupt</span>例外を送出し、その例外を処理します。</p>
<pre class="pre"><code class="calibre9">except KeyboardInterrupt:
    sys.exit()
</code></pre>
<p class="tx">プログラム実行が<span class="thesansmonocd_w5regular_">except</span>ブロックに移り、<span class="thesansmonocd_w5regular_">sys.exit()</span>を実行して、プログラムを終了します。このように、メインのプログラムが無限ループだとしても、プログラムを終了させる方法があります。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h3 class="h" id="calibre_link-1501"><span id="calibre_link-87"></span><span class="sans_futura_std_bold_b_">短いプログラム：グラフのスパイク</span></h3>
<p class="tni">もう一つアニメーションのプログラムを作ってみましょう。このプログラムでは、文字列の繰り返しと入れ子になったループを使ってグラフのスパイクを描画します。次のコードを<i class="calibre5">spike.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import time, sys

try:
    while True:  # メインプログラムループ
        # 長さを増やしながら線を引く
        for i in range(1, 9):
            print('-' * (i * i))
            time.sleep(0.1)

        # 長さを減らしながら線を引く
        for i in range(7, 1, -1):
            print('-' * (i * i))
            time.sleep(0.1)
except KeyboardInterrupt:
    sys.exit()
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1298" aria-label="92"></span>このプログラムを実行すると、次のようなグラフのスパイクを繰り返し描画します。</p>
<pre class="pre"><code class="calibre9">-
----
---------
----------------
-------------------------
------------------------------------
-------------------------------------------------
----------------------------------------------------------------
-------------------------------------------------
------------------------------------
-------------------------
----------------
---------
----
</code></pre>
<p class="tx">一つ前のジグザグプログラムと同様に、スパイクプログラムには<span class="thesansmonocd_w5regular_">time.sleep()</span>関数と<span class="thesansmonocd_w5regular_">sys.exit()</span>関数が必要です。最初に<span class="thesansmonocd_w5regular_">time</span>モジュールと<span class="thesansmonocd_w5regular_">sys</span>モジュールをインポートしています。<span class="thesansmonocd_w5regular_">try</span>ブロックは<span class="thesansmonocd_w5regular_">KeyboardInterrupt</span>例外を捕捉します。ユーザーが<small class="calibre4">CTRL</small>-Cを押すと例外が送出されます。それまでは無限ループでグラフのスパイクを描画し続けます。</p>
<p class="tx">1つ目の<span class="thesansmonocd_w5regular_">for</span>ループではスパイク部分を増やしながら描画します。</p>
<pre class="pre"><code class="calibre9">        # 長さを増やしながら線を引く
        for i in range(1, 9):
            print('-' * (i * i))
            time.sleep(0.1)
</code></pre>
<p class="tx">変数<span class="thesansmonocd_w5regular_">i</span>は<span class="thesansmonocd_w5regular_">1</span>、<span class="thesansmonocd_w5regular_">2</span>、<span class="thesansmonocd_w5regular_">3</span>と<span class="thesansmonocd_w5regular_">9</span>まで増えていくので（<span class="thesansmonocd_w5regular_">9</span>は含みません）、<span class="thesansmonocd_w5regular_">print()</span>は文字列<span class="thesansmonocd_w5regular_">'-'</span>を<span class="thesansmonocd_w5regular_">1 * 1</span>で<span class="thesansmonocd_w5regular_">1</span>、<span class="thesansmonocd_w5regular_">2 * 2</span>で<span class="thesansmonocd_w5regular_">4</span>、<span class="thesansmonocd_w5regular_">3 * 3</span>で<span class="thesansmonocd_w5regular_">9</span>と増やしながら表示していきます。このコードは、1、4、9、16、25、36、49、64と<span class="thesansmonocd_w5regular_">'-'</span>の長さを増やしていきます。このように指数関数的に増やすことで、グラフのスパイクの前半を描画します。</p>
<p class="tx">グラフのスパイクの後半を描画するために、2つ目の<span class="thesansmonocd_w5regular_">for</span>ループでは、<span class="thesansmonocd_w5regular_">i</span>を<span class="thesansmonocd_w5regular_">7</span>から始めて<span class="thesansmonocd_w5regular_">1</span>まで減らしていきます（<span class="thesansmonocd_w5regular_">1</span>は含みません）。</p>
<pre class="pre"><code class="calibre9">        # 長さを減らしながら線を引く
        for i in range(7, 1, -1):
            print('-' * (i * i))
            time.sleep(0.1)
</code></pre>
<p class="tx">グラフのスパイクの幅を変えたければ、2つの<span class="thesansmonocd_w5regular_">for</span>ループ内の<span class="thesansmonocd_w5regular_">9</span>と<span class="thesansmonocd_w5regular_">7</span>の値を調整できます。値を調整してもコードの他の部分はそのままで大丈夫です。</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec18">
<h3 class="h" id="calibre_link-1502"><span id="calibre_link-88"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">関数はコードを論理的に分割する主な方法です。関数内の変数はその関数のローカルスコープ内に存在しますから、ある関数のコードが別の関数の変数の値を直接変更することはできません。そのため、変数の値がどこで変更されたかが限定され、デバッグの労が減ります。</p>
<p class="tx">関数を利用するとコードを整理できます。関数はブラックボックスだと考えられます。パラメータの形で入力を受け取り、返り値の形で出力を返します。関数内のコードはほかの関数内の変数に影響を及ぼしません。</p>
<p class="tx">これまでの章では、エラーが1回でも発生するとプログラムがクラッシュしました。本章では、<span class="thesansmonocd_w5regular_">try</span>文と<span class="thesansmonocd_w5regular_">except</span>文を学習し、エラーを検知してコードの実行を続けられるようになりました。これで一般的なエラーに対するプログラムの耐障害性が高まりました。</p>
</section>
<section type="division" aria-labelledby="sec19">
<h3 class="h" id="calibre_link-1504"><span id="calibre_link-89"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. プログラムで関数を利用するとどのような利点がありますか？</p>
<p class="listnumber">  2. 関数内のコードが実行されるのは、関数が定義されたときか関数が呼び出されたときのどちらですか？</p>
<p class="listnumber">  3. 関数を作成するにはどのような文を書きますか？</p>
<p class="listnumber">  4. 関数と関数呼び出しの違いは何ですか？</p>
<p class="listnumber">  5. Pythonのプログラムにはグローバルスコープがいくつありますか？　ローカルスコープはいくつありますか？</p>
<p class="listnumber">  6. 関数の呼び出しが終わったときにその関数のローカルスコープ内の変数はどうなりますか？</p>
<p class="listnumber">  7. 返り値とは何ですか？　返り値を式の一部にすることはできますか？</p>
<p class="listnumber">  8. 関数に<span class="thesansmonocd_w5regular_">return</span>文がない場合に、その関数を呼び出したときの返り値はどうなりますか？</p>
<p class="listnumber">  9. どのようにすれば関数内の変数がグローバル変数を参照できますか？</p>
<p class="listnumber">10. <span class="thesansmonocd_w5regular_">None</span>のデータ型は何ですか？</p>
<p class="listnumber">11. <span class="thesansmonocd_w5regular_">import areallyourpetsnamederic</span>文は何を行いますか？</p>
<p class="listnumber">12. <span class="thesansmonocd_w5regular_">spam</span>モジュールに<span class="thesansmonocd_w5regular_">bacon()</span>関数があるとします。<span class="thesansmonocd_w5regular_">spam</span>モジュールをインポートしてから、その関数をどのように呼び出しますか？</p>
<p class="listnumber">13. どのようにすればエラーが発生したときにプログラムがクラッシュするのを防げますか？</p>
<p class="listnumber">14. <span class="thesansmonocd_w5regular_">try</span>節と<span class="thesansmonocd_w5regular_">except</span>節とは何ですか？</p>
<p class="listnumber">15. 次のコードを<i class="calibre5">notrandomdice.py</i>という名前で保存して実行してください。関数呼び出しが同じ数値ばかりを返すのはなぜですか？</p>
<pre class="pre"><code class="calibre9">import random
random_number = random.randint(1, 6)

def get_random_dice_roll():
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1031" aria-label="94"></span>    # 1から6までのランダムな整数を返す
    return random_number

print(get_random_dice_roll())
print(get_random_dice_roll())
print(get_random_dice_roll())
print(get_random_dice_roll())
</code></pre>
</section>
<section type="division" aria-labelledby="sec20">
<h3 class="h" id="calibre_link-1505"><span id="calibre_link-90"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1506"><span id="calibre_link-91"></span><span class="sans_futura_std_heavy_oblique_bi_">コラッツの問題</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">number</span>をパラメータとする<span class="thesansmonocd_w5regular_">collatz()</span>という名前の関数を作成してください。<span class="thesansmonocd_w5regular_">number</span>が偶数なら<span class="thesansmonocd_w5regular_">collatz()</span>は<span class="thesansmonocd_w5regular_">number // 2（2で割った商）</span>を表示して、その値を返します。<span class="thesansmonocd_w5regular_">number</span>が奇数なら、<span class="thesansmonocd_w5regular_">collatz()</span>は<span class="thesansmonocd_w5regular_">3 * number + 1（3倍して1を足した数）</span>を表示して、その値を返します。</p>
<p class="tx">ユーザーが整数を入力すると、その整数を最初の引数として、返り値が<span class="thesansmonocd_w5regular_">1</span>になるまで<span class="thesansmonocd_w5regular_">collatz()</span>関数を繰り返し適用するプログラムを書いてください。（驚くべきことに、最初にどのような整数を与えても、この手順で必ず1にたどり着きます。数学者にとってさえもその理由ははっきりしていません。最も単純な解決不能問題とも言われる<i class="calibre5">コラッツの問題</i>です。）</p>
<p class="tx"><span class="thesansmonocd_w5regular_">input()</span>の返り値を<span class="thesansmonocd_w5regular_">int()</span>関数で整数に変換するのを忘れないでください。そうしないと文字列値になってしまいます。出力をコンパクトにするために、<span class="thesansmonocd_w5regular_">sep=' '</span>と名前付きパラメータを設定して、<span class="thesansmonocd_w5regular_">print()</span>がすべての値を1行で表示するようにしてください。</p>
<p class="tx">このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">Enter number:
3
3 10 5 16 8 4 2 1
</code></pre>
<p class="tx">ヒント：<span class="thesansmonocd_w5regular_">number</span>は、<span class="thesansmonocd_w5regular_">number % 2</span> <span class="thesansmonocd_w5regular_">==</span> <span class="thesansmonocd_w5regular_">0</span>なら偶数で、<span class="thesansmonocd_w5regular_">number % 2</span> <span class="thesansmonocd_w5regular_">==</span> <span class="thesansmonocd_w5regular_">1</span>なら奇数です。</p>
</section>
<section type="division" aria-labelledby="sec22">
<h4 class="h1" id="calibre_link-1507"><span id="calibre_link-92"></span><span class="sans_futura_std_heavy_oblique_bi_">入力値の検証</span></h4>
<p class="tni">先ほどのプログラムに<span class="thesansmonocd_w5regular_">try</span>文と<span class="thesansmonocd_w5regular_">except</span>文を追加して、ユーザーが整数以外を入力したら検知されるようにしてください。<span class="thesansmonocd_w5regular_">int('puppy')</span>のように整数ではない文字列が渡されると、<span class="thesansmonocd_w5regular_">int()</span>関数は<span class="thesansmonocd_w5regular_">ValueError</span>エラーを送出します。<span class="thesansmonocd_w5regular_">except</span>節では、整数を入力しなければならない旨のメッセージを表示してください。</p>
</section>
</section>
</section>
</div>


</div>



</body></html>