<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-227">
<section type="chapter" role="doc-chapter" aria-labelledby="ch10">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1155" aria-label="217"></span>
<hgroup>
<h2 class="title" id="calibre_link-1667">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">10</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">ファイルの読み書き</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">プログラムの実行中にデータを保存するには変数で事足りますが、プログラムの終了後もデータを保存しておく必要があるなら、ファイルに保存する必要があります。ファイルの内容は、ギガバイト単位のサイズになる可能性もありますが、一つの文字列だと考えることができます。本章では、Pythonでハードドライブ上のファイルを作成、読み取り、保存（書き込み）する方法を説明します。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1668"><span id="calibre_link-228"></span><span class="sans_futura_std_bold_b_">ファイルとファイルパス</span></h3>
<p class="tni">ファイルには2つの主要なプロパティがあります。<i class="calibre5">ファイル名</i>（通常は1単語）と<i class="calibre5">パス</i>です。パスはそのファイルがコンピュータ上に存在する場所です。例えば、私のWindowsノートPCには、パス<i class="calibre5">C:\Users\Al\Documents</i>に<i class="calibre5">project.docx</i>という名前のファイルがあります。ファイル名のドット以下の部分は<i class="calibre5">拡張子</i>と呼ばれ、ファイルの種類を示します。<i class="calibre5">project.docx</i>というファイル名からWordの文書ファイルであることがわかり、<i class="calibre5">Users</i>、<i class="calibre5">Al</i>、 <i class="calibre5">Documents</i>はすべて<i class="calibre5">フォルダ</i>（<i class="calibre5">ディレクトリ</i>とも呼ばれます）です。フォルダにはファイルとフォルダ（<i class="calibre5">サブフォルダ</i>）を入れることができます。例えば、<i class="calibre5">project.docx</i>は、<i class="calibre5">Users</i>フォルダの中にある<i class="calibre5">Al</i>フォルダの中にある<i class="calibre5">Documents</i>フォルダの中にあります。図10-1はこのフォルダの階層構造を示しています。</p>
<figure class="img"><img class="img2" id="calibre_link-728" src="images/000005.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 10-1：フォルダの階層構造</span></p></figcaption>
</figure>
<p class="tx">パスの<i class="calibre5">C:\</i>という部分は、すべてのフォルダを含む<i class="calibre5">ルートフォルダ</i>です。Windowsでは、ルートフォルダは<i class="calibre5">C:\</i>という名前で、<i class="calibre5">C: ドライブ</i>と呼ばれることもあります。macOSとLinuxでは、ルートフォルダは<i class="calibre5">/</i>です。本書では、Windowsスタイルのルートフォルダ<i class="calibre5">C:\</i>で表記します。macOSやLinuxで対話型シェルを実行する場合は、<span class="thesansmonocd_w5regular_">/</span>と読み替えてください。</p>
<p class="tx">DVDドライブやUSBフラッシュドライブのような追加<i class="calibre5">ボリューム</i>の見え方はOSによって異なります。Windowsでは、<i class="calibre5">D:\</i>や<i class="calibre5">E:\</i>のような、新しいアルファベットのドライブが出現します。macOSでは、<i class="calibre5">/Volumes</i>フォルダ以下に新しいフォルダが出現します。Linuxでは、<i class="calibre5">/mnt</i>フォルダ以下に新しいフォルダが出現します。WindowsとmacOSではフォルダ名とファイル名の大文字と小文字を区別しませんが、Linuxでは区別します。</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_1">注記</span></p>
</blockquote>
<p class="note-txt"><i class="calibre5">お使いのシステムでは筆者のシステムのファイルやフォルダと違っているでしょうから、本章の例を正確に再現することはできないと思います。お使いのシステムに存在するフォルダで再現するようにしてください。</i></p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1669"><span id="calibre_link-229"></span><span class="sans_futura_std_heavy_oblique_bi_">パス区切りの標準化</span></h4>
<p class="tni">フォルダ名の間のパス区切りに、Windowsではバックスラッシュ（<span class="thesansmonocd_w5regular_">\</span>）を使いますが、macOSとLinuxではスラッシュ（<i class="calibre5">/</i>）を使います。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">pathlib</span>モジュールの<span class="thesansmonocd_w5regular_">Path()</span>関数はすべてのOSに対応していますので、Pythonのコードではスラッシュに統一するのがベストプラクティスです。ファイル名やフォルダ名の文字列値を渡すと、<span class="thesansmonocd_w5regular_">Path()</span>は正しいパス区切りのファイルパスを文字列で返してくれます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path('spam', 'bacon', 'eggs')</b>
WindowsPath('spam/bacon/eggs')
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1053" aria-label="219"></span>&gt;&gt;&gt; <b class="calibre10">str(Path('spam', 'bacon', 'eggs'))</b>
'spam\\bacon\\eggs'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">WindowsPath</span>オブジェクトではスラッシュ（<span class="thesansmonocd_w5regular_">/</span>）を使っていても、<span class="thesansmonocd_w5regular_">str()</span>関数で文字列に変換するとバックスラッシュ（<span class="thesansmonocd_w5regular_">\</span>）を使うようになります。<span class="thesansmonocd_w5regular_">pathlib</span>をインポートする際には<span class="thesansmonocd_w5regular_">from pathlib import Path</span>とするのが慣習になっています。そうすれば<span class="thesansmonocd_w5regular_">pathlib.Path</span>の代わりに<span class="thesansmonocd_w5regular_">Path</span>と書くことができます。書くのも読むのも楽になります。</p>
<p class="tx">本章の対話型シェルの例はWindowsで実行しているので、<span class="thesansmonocd_w5regular_">WindowsPath('spam/bacon/eggs')</span>と表示されているように、<span class="thesansmonocd_w5regular_">Path('spam', 'bacon', 'eggs')</span>は<span class="thesansmonocd_w5regular_">WindowsPath</span>オブジェクトを返します。Windowsではバックスラッシュを使いますが、対話型シェルでの<span class="thesansmonocd_w5regular_">WindowsPath</span>の表記ではスラッシュが使われています。オープンソースソフトウェアの開発者は歴史的にLinuxを好むためにそうなっています。</p>
<p class="tx">このパスのテキストがほしければ、<span class="thesansmonocd_w5regular_">str()</span>関数に渡します。先の例では<span class="thesansmonocd_w5regular_">'spam\\bacon\\eggs'</span>が返されています（バックスラッシュをエスケープするためにバックスラッシュが2つになっている点に注意してください）。この関数をmacOSやLinuxで呼び出したとしたら、<span class="thesansmonocd_w5regular_">Path()</span>は<span class="thesansmonocd_w5regular_">PosixPath</span>オブジェクトを返し、<span class="thesansmonocd_w5regular_">str()</span>関数に渡したら<span class="thesansmonocd_w5regular_">'spam/bacon/eggs'</span>が返されていたはずです（<i class="calibre5">POSIX</i>はUnix系OSの標準規格です）。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">Path</span>オブジェクトを扱うとしても、<span class="thesansmonocd_w5regular_">WindowsPath</span>と<span class="thesansmonocd_w5regular_">PosixPath</span>がソースコードに直接現れることは決してありません。これらの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトは本章で紹介するファイル関連の関数に渡されます。例えば、以下のコードはファイル名のリストをフォルダ名の末尾に連結しています。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt;<b class="calibre10"> my_files = ['accounts.txt', 'details.csv', 'invite.docx']</b>
&gt;&gt;&gt;<b class="calibre10"> for filename in my_files:</b>
...     <b class="calibre10">print(Path(r'C:\Users\Al', filename))</b>
...
C:\Users\Al\accounts.txt
C:\Users\Al\details.csv
C:\Users\Al\invite.docx
</code></pre>
<p class="tx">Windowsではバックスラッシュでディレクトリを区切りますから、ファイル名にバックスラッシュを使うことはできません。しかし、macOSとLinuxではバックスラッシュをファイル名に使えます。よって、<span class="thesansmonocd_w5regular_">Path(r'spam\eggs')</span>はWindowsでは2つの別々のフォルダ（あるいは<i class="calibre5">spam</i>フォルダ内の<i class="calibre5">eggs</i>ファイル）を指しますが、macOSとLinuxでは<i class="calibre5">spam\eggs</i>という名前の一つのフォルダ（またはファイル）を指します。そのため、Pythonのコードでは常にスラッシュを使うのが望ましいです（本書のこのあとの部分もそうしています）。<span class="thesansmonocd_w5regular_">pathlib</span>モジュールはすべてのOSで動作することを保証します。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h4 class="h1" id="calibre_link-1670"><span id="calibre_link-230"></span><span class="sans_futura_std_heavy_oblique_bi_">パスの連結</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">+</span>演算子は2つの整数または浮動小数点数の足し算に使うのが普通ですが（例えば<span class="thesansmonocd_w5regular_">2</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">2</span>という式は<span class="thesansmonocd_w5regular_">4</span>という整数値に評価されます）、<span class="thesansmonocd_w5regular_">+</span>演算子を2つの文字列値を結合するにも使えます（例えば<span class="thesansmonocd_w5regular_">'Hello'</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">'World'</span>という式は<span class="thesansmonocd_w5regular_">'HelloWorld'</span>という文字列値に評価されます）。同様に、<span class="thesansmonocd_w5regular_">/</span>演算子は、割り算に使うのが普通ですが、<span class="thesansmonocd_w5regular_">Path</span>オブジェクトと文字列を結合することもできます。<span class="thesansmonocd_w5regular_">Path()</span>関数で<span class="thesansmonocd_w5regular_">Path</span>オブジェクトを作成してから調整するのに便利です。</p>
<p class="tx">対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path('spam') / 'bacon' / 'eggs'</b>
WindowsPath('spam/bacon/eggs')
&gt;&gt;&gt; <b class="calibre10">Path('spam') / Path('bacon/eggs')</b>
WindowsPath('spam/bacon/eggs')
&gt;&gt;&gt; <b class="calibre10">Path('spam') / Path('bacon', 'eggs')</b>
WindowsPath('spam/bacon/eggs')
</code></pre>
<p class="tx">パスの連結に<span class="thesansmonocd_w5regular_">/</span>演算子を使う際に一つ覚えておく必要のあることがあります。式中の最初の2つの値のうち1つは<span class="thesansmonocd_w5regular_">Path</span>オブジェクトでなければなりません。式は左から右へと評価されていき、<span class="thesansmonocd_w5regular_">/</span>演算子は2つの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトか1つの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトと1つの文字列に使えるのですけれども、2つの文字列には使えません。対話型シェルで以下の内容を実行しようとするとエラーになります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'spam' / 'bacon'</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for /: 'str' and 'str'
</code></pre>
<p class="tx">式全体が<span class="thesansmonocd_w5regular_">Path</span>オブジェクトに評価されるには、1番目か2番目の値のどちらかが<span class="thesansmonocd_w5regular_">Path</span>オブジェクトでなければなりません。<span class="thesansmonocd_w5regular_">/</span>演算子と<span class="thesansmonocd_w5regular_">Path</span>オブジェクトが<span class="thesansmonocd_w5regular_">Path</span>オブジェクトに評価される様子を以下に示します。</p>
<figure class="img"><img class="img2" id="calibre_link-1344" src="images/000110.jpg" alt="" />
<figcaption><p class="cap"></p></figcaption>
</figure>
<p class="tx">先ほど紹介した<span class="thesansmonocd_w5regular_">TypeError: unsupported operand type(s) for /: 'str' and 'str'</span>エラーメッセージを目にしたら、文字列ではなく<span class="thesansmonocd_w5regular_">Path</span>オブジェクトを式の左側に配置する必要があります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">/</span>演算子は古い<span class="thesansmonocd_w5regular_">os.path.join()</span>関数の代わりに使えます。<i class="calibre5"><a href="https://docs.python.org/3/library/os.path.html#os.path.join" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/os<wbr></wbr>.path<wbr></wbr>.html#os<wbr></wbr>.path<wbr></wbr>.join</a></i>で詳しく説明されています。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1671"><span id="calibre_link-231"></span><span class="sans_futura_std_heavy_oblique_bi_">現在の作業ディレクトリにアクセスする</span></h4>
<p class="tni">コンピュータ上で実行されているすべてのプログラムには<i class="calibre5">現在の作業ディレクトリ</i>があります。ルートフォルダで始まらないファイル名やパスは、現在の作業ディレクトリ以下にあるとみなされます。</p>
<blockquote class="calibre17">
<p class="note"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1009" aria-label="221"></span><span class="sans_dogma_ot_bold_b_1">注記</span></p>
</blockquote>
<p class="note-txt"><span class="dedication_italic">フォルダ</span><i class="calibre5">は</i><span class="dedication_italic">ディレクトリ</span><i class="calibre5">よりも新しい呼び方ですが、</i><span class="dedication_italic">現在の作業ディレクトリ</span><i class="calibre5">（あるいは単に</i> <span class="dedication_italic">作業ディレクトリ</span><i class="calibre5">）という用語が標準的で、</i>現在の作業<span class="dedication_italic">フォルダ</span><i class="calibre5">とはあまり言いません。</i></p>
<p class="tx"><span class="thesansmonocd_w5regular_">Path.cwd()</span>関数で現在の作業ディレクトリの文字列値を取得でき、<span class="thesansmonocd_w5regular_">os.chdir()</span>で現在の作業ディレクトリを変更できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">import os</b>
&gt;&gt;&gt; <b class="calibre10">Path.cwd()</b>
WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python313')'
&gt;&gt;&gt; <b class="calibre10">os.chdir('C:\\Windows\\System32')</b>
&gt;&gt;&gt; <b class="calibre10">Path.cwd()</b>
WindowsPath('C:/Windows/System32')
</code></pre>
<p class="tx">現在の作業ディレクトリは<i class="calibre5">C:\Users\Al\AppData\Local\Programs\Python\Python313</i>ですから、<i class="calibre5">project.docx</i>というファイル名は<i class="calibre5">C:\Users\Al\AppData\Local\Programs\Python\Python313\project.docx</i>を指します。現在の作業ディレクトリを<i class="calibre5">C:\Windows\System32</i>に変更すると、<i class="calibre5">project.docx</i>というファイル名が<i class="calibre5">C:\Windows\System32\project.docx</i>だと解釈されます。</p>
<p class="tx">存在しないディレクトリに変更しようとするとエラーになります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import os</b>
&gt;&gt;&gt; <b class="calibre10">os.chdir('C:/ThisFolderDoesNotExist')</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
FileNotFoundError: [WinError 2] The system cannot find the file specified:
'C:/ThisFolderDoesNotExist'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">pathlib</span>には現在の作業ディレクトリを変更する関数がないので、<span class="thesansmonocd_w5regular_">os.chdir()</span>を使ってください。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">os.getcwd()</span>関数は現在の作業ディレクトリの文字列を取得する古い方法です。<i class="calibre5"><a href="https://docs.python.org/3/library/os.html#os.getcwd" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/os<wbr></wbr>.html#os<wbr></wbr>.getcwd</a></i>に書かれています。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1672"><span id="calibre_link-232"></span><span class="sans_futura_std_heavy_oblique_bi_">ホームディレクトリにアクセスする</span></h4>
<p class="tni">コンピュータ上には、<i class="calibre5">ホームディレクトリ</i>ないし<i class="calibre5">ホームフォルダ</i>と呼ばれる、ユーザー用のフォルダがあります。<span class="thesansmonocd_w5regular_">Path.home()</span>を呼び出すとホームフォルダの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトを取得できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path.home()</b>
WindowsPath('C:/Users/Al')
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-856" aria-label="222"></span>ホームディレクトリはOSに応じて決まった場所にあります。</p>
<ul class="ul">
<li class="bl">Windowsでは、ホームディレクトリが<i class="calibre5">C:\Users</i>以下にあります。</li>
<li class="bl">macOSでは、ホームディレクトリが<i class="calibre5">/Users</i>以下にあります。</li>
<li class="bl">Linuxでは、ホームディレクトリが<i class="calibre5">/home</i>以下にあります。</li>
</ul>
<p class="tx">自分が書いたスクリプトにはホームディレクトリ以下のファイルを読み書きできるパーミッション（権限）があるはずですから、Pythonプログラムで操作する対象のファイルをホームディレクトリ以下に置くのが望ましいです。</p>
</section>
<section type="division" aria-labelledby="sec6">
<h4 class="h1" id="calibre_link-1673"><span id="calibre_link-233"></span><span class="sans_futura_std_heavy_oblique_bi_">絶対パス指定と相対パス指定</span></h4>
<p class="tni">ファイルパスを指定するには、2つの方法があります。</p>
<ul class="ul">
<li class="bl">ルートフォルダ（Windowsでは<i class="calibre5">C:\</i>、macOSとLinuxでは<i class="calibre5">/</i>）で始まる<i class="calibre5">絶対パス</i></li>
<li class="bl">プログラムの現在の作業ディレクトリから相対的に場所が決まる<i class="calibre5">相対パス</i></li>
</ul>
<p class="tx">Windowsでは、<i class="calibre5">C:\</i>がメインハードドライブのルートです。1960年代にはコンピュータに<i class="calibre5">A:\</i>と<i class="calibre5">B:\</i>という2つのフロッピーディスクドライブがあったことに由来します。Windowsでは、USBメモリとDVDドライブには<i class="calibre5">D:\</i>以降の文字が割り当てられます。そのストレージメディアのファイルにアクセスするには、そのドライブ文字をルートフォルダとして使います。</p>
<p class="tx"><i class="calibre5">ドット</i>（<i class="calibre5">.</i>）と<i class="calibre5">ドットドット</i>（<i class="calibre5">..</i>）というフォルダもあります。これらは実際のフォルダではなく、ファイルパスで用いられる特別な名前です。ドットは<i class="calibre5">このフォルダ</i>を表し、ドットドットは<i class="calibre5">親フォルダ</i>を表します。</p>
<p class="tx">図10-2はフォルダとファイルの例です。現在の作業ディレクトリが<i class="calibre5">C:\bacon</i>だと仮定して、相対パスを図に書きました。</p>
<figure class="img"><img class="img1" id="calibre_link-730" src="images/000006.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 10-2：現在の作業ディレクトリが</span><span class="sans_futura_std_book_">C:\bacon</span>である場合のフォルダとファイルの相対パス</p></figcaption>
</figure>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-878" aria-label="223"></span>相対パスの最初の<i class="calibre5">.\</i>はあってもなくてもいいです。例えば、<i class="calibre5">.\spam.txt</i>と<i class="calibre5">spam.txt</i>は同じファイルを指します。</p>
</section>
<section type="division" aria-labelledby="sec7">
<h4 class="h1" id="calibre_link-1674"><span id="calibre_link-234"></span><span class="sans_futura_std_heavy_oblique_bi_">新しいフォルダを作成する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">os.makedirs()</span>関数で新しいフォルダを作成できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import os</b>
&gt;&gt;&gt; <b class="calibre10">os.makedirs('C:\\delicious\\walnut\\waffles')</b>
</code></pre>
<p class="tx"><i class="calibre5">C:\delicious</i>フォルダだけでなく<i class="calibre5">C:\delicious</i>の内部にある<i class="calibre5">walnut</i>フォルダと、<i class="calibre5">C:\delicious\walnut</i>フォルダの内部にある<i class="calibre5">waffles</i>フォルダも作成されます。つまり、<span class="thesansmonocd_w5regular_">os.makedirs()</span>は必要となる中間的なフォルダを作成し、指定したフルパスが存在することを保証します。図10-3はこのフォルダの階層構造を示しています。</p>
<figure class="img"><img class="img2" id="calibre_link-732" src="images/000007.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 10-3：</span><span class="sans_thesansmonocd_w5regular_italic_">os.makedirs('C:\\delicious\\ walnut\\waffles')</span>の結果</p></figcaption>
</figure>
<p class="tx"><span class="thesansmonocd_w5regular_">mkdir()</span>メソッドを呼び出すと<span class="thesansmonocd_w5regular_">Path</span>オブジェクトからディレクトリを作成できます。例えば、このコードは私のホームフォルダ以下に<i class="calibre5">spam</i>フォルダを作成します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path(r'C:\Users\Al\spam').mkdir()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">mkdir()</span>は一度に一つのディレクトリしか作成できないことに注意してください。<span class="thesansmonocd_w5regular_">parents=True</span>を渡せば、必要となる親フォルダも同時に作成できるようになります。</p>
</section>
<section type="division" aria-labelledby="sec8">
<h4 class="h1" id="calibre_link-1675"><span id="calibre_link-235"></span><span class="sans_futura_std_heavy_oblique_bi_">絶対パスと相対パスを扱う</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Path</span>オブジェクトの<span class="thesansmonocd_w5regular_">is_absolute()</span>メソッドを呼び出すと、絶対パスを表していれば<span class="thesansmonocd_w5regular_">True</span>が返され、相対パスを表していれば<span class="thesansmonocd_w5regular_">False</span>が返されます。例えば、お手元のフォルダで以下のコードを試してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path.cwd()</b>
WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python312')
&gt;&gt;&gt; <b class="calibre10">Path.cwd().is_absolute()</b>
True
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-877" aria-label="224"></span>&gt;&gt;&gt; <b class="calibre10">Path('spam/bacon/eggs').is_absolute()</b>
False
</code></pre>
<p class="tx">相対パスから絶対パスを得たければ、相対パスの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトの前に<span class="thesansmonocd_w5regular_">Path.cwd() /</span>を置きます。「相対パス」というのは現在の作業ディレクトリから相対的に見たパスのことです。<span class="thesansmonocd_w5regular_">absolute()</span>メソッドを呼び出しても絶対パスの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトを取得できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path('my/relative/path')</b>
WindowsPath('my/relative/path')
&gt;&gt;&gt; <b class="calibre10">Path.cwd() / Path('my/relative/path')</b>
WindowsPath('C:/Users/Al/Desktop/my/relative/path')
&gt;&gt;&gt; <b class="calibre10">Path('my/relative/path').absolute()</b>
WindowsPath('C:/Users/Al/Desktop/my/relative/path')
</code></pre>
<p class="tx">相対パスが現在の作業ディレクトリ以外のパスから見た相対パスである場合には、<span class="thesansmonocd_w5regular_">Path.cwd()</span>をその起点となるパスに置き換えてください。以下の例は現在の作業ディレクトリではなくホームディレクトリを使って絶対パスを取得しています。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path('my/relative/path')</b>
WindowsPath('my/relative/path')
&gt;&gt;&gt; <b class="calibre10">Path.home() / Path('my/relative/path')</b>
WindowsPath('C:/Users/Al/my/relative/path')
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Path</span>オブジェクトは絶対パスも相対パスも表せます。<span class="thesansmonocd_w5regular_">Path</span>オブジェクトがルートフォルダで始まるかどうかという点だけが違います。</p>
</section>
<section type="division" aria-labelledby="sec9">
<h4 class="h1" id="calibre_link-1676"><span id="calibre_link-236"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルパスの一部を取得する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">Path</span>オブジェクトがあれば、その属性からファイルパスの一部を文字列として抽出できます。既存のファイルパスから新しいファイルパスを組み立てる際に便利です。図10-4に属性を示します。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-904" aria-label="225"></span>
<figure class="img"><img class="img2" id="calibre_link-733" src="images/000008.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 10-4：Windowsのファイルパス（上側）とmacOSまたはLinuxのファイルパス（下側）の属性</span></p></figcaption>
</figure>
<p class="tx">ファイルパスには次のような部分があります。</p>
<ul class="ul">
<li class="bl"><i class="calibre5">anchor</i>はルートフォルダです。</li>
<li class="bl">Windowsで、<i class="calibre5">drive</i>は、物理ハードドライブその他のストレージデバイスを示すアルファベット1文字です。</li>
<li class="bl"><i class="calibre5">parent</i>は、そのファイルを含むフォルダです。</li>
<li class="bl">ファイルの<i class="calibre5">name</i>は、<i class="calibre5">stem</i>と<i class="calibre5">suffix</i>から成り立っています。</li>
</ul>
<p class="tx">Windowsの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトには属性<span class="thesansmonocd_w5regular_">drive</span>がありますが、macOSとLinuxの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトにはありません。属性<span class="thesansmonocd_w5regular_">drive</span>は最初のバックスラッシュを含みません。</p>
<p class="tx">対話型シェルでファイルパスからそれぞれの属性を取り出してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">p = Path('C:/Users/Al/spam.txt')</b>
&gt;&gt;&gt; <b class="calibre10">p.anchor</b>
'C:\\'
&gt;&gt;&gt; <b class="calibre10">p.parent </b>
WindowsPath('C:/Users/Al')
&gt;&gt;&gt; <b class="calibre10">p.name</b>
'spam.txt'
&gt;&gt;&gt; <b class="calibre10">p.stem</b>
'spam'
&gt;&gt;&gt; <b class="calibre10">p.suffix</b>
'.txt'
&gt;&gt;&gt; <b class="calibre10">p.drive</b>
'C:'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1302" aria-label="226"></span>別の<span class="thesansmonocd_w5regular_">Path</span>オブジェクトに評価される<span class="thesansmonocd_w5regular_">parent</span>以外の属性は文字列値に評価されます。パスを区切りたければ、タプルの中に文字列が入っている属性<span class="thesansmonocd_w5regular_">parts</span>にアクセスします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">p = Path('C:/Users/Al/spam.txt')</b>
&gt;&gt;&gt; <b class="calibre10">p.parts</b>
('C:\\', 'Users', 'Al', 'spam.txt')
 &gt;&gt;&gt; <b class="calibre10">p.parts[3]</b>
'spam.txt'
&gt;&gt;&gt; <b class="calibre10">p.parts[0:2]</b>
('C:\\', 'Users')
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Path()</span>の呼び出しではスラッシュを含む文字列を使っているのに、Windowsの<span class="thesansmonocd_w5regular_">parts</span>のanchorでは<span class="thesansmonocd_w5regular_">'C:\\'</span>（raw文字列ならエスケープしない<span class="thesansmonocd_w5regular_">r'C:\'</span>）と適切なバックスラッシュが使われていることに注意してください。</p>
<p class="tx">属性<span class="thesansmonocd_w5regular_">parents</span>（<span class="thesansmonocd_w5regular_">parent</span>と異なり複数形です）は、整数のインデックスでアクセスできる<span class="thesansmonocd_w5regular_">Path</span>オブジェクトの祖先フォルダに評価されます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">Path.cwd()</b>
WindowsPath('C:/Users/Al/Desktop')
&gt;&gt;&gt; <b class="calibre10">Path.cwd().parents[0]</b>
WindowsPath('C:/Users/Al')
&gt;&gt;&gt; <b class="calibre10">Path.cwd().parents[1]</b>
WindowsPath('C:/Users')
&gt;&gt;&gt; <b class="calibre10">Path.cwd().parents[2]</b>
WindowsPath('C:/')
</code></pre>
<p class="tx">祖先フォルダを追いかけていくと、ルートフォルダに行き着きます。</p>
</section>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1677"><span id="calibre_link-237"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルサイズとタイムスタンプを調べる</span></h4>
<p class="tni">ファイルパスの扱い方がわかったので、ファイルやフォルダについての情報を集めてみましょう。<span class="thesansmonocd_w5regular_">stat()</span>メソッドは、ファイルサイズやタイムスタンプなどを含む<span class="thesansmonocd_w5regular_">stat_result</span>オブジェクトを返します。</p>
<p class="tx">例として、対話型シェルに以下の内容を入力して、Windowsの<i class="calibre5">calc.exe</i>について調べてみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">calc_file = Path('C:/Windows/System32/calc.exe')</b>
&gt;&gt;&gt; <b class="calibre10">calc_file.stat()</b>
os.stat_result(st_mode=33279, st_ino=562949956525418, st_dev=3739257218,
st_nlink=2, st_uid=0, st_gid=0, st_size=27648, st_atime=1678984560,
st_mtime=1575709787, st_ctime=1575709787)
&gt;&gt;&gt; <b class="calibre10">calc_file.stat().st_size</b>
27648
&gt;&gt;&gt; <b class="calibre10">calc_file.stat().st_mtime</b>
1712627129.0906117
&gt;&gt;&gt; <b class="calibre10">import time</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-934" aria-label="227"></span>&gt;&gt;&gt; <b class="calibre10">time.asctime(time.localtime(calc_file.stat().st_mtime))</b>
'Mon Apr  8 20:45:29 2024'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">stat()</span>メソッドで返される<span class="thesansmonocd_w5regular_">stat_result</span>オブジェクトの属性<span class="thesansmonocd_w5regular_">st_size</span>はファイルサイズのバイト数です。この数値を、<span class="thesansmonocd_w5regular_">1024</span>、<span class="thesansmonocd_w5regular_">1024 ** 2</span>、<span class="thesansmonocd_w5regular_">1024 ** 3</span>で割ればそれぞれKB、MB、GB単位になります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">st_mtime</span>は「最終更新」タイムスタンプです。例えば、<i class="calibre5">.docx</i>Wordファイルがいつ最後に変更されたかを知りたいときなどに使います。このタイムスタンプは、1970年1月1日からの経過秒数であるUnix時間です。<span class="thesansmonocd_w5regular_">time</span>モジュール（<span>第19章</span>で説明します）にはこの数値を人間にとって読みやすい形式に変換する関数があります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">stat_result</span>オブジェクトには便利な属性があります。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">st_size</span> ファイルのバイト単位でのサイズです。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">st_mtime</span> そのファイルが最後に変更された「最終更新」タイムスタンプです。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">st_ctime</span> 「作成」タイムスタンプです。Windowsではそのファイルが作成された日時です。macOSとLinuxではそのファイルのメタデータ（ファイル名など）が最後に変更された日時です。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">st_atime</span> そのファイルが最後に読み取られた「最終アクセス」タイムスタンプです。</p>
<p class="tx">更新、作成、アクセスのタイムスタンプは手動で変更することができるので、必ずしも正確とは限らないことに留意してください。</p>
</section>
<section type="division" aria-labelledby="sec11">
<h4 class="h1" id="calibre_link-1678"><span id="calibre_link-238"></span><span class="sans_futura_std_heavy_oblique_bi_">グロブパターンを利用してファイルを検索する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">*</span>と<span class="thesansmonocd_w5regular_">?</span>はフォルダ名やファイル名にマッチさせるのに使えます。<i class="calibre5">グロブパターン</i>と呼ばれます。グロブパターンは簡易的な正規表現のようなものです。<span class="thesansmonocd_w5regular_">*</span>はすべてのテキストにマッチし、<span class="thesansmonocd_w5regular_">?</span>は1文字にマッチします。以下の例を見てください。</p>
<p class="listplain"><span class="thesansmonocd_w5regular_">'*.txt'</span>は<i class="calibre5">.txt</i>で終わるすべてのファイルにマッチします。</p>
<p class="listplain"><span class="thesansmonocd_w5regular_">'project?.txt'</span>は<span class="thesansmonocd_w5regular_">'project1.txt'</span>や<span class="thesansmonocd_w5regular_">'project2.txt'</span>や<span class="thesansmonocd_w5regular_">'projectX.txt'</span>にマッチします。</p>
<p class="listplain"><span class="thesansmonocd_w5regular_">'*project?.*'</span>は<span class="thesansmonocd_w5regular_">'catproject5.txt'</span>や<span class="thesansmonocd_w5regular_">'secret_project7.docx'</span>にマッチします。</p>
<p class="listplain"><span class="thesansmonocd_w5regular_">'*'</span>はすべてのファイル名にマッチします。</p>
<p class="tx">フォルダの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトには、そのフォルダ内でグロブパターンにマッチするものを一覧で取得する<span class="thesansmonocd_w5regular_">glob()</span>メソッドがあります。<span class="thesansmonocd_w5regular_">glob()</span>メソッドはジェネレータオブジェクト（本書の範囲外です）を返すので、対話型シェルで確認するには<span class="thesansmonocd_w5regular_">list()</span>に渡す必要があります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">p = Path('C:/Users/Al/Desktop')</b>
&gt;&gt;&gt; <b class="calibre10">p.glob('*')</b>
&lt;generator object Path.glob at 0x000002A6E389DED0&gt;
&gt;&gt;&gt; <b class="calibre10">list(p.glob('*'))</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1112" aria-label="228"></span>[WindowsPath('C:/Users/Al/Desktop/1.png'), WindowsPath('C:/Users/Al/
Desktop/22-ap.pdf'), WindowsPath('C:/Users/Al/Desktop/cat.jpg'),
WindowsPath('C:/Users/Al/Desktop/zzz.txt')]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">glob()</span>が返すジェネレータオブジェクトを<span class="thesansmonocd_w5regular_">for</span>ループで使うこともできます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">for name in Path('C:/Users/Al/Desktop').glob('*')</b>:
&gt;&gt;&gt;     <b class="calibre10">print(name)</b>
C:\Users\Al\Desktop\1.png
C:\Users\Al\Desktop\22-ap.pdf
C:\Users\Al\Desktop\cat.jpg
C:\Users\Al\Desktop\zzz.txt
</code></pre>
<p class="tx">バックアップフォルダへのコピーや名前の変更など、フォルダ内のすべてのファイルに何らかの処理をする必要がある場合は、<span class="thesansmonocd_w5regular_">glob('*')</span>メソッドを呼び出せば<span class="thesansmonocd_w5regular_">Path</span>オブジェクト内のファイルとフォルダの一覧を取得できます。<span class="thesansmonocd_w5regular_">ls</span>や<span class="thesansmonocd_w5regular_">dir</span>などのコマンドラインのコマンドでもグロブパターンはよく使われます。<span>第12章</span>でコマンドラインについて詳しく説明します。</p>
</section>
<section type="division" aria-labelledby="sec12">
<h4 class="h1" id="calibre_link-1679"><span id="calibre_link-239"></span><span class="sans_futura_std_heavy_oblique_bi_">有効なパスかどうかをチェックする</span></h4>
<p class="tni">Pythonには、存在しないパスを渡すとエラーでクラッシュする関数がたくさんあります。幸い、<span class="thesansmonocd_w5regular_">Path</span>オブジェクトには、指定したパスが存在するかどうか、ファイルなのかフォルダなのかをチェックするメソッドがあります。<span class="thesansmonocd_w5regular_">p</span>が<span class="thesansmonocd_w5regular_">Path</span>オブジェクトだとすると、以下の挙動になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">p.exists()</span>を呼び出すと、そのパスが存在すれば<span class="thesansmonocd_w5regular_">True</span>を、存在しなければ<span class="thesansmonocd_w5regular_">False</span>を返します。</li>
<li class="bl"><span class="thesansmonocd_w5regular_">p.is_file()</span>を呼び出すと、そのパスが存在してかつファイルであれば<span class="thesansmonocd_w5regular_">True</span>を、そうでなければ<span class="thesansmonocd_w5regular_">False</span>を返します。</li>
<li class="bl"><span class="thesansmonocd_w5regular_">p.is_dir()</span>を呼び出すと、そのパスが存在してかつディレクトリであれば<span class="thesansmonocd_w5regular_">True</span>を、そうでなければ<span class="thesansmonocd_w5regular_">False</span>を返します。</li>
</ul>
<p class="tx">私のコンピュータの対話型シェルでこれらのメソッドを実行した結果を示します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">win_dir = Path('C:/Windows')</b>
&gt;&gt;&gt; <b class="calibre10">not_exists_dir = Path('C:/This/Folder/Does/Not/Exist')</b>
&gt;&gt;&gt; <b class="calibre10">calc_file_path = Path('C:/Windows</b>
<b class="calibre10">/System32/calc.exe')</b>
&gt;&gt;&gt; <b class="calibre10">win_dir.exists()</b>
True
&gt;&gt;&gt; <b class="calibre10">win_dir.is_dir()</b>
True
&gt;&gt;&gt; <b class="calibre10">not_exists_dir.exists()</b>
False
&gt;&gt;&gt; <b class="calibre10">calc_file_path.is_file()</b>
True
&gt;&gt;&gt; <b class="calibre10">calc_file_path.is_dir()</b>
False
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-965" aria-label="229"></span><span class="thesansmonocd_w5regular_">exists()</span>メソッドでDVDやUSBドライブが取り付けられているかどうかを判定することができます。例えば、私のWindowsマシンに<i class="calibre5">D:\</i>という名前のUSBドライブのボリュームがあるかどうかを確認したければ、次のようにします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">d_drive = Path('D:/')</b>
&gt;&gt;&gt; <b class="calibre10">d_drive.exists()</b>
False
</code></pre>
<p class="tx">おっと、USBドライブを差し込むのを忘れていたようです。</p>
<p class="tx">古い<span class="thesansmonocd_w5regular_">os.path</span>モジュールの<span class="thesansmonocd_w5regular_">os.path.exists(</span><span class="sans_thesansmonocd_w5regular_italic_">path</span><span class="thesansmonocd_w5regular_">)</span>、<span class="thesansmonocd_w5regular_">os.path.isfile(</span><span class="sans_thesansmonocd_w5regular_italic_">path</span><span class="thesansmonocd_w5regular_">)</span>、<span class="thesansmonocd_w5regular_">os.path.isdir(</span><span class="sans_thesansmonocd_w5regular_italic_">path</span><span class="thesansmonocd_w5regular_">)</span>関数でも、<span class="thesansmonocd_w5regular_">Path</span>関数と同じことができます。Python3.6以降では、これらの関数が、ファイルパスの文字列だけでなく<span class="thesansmonocd_w5regular_">Path</span>オブジェクトも取ることができるようになりました。</p>
</section>
</section>
<section type="division" aria-labelledby="sec13">
<h3 class="h" id="calibre_link-1680"><span id="calibre_link-240"></span><span class="sans_futura_std_bold_b_">ファイルの読み書き</span></h3>
<p class="tni">フォルダと相対パスに慣れると、読み書きするファイルの場所を指定することができます。以下の数節ではプレーンテキストファイルに適用する関数を紹介します。<i class="calibre5">プレーンテキストファイル</i>は基本的なテキスト文字だけを含み、フォント、サイズ、色などの情報は含みません。<i class="calibre5">.txt</i>拡張子のテキストファイルや<i class="calibre5">.py</i>拡張子のPythonスクリプトファイルはプレーンテキストファイルです。れらのファイルはWindowsのメモ帳やmacOSのTextEditアプリケーションで開くことができ、プログラムから開いて内容を読み取って通常の文字列値のように扱うことが簡単にできます。</p>
<p class="tx">ワープロソフトのファイル、PDF、画像、スプレッドシート、実行ファイルなど、その他のファイルはすべて<i class="calibre5">バイナリファイル</i>です。バイナリファイルをメモ帳やTextEditで開くと、図10-5のようにぐちゃぐちゃで判読できません。</p>
<figure class="img"><img class="img1" id="calibre_link-735" src="images/000009.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 10-5：Windowsの</span><span class="sans_futura_std_book_">calc.exe</span><span class="sans_futura_std_book_oblique_i_">プログラムをメモ帳で開いた状態</span></p></figcaption>
</figure>
<p class="tni"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1027" aria-label="230"></span>バイナリファイルはそのファイル固有の方法で処理しなければならず、本書では生のバイナリファイルを直接読み書きする方法は扱いません。バイナリファイルを扱いやすくしてくれるモジュールはたくさんあります。本章の後半では、その中の一つである<span class="thesansmonocd_w5regular_">shelve</span>モジュールを紹介します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">pathlib</span>モジュールの<span class="thesansmonocd_w5regular_">read_text()</span>メソッドは、テキストファイルの内容全体を一つの文字列として返します。<span class="thesansmonocd_w5regular_">write_text()</span>メソッドは渡した文字列が書かれた新しいテキストファイルを作成します（あるいは既存のファイルを上書きします）。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">p = Path('spam.txt')</b>
&gt;&gt;&gt; <b class="calibre10">p.write_text('Hello, world!')</b>
13
&gt;&gt;&gt; <b class="calibre10">p.read_text()</b>
'Hello, world!'
</code></pre>
<p class="tx">このメソッドを呼び出すと、<span class="thesansmonocd_w5regular_">'Hello, world!'</span>という内容の<i class="calibre5">spam.txt</i>というファイルを作成します。<span class="thesansmonocd_w5regular_">write_text()</span>が返す<span class="thesansmonocd_w5regular_">13</span>は、ファイルに13文字書き込まれたことを示します（この返り値は無視して差し支えありません）。<span class="thesansmonocd_w5regular_">read_text()</span>を呼び出すとそのファイルの中身を読み取り、一つの文字列<span class="thesansmonocd_w5regular_">'Hello, world!'</span>として返します。</p>
<p class="tx">これらの<span class="thesansmonocd_w5regular_">Path</span>オブジェクトメソッドは、ファイルの基本的な読み書きしかサポートしていません。ファイルに書き込むには、<span class="thesansmonocd_w5regular_">open()</span>関数を使ってファイルオブジェクトを操作するほうが一般的です。以下の3ステップでPythonでのファイルの読み書きができます。</p>
<p class="listnumberf">  1. <span class="thesansmonocd_w5regular_">open()</span>関数を呼び出して<span class="thesansmonocd_w5regular_">File</span>オブジェクトを取得します。</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">File</span>オブジェクトについて<span class="thesansmonocd_w5regular_">read()</span>メソッドまたは<span class="thesansmonocd_w5regular_">write()</span>メソッドを呼び出します。</p>
<p class="listnumberl">  3. <span class="thesansmonocd_w5regular_">File</span>オブジェクトについて<span class="thesansmonocd_w5regular_">close()</span>メソッドを呼び出してファイルを閉じます。</p>
<p class="tx">以下の節ではこのステップを実践します。</p>
<p class="tx">ファイルを操作するときには、ファイル拡張子（<i class="calibre5">.txt</i>、.<i class="calibre5">pdf</i>、.<i class="calibre5">jpg</i>など）を素早く確認できると便利です。WindowsとmacOSでは、ファイル拡張子がデフォルトでは非表示になっていることがあります。その場合は、<i class="calibre5">spam.txt</i>と表示されずに<i class="calibre5">spam</i>と表示されます。拡張子を表示するには、Windowsではファイルエクスプローラーの設定を開き、「ファイル名拡張子」のような欄にチェックを入れてください。macOSでは、Finderの設定を開き、「すべてのファイル名拡張子を表示」のような欄にチェックを入れてください。（この設定の場所や文言はOSのバージョンによって微妙に異なります。）</p>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1681"><span id="calibre_link-241"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルを開く</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">open()</span>関数に開きたいファイルのパスを渡すとそのファイルを開くことができます。絶対パスでも相対パスでも構いません。<span class="thesansmonocd_w5regular_">open()</span>関数は<span class="thesansmonocd_w5regular_">File</span>オブジェクトを返します。</p>
<p class="tx">メモ帳やTextEditを使って<i class="calibre5">hello.txt</i>という名前のテキストファイルを作ってください。そのテキストファイルに<b class="calibre10">Hello, world!</b>と入力して、ホームフォルダに保存してください。それから以下の対話型シェルの内容を実行してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">hello_file = open(Path.home() / 'hello.txt', encoding='UTF-8')</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1068" aria-label="231"></span><span class="thesansmonocd_w5regular_">open()</span>関数は指定したファイルを「プレーンテキスト読み取り」モード（「読み取り」モード）で開きます。ファイルを読み取りモードで開くと、そのファイルのデータを読み取ることはできますが、書き込んだり変更したりすることはできません。Pythonでファイルを開くときのデフォルトは読み取りモードです。デフォルトに頼らず<span class="thesansmonocd_w5regular_">open()</span>関数の第二引数に<span class="thesansmonocd_w5regular_">'r'</span>という文字列を渡して明示的にモードを指定することもできます。例えば、<span class="thesansmonocd_w5regular_">open('/Users/Al/hello.txt', 'r')</span>は<span class="thesansmonocd_w5regular_">open('/Users/Al/hello.txt')</span>と同じです。</p>
<p class="tx">名前付きパラメータ<span class="thesansmonocd_w5regular_">encoding</span>では、ファイルのバイトをPythonのテキスト文字列に変換するときのエンコーディングを指定します。macOSやLinuxでデフォルトとして用いられている<span class="thesansmonocd_w5regular_">'utf-8'</span>を指定すればほぼ間違いないです（macOSやLinuxではエンコーディングを指定しなくてもデフォルトのUTF-8が用いられますが、後述のようにWindowsではデフォルトで別のエンコーディングが用いられます）。しかし、Windowsでは<span class="thesansmonocd_w5regular_">'cp1252'</span>（<i class="calibre5">拡張ASCII</i>）をデフォルトのエンコーディングとして用いているので、非英語文字のUTF-8でエンコードされたテキストをWindowsで読み取ろうとすると問題が発生するかもしれません。ですので、プレーンテキストファイルの読み書き追記モードでファイルを開く際には<span class="thesansmonocd_w5regular_">open()</span>関数呼び出しに<span class="thesansmonocd_w5regular_">encoding='utf-8'</span>を渡す習慣をつけるとよいです。（訳注：日本語のWindowsでは<span class="thesansmonocd_w5regular_">'cp1252'</span>ではなく<span class="thesansmonocd_w5regular_">'cp932'</span>をデフォルトのエンコーディングとして用いていますが、デフォルトがUTF-8でないことに変わりはないので、関数呼び出しに<span class="thesansmonocd_w5regular_">encoding='utf-8'</span>を渡す習慣をつけるとよいことに変わりはありません。エンコーディングは常にUTF-8で統一すると間違いが少なくなります。）バイナリの読み書き追記モードには<span class="thesansmonocd_w5regular_">encoding</span>という名前付きパラメータはありません。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">open()</span>を呼び出すと<span class="thesansmonocd_w5regular_">File</span>オブジェクトが返されます。<span class="thesansmonocd_w5regular_">File</span>オブジェクトはコンピュータ上のファイルを表しています。すでにおなじみのリストや辞書と同じようなPythonの型の一つです。先の例では、<span class="thesansmonocd_w5regular_">File</span>オブジェクトを変数<span class="thesansmonocd_w5regular_">hello_file</span>に格納しました。ファイルの読み書きをするときは、<span class="thesansmonocd_w5regular_">hello_file</span>に格納されている<span class="thesansmonocd_w5regular_">File</span>オブジェクトのメソッドを呼び出します。</p>
</section>
<section type="division" aria-labelledby="sec15">
<h4 class="h1" id="calibre_link-1682"><span id="calibre_link-242"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルの内容を読み取る</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">File</span>オブジェクトがあれば、その内容を読み取れます。ファイルの中身全体を一つの文字列として読み取るなら、<span class="thesansmonocd_w5regular_">File</span>オブジェクトの<span class="thesansmonocd_w5regular_">read()</span>メソッドを使います。<span class="thesansmonocd_w5regular_">hello_file</span>に格納した<i class="calibre5">hello.txt</i>の<span class="thesansmonocd_w5regular_">File</span>オブジェクトの例を続けましょう。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">hello_content = hello_file.read()</b>
&gt;&gt;&gt; <b class="calibre10">hello_content</b>
'Hello, world!'
</code></pre>
<p class="tx">ファイルの中身は一つの大きな文字列値だと考えられます。<span class="thesansmonocd_w5regular_">read()</span>メソッドはそのファイルに保存されている文字列を返します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">readlines()</span>メソッドを使うと、ファイルから、一つの大きな文字列値ではなく、各行の文字列値の<i class="calibre5">リスト</i>を取得できます。例えば、<i class="calibre5">hello.txt</i>と同じディレクトリ内に<i class="calibre5">sonnet29.txt</i>という名前のファイルを作成し、以下の内容を貼り付けてください。</p>
<pre class="pre"><code class="calibre9">When, in disgrace with fortune and men's eyes,
I all alone beweep my outcast state,
And trouble deaf heaven with my bootless cries,
And look upon myself and curse my fate,
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-919" aria-label="232"></span>4つの行を改行で区切ってください。そして、対話型シェルに次のように入力します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">sonnet_file = open(Path.home() / 'sonnet29.txt', encoding='UTF-8')</b>
&gt;&gt;&gt; <b class="calibre10">sonnet_file.readlines()</b>
["When, in disgrace with fortune and men's eyes,\n", 'I all alone beweep
my outcast state,\n', 'And trouble deaf heaven with my bootless cries,\n',
'And look upon myself and curse my fate,']
</code></pre>
<p class="tx">最終行以外は改行文字<span class="thesansmonocd_w5regular_">\n</span>が文字列の最後にあります。一つの大きな文字列値よりも文字列のリストのほうが扱いやすい場合が多いです。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h4 class="h1" id="calibre_link-1683"><span id="calibre_link-243"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルへの書き込み</span></h4>
<p class="tni">Pythonでは、<span class="thesansmonocd_w5regular_">print()</span>関数が画面に文字列を書き込むのと同じように、ファイルに書き込むことができます。読み取りモードでファイルを開くと書き込みはできません。「プレーンテキスト書き込み」モード（「書き込み」モード）または「プレーンテキスト追記」モード（「追記」モード）でファイルを開く必要があります。</p>
<p class="tx">書き込みモードでは既存のファイルを上書きします。変数の値を新しい値で上書きするのと似ています。<span class="thesansmonocd_w5regular_">open()</span>の第二引数に<span class="thesansmonocd_w5regular_">'w'</span>を渡すと書き込みモードになります。追記モードは、既存のファイルの末尾にテキストを追記します。変数を上書きするのではなく変数に格納されているリストに値を追加するのと似ています。<span class="thesansmonocd_w5regular_">open()</span>の第二引数に<span class="thesansmonocd_w5regular_">'a'</span>を渡すと追記モードになります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">open()</span>に渡された名前のファイルが存在しなければ、書き込みモードと追記モードでは新しいファイルを作成します。ファイルの読み書きが終われば、再びファイルを開く前に<span class="thesansmonocd_w5regular_">close()</span>メソッドを呼び出してください。</p>
<p class="tx">一連の流れを試してみましょう。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">bacon_file = open('bacon.txt', 'w', encoding='UTF-8')   </b>
&gt;&gt;&gt; <b class="calibre10">bacon_file.write('Hello, world!\n')</b>
14
&gt;&gt;&gt; <b class="calibre10">bacon_file.close()</b>
&gt;&gt;&gt; <b class="calibre10">bacon_file = open('bacon.txt', 'a', encoding='UTF-8') </b>
&gt;&gt;&gt; <b class="calibre10">bacon_file.write('Bacon is not a vegetable.')</b>
25
&gt;&gt;&gt; <b class="calibre10">bacon_file.close()</b>
&gt;&gt;&gt; <b class="calibre10">bacon_file = open('bacon.txt', encoding='UTF-8')</b>
&gt;&gt;&gt; <b class="calibre10">content = bacon_file.read()</b>
&gt;&gt;&gt; <b class="calibre10">bacon_file.close()</b>
&gt;&gt;&gt; <b class="calibre10">print(content)</b>
Hello, world!
Bacon is not a vegetable.
</code></pre>
<p class="tx">まず、<i class="calibre5">bacon.txt</i>を書き込みモードで開いています。<i class="calibre5">bacon.txt</i>ファイルはまだ存在しませんから、Pythonがそのファイルを作成します。開いたファイルについて<span class="thesansmonocd_w5regular_">write()</span>メソッドを呼び出し、<span class="thesansmonocd_w5regular_">write()</span> に<span class="thesansmonocd_w5regular_">'Hello, world!\n'</span>という文字列引数を渡しているので、その文字列がファイルに書き込まれ、改行文字を含めて書き込んだ文字数が返されます。それからそのファイルを閉じています。</p>
<p class="tx">先ほど書き込んだ文字列のファイルを上書きするのではなく追記するために、そのファイルを追記モードで開いています。そのファイルに<span class="thesansmonocd_w5regular_">'Bacon is not a vegetable.'</span>と書き込んで閉じています。最後に、ファイルの内容を画面に表示するために、そのファイルをデフォルトの読み取りモードで開き、<span class="thesansmonocd_w5regular_">read()</span>を呼び出して、<span class="thesansmonocd_w5regular_">File</span>オブジェクトを<span class="thesansmonocd_w5regular_">content</span>に格納してからそのファイルを閉じ、<span class="thesansmonocd_w5regular_">content</span>を出力しています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">write()</span>メソッドは文字列の終わりに改行を自動的に追加しないことに注意してください。改行を自動的に追加する<span class="thesansmonocd_w5regular_">print()</span>関数とは異なり、自分で改行文字を入れなければなりません。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">open()</span>関数にはファイル名の文字列の代わりに<span class="thesansmonocd_w5regular_">Path</span>オブジェクトを渡すこともできます。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h4 class="h1" id="calibre_link-1684"><span id="calibre_link-244"></span><span class="sans_futura_std_heavy_oblique_bi_">with文</span></h4>
<p class="tni">プログラムから<span class="thesansmonocd_w5regular_">open()</span>を呼び出して開いたファイルはすべて<span class="thesansmonocd_w5regular_">close()</span>を呼び出して閉じなければなりません。<span class="thesansmonocd_w5regular_">close()</span>関数を入れ忘れることもあれば、状況によってはプログラムが<span class="thesansmonocd_w5regular_">close()</span>呼び出しを飛ばしてしまうこともあります。</p>
<p class="tx">Pythonの<span class="thesansmonocd_w5regular_">with</span> 文を使うと自動的にファイルを閉じてくれます。<span class="thesansmonocd_w5regular_">with</span>文は、Pythonがリソース管理に利用する<i class="calibre5">コンテキストマネージャ</i>を作成します。ファイル、ネットワーク接続、メモリのセグメントなどのリソースには、たいてい、プログラムから利用するために割り当てて解放する、開始段階と終了段階があります（<span class="thesansmonocd_w5regular_">with</span>文はファイルを開くときに使うことが多いでしょう）。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">with</span>文では、リソースの割り当て時にコードブロックを追加し、プログラム実行がコードブロックを抜けたときにリソースを解放します。<span class="thesansmonocd_w5regular_">return</span>文や処理されない例外が送出されたときなどにコードブロックを抜けてリソースが解放されます。</p>
<p class="tx">以下はファイルに書き込んでからその内容を読み取る典型的なコードです。</p>
<pre class="pre"><code class="calibre9">file_obj = open('data.txt', 'w', encoding='utf-8')
file_obj.write('Hello, world!')
file_obj.close()
file_obj = open('data.txt', encoding='utf-8')
content = file_obj.read()
file_obj.close()
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">with</span>文を使うとこうなります。</p>
<pre class="pre"><code class="calibre9">with open('data.txt', 'w', encoding='UTF-8') as file_obj:
    file_obj.write('Hello, world!')
with open('data.txt', encoding='UTF-8') as file_obj:
    content = file_obj.read()
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">with</span>文の例では、プログラム実行がブロックを抜けたときに<span class="thesansmonocd_w5regular_">with</span>文が自動的に呼び出してくれるので、<span class="thesansmonocd_w5regular_">close()</span>を呼び出していないことに注意してください。<span class="thesansmonocd_w5regular_">with</span>文は<span class="thesansmonocd_w5regular_">open()</span>関数から取得したコンテキストマネージャに基づいて動作します。コンテキストマネージャを自分で作成するのは本書の範囲外ですが、オンラインドキュメントの<i class="calibre5"><a href="https://docs.python.org/3/reference/datamodel.html#context-managers" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/reference<wbr></wbr>/datamodel<wbr></wbr>.html#context<wbr></wbr>-managers</a></i>やJulien Danjouの<i class="calibre5">Serious Python</i>(No Starch Press, 2018)という本で学習できます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec18">
<h3 class="h" id="calibre_link-1685"><span id="calibre_link-245"></span><span class="sans_futura_std_bold_b_">shelveモジュールで変数を保存する</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">shelve</span>モジュールを使うと、Pythonプログラム中の変数をバイナリ形式のshelfファイルに保存できます。そうすると別のプログラムを実行する際に保存したデータを復元できます。これによりプログラムに保存して開く機能を備えられます。例えば、プログラムを実行して何らかの設定を入力したとして、その設定をshelfファイルに保存し、次回実行時に読み込むことができます。</p>
<p class="tx">対話型シェルに次の内容を入力して、<span class="thesansmonocd_w5regular_">shelve</span>を使う練習をしてみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import shelve</b>
&gt;&gt;&gt; <b class="calibre10">shelf_file = shelve.open('mydata')</b>

&gt;&gt;&gt; <b class="calibre10">shelf_file['cats'] = ['Zophie', 'Pooka', 'Simon']</b>
&gt;&gt;&gt; <b class="calibre10">shelf_file.close()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">shelve</span>モジュールでデータの読み書きをするには、最初に<span class="thesansmonocd_w5regular_">shelve</span>をインポートします。次に、ファイル名を渡して<span class="thesansmonocd_w5regular_">shelve.open()</span>を呼び出し、その返り値を変数に格納します。shelf値は辞書のように変更できます。変更が終わればshelf値について<span class="thesansmonocd_w5regular_">close()</span>を呼び出します。これでshelf値が<span class="thesansmonocd_w5regular_">shelf_file</span>に保存されます。上記のプログラムでは、リスト<span class="thesansmonocd_w5regular_">cats</span>を作成し、<span class="thesansmonocd_w5regular_">shelf_file['cats']</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">['Zophie', 'Pooka', 'Simon']</span>と書いてそのリストを（辞書のように）<span class="thesansmonocd_w5regular_">'cats'</span>というキーの値として<span class="thesansmonocd_w5regular_">shelf_file</span>に格納し、<span class="thesansmonocd_w5regular_">shelf_file</span>について<span class="thesansmonocd_w5regular_">close()</span>を呼び出しています。</p>
<p class="tx">Windowsでこのコードを実行すると、現在の作業ディレクトリに<i class="calibre5">mydata.bak</i>、<i class="calibre5">mydata.dat</i>、<i class="calibre5">mydata.dir</i>の3つの新しいファイルが見えるはずです。macOSでは、<i class="calibre5">mydata.db</i>という1ファイルが、Linuxでは<i class="calibre5">mydata</i>という1ファイルが見えるはずです。これらのバイナリファイルに保存したデータが含まれています。これらのバイナリファイルの形式は重要ではありません。<span class="thesansmonocd_w5regular_">shelve</span>モジュールが何をしているかがわかればよいのであって、どのようにしているのかを知る必要はありません。プログラムのデータをどのようにしてファイルに保存するかはモジュールが面倒を見てくれます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">shelve</span>モジュールを使うと、あとでshelfファイルを再び開いてデータを取得できます。shelf値には読み取りや書き込みといったモードは存在せず、開けば読み書きできます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">shelf_file = shelve.open('mydata')</b>
&gt;&gt;&gt; <b class="calibre10">type(shelf_file) </b>
&lt;class 'shelve.DbfilenameShelf'&gt;
&gt;&gt;&gt; <b class="calibre10">shelf_file['cats']</b>
['Zophie', 'Pooka', 'Simon']
&gt;&gt;&gt; <b class="calibre10">shelf_file.close()</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1172" aria-label="235"></span>shelfファイルを開いてデータが正しく保存されるかを確かめます。<span class="thesansmonocd_w5regular_">shelf_file['cats']</span>が先に作成したのと同じリストを返しています。リストが正しく保存されていることがわかったので、<span class="thesansmonocd_w5regular_">close()</span>を呼び出します。</p>
<p class="tx">辞書と同様に、shelf値には<span class="thesansmonocd_w5regular_">keys()</span>メソッドと<span class="thesansmonocd_w5regular_">values()</span>メソッドがあります。shelfのキーと値をリストのような値で返します。これらの返り値は本物のリストではありませんから、リスト形式にするには<span class="thesansmonocd_w5regular_">list()</span>関数に渡します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">shelf_file = shelve.open('mydata')</b>
&gt;&gt;&gt; <b class="calibre10">list(shelf_file.keys())</b>
['cats']
&gt;&gt;&gt; <b class="calibre10">list(shelf_file.values())</b>
[['Zophie', 'Pooka', 'Simon']]
&gt;&gt;&gt; <b class="calibre10">shelf_file.close()</b>
</code></pre>
<p class="tx">プレーンテキストはメモ帳やTextEditのようなテキストエディタで読めるファイルを作成できますが、Pythonプログラムのデータを保存したい場合には<span class="thesansmonocd_w5regular_">shelve</span>モジュールが使えます。</p>
<p class="ph"><span id="calibre_link-246"></span><span class="sans_futura_std_heavy_b_">プロジェクト4：ランダムな設問ファイルの生成</span></p>
<p class="tni">35人の生徒がいるクラスの地理の先生が、アメリカ合衆国の州都のテストの設問を作ろうとしているとします。悪い生徒がいてカンニングするかもしれません。設問の順番をランダムにしてそれぞれ違うようにして、カンニングできないようにしたいです。これを手で行うのは大変で退屈な作業です。ここでPythonを活用します。</p>
<p class="tx">このプログラムには以下の内容が必要です。</p>
<ul class="ul">
<li class="bl">35人分の設問を作成する</li>
<li class="bl">1人分につき50問の選択式の設問をランダムな順番で作成する</li>
<li class="bl">1つの正解と3つの不正解の選択肢をランダムな順番で用意する</li>
<li class="bl">設問を35個のファイルに書き込む</li>
<li class="bl">正解を35個のファイルに書き込む</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl">州と州都を辞書形式で保存する</li>
<li class="bl">設問テキストと解答テキストについて<span class="thesansmonocd_w5regular_">open()</span>、<span class="thesansmonocd_w5regular_">write()</span>、<span class="thesansmonocd_w5regular_">close()</span>を呼び出す</li>
<li class="bl">設問と選択肢の順番を<span class="thesansmonocd_w5regular_">random.shuffle()</span>でランダムにする</li>
</ul>
<p class="tx">それでは始めましょう。</p>
<section type="division" aria-labelledby="sec19">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1280" aria-label="236"></span>
<h4 class="h1" id="calibre_link-1686"><span id="calibre_link-247"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：設問のデータを辞書形式で保存する</span></h4>
<p class="tni">まず骨組みのスクリプトを作成して、設問のデータを用意します。次のコードを<i class="calibre5">randomQuizGenerator.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9"># randomQuizGenerator.py - 設問と選択肢を
# ランダムな順番で作成し、解答ファイルも作成する

<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> import random

# キーが州で値が州都の設問データ
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> capitals = {'Alabama': 'Montgomery', 'Alaska': 'Juneau', 'Arizona':
'Phoenix', 'Arkansas': 'Little Rock', 'California': 'Sacramento', 'Colorado':
'Denver', 'Connecticut': 'Hartford', 'Delaware': 'Dover', 'Florida':
'Tallahassee', 'Georgia': 'Atlanta', 'Hawaii': 'Honolulu', 'Idaho': 'Boise',
'Illinois': 'Springfield', 'Indiana': 'Indianapolis', 'Iowa': 'Des Moines',
'Kansas': 'Topeka', 'Kentucky': 'Frankfort', 'Louisiana': 'Baton Rouge',
'Maine': 'Augusta', 'Maryland': 'Annapolis', 'Massachusetts': 'Boston',
'Michigan': 'Lansing', 'Minnesota': 'Saint Paul', 'Mississippi': 'Jackson',
'Missouri': 'Jefferson City', 'Montana': 'Helena', 'Nebraska': 'Lincoln',
'Nevada': 'Carson City', 'New Hampshire': 'Concord', 'New Jersey': 'Trenton',
'New Mexico': 'Santa Fe', 'New York': 'Albany', 'North Carolina': 'Raleigh',
'North Dakota': 'Bismarck', 'Ohio': 'Columbus', 'Oklahoma': 'Oklahoma City',
'Oregon': 'Salem', 'Pennsylvania': 'Harrisburg', 'Rhode Island': 'Providence',
'South Carolina': 'Columbia', 'South Dakota': 'Pierre', 'Tennessee':
'Nashville', 'Texas': 'Austin', 'Utah': 'Salt Lake City', 'Vermont':
'Montpelier', 'Virginia': 'Richmond', 'Washington': 'Olympia', 'West
Virginia':'Charleston', 'Wisconsin': 'Madison', 'Wyoming': 'Cheyenne'}

# 35人分の設問を作成
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> for quiz_num in range(35):
    # TODO：設問ファイルと解答ファイルを作成

    # TODO：設問のヘッダーを書き込み

    # TODO：州の順番をシャッフル

    # TODO：50の州をループして各設問を作成
</code></pre>
<p class="tx">このプログラムは設問と選択肢の順番をランダムにしますから、<span class="thesansmonocd_w5regular_">random</span>モジュールの関数を使えるようにインポートします(<span class="codeannotation" aria-label="annotation1">❶</span>)。変数<span class="thesansmonocd_w5regular_">capitals</span>はアメリカ合衆国の州をキー、州都の値とする辞書です(<span class="codeannotation" aria-label="annotation2">❷</span>)。35人分の設問を作成しますから、このコードでは、35回ループする<span class="thesansmonocd_w5regular_">for</span>ループ内で35の設問ファイルと解答ファイルを作成します(<span class="codeannotation" aria-label="annotation3">❸</span>)。今のところは<span class="thesansmonocd_w5regular_">TODO</span>コメントを入れています。この数値を変えれば作成するファイル数を変えられます。</p>
</section>
<section type="division" aria-labelledby="sec20">
<h4 class="h1" id="calibre_link-1687"><span id="calibre_link-248"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：設問ファイルの作成</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">TODO</span>の部分を埋めていきましょう。</p>
<p class="tx">ループ内のコードは35回実行され、1回のループで1つの設問ファイルを作成します。よって、ループ内では1つの設問ファイルを作成することに集中します。まず、設問ファイルを作成します。固有のファイル名と共通のヘッダー部分（生徒名、日付、授業時間の欄）が必要になります。次に、ランダムな順番の州のリストが必要です。これを使って設問と解答を作成します。</p>
<p class="tx">次の内容を<i class="calibre5">randomQuizGenerator.py</i>に追加してください。</p>
<pre class="pre"><code class="calibre9"># randomQuizGenerator.py - 設問と選択肢を
# ランダムな順番で作成し、解答ファイルも作成する

<var class="calibre20">--snip--</var>

# 35人分の設問を作成
for quiz_num in range(35):
    # 設問ファイルと解答ファイルを作成
    <b class="calibre10">quiz_file = open(f'capitalsquiz{quiz_num + 1}.txt', 'w', encoding='UTF-8')</b> <span class="code_codeannotation" aria-label="annotation1">❶</span>
    <b class="calibre10">answer_file = open(f'capitalsquiz_answers{quiz_num + 1}.txt', 'w', encoding='UTF-8')</b> <span class="code_codeannotation" aria-label="annotation2">❷</span>

    # 設問のヘッダーを書き込み
    <b class="calibre10">quiz_file.write('Name:\n\nDate:\n\nPeriod:\n\n')</b> <span class="code_codeannotation" aria-label="annotation3">❸</span>
    <b class="calibre10">quiz_file.write((' ' * 20) + f'State Capitals Quiz (Form{quiz_num + 1})')</b>
    <b class="calibre10">quiz_file.write('\n\n')</b>

    # 州の順番をシャッフル
<b class="calibre10">    states = list(capitals.keys())</b>
    <b class="calibre10">random.shuffle(states)</b> <span class="code_codeannotation" aria-label="annotation4">❹</span>

    # TODO：50の州をループして各設問を作成
</code></pre>
<p class="tx">設問は<i class="calibre5">capitalsquiz&lt;N&gt;.txt</i>というファイル名にします。<i class="calibre5">&lt;N&gt;</i>は<span class="thesansmonocd_w5regular_">for</span>ループのカウンター<span class="thesansmonocd_w5regular_">quiz_num</span>に由来する固有の番号です。<i class="calibre5">capitalsquiz&lt;N&gt;.txt</i>という設問ファイルに対応する解答は<i class="calibre5">capitalsquiz_answers&lt;N&gt;.txt</i>というファイル名にします。ループの反復ごとに、ファイル名中の<span class="thesansmonocd_w5regular_">{quiz _num</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">1}</span>というプレースホルダーを固有の番号で置き換えます。例えば、最初の設問ファイルと解答ファイルは、<i class="calibre5">capitalsquiz1.txt</i>と<i class="calibre5">capitalsquiz _answers1.txt</i>になります。書き込みモードでファイルを開くために<span class="thesansmonocd_w5regular_">open()</span>関数の第二引数に <span class="thesansmonocd_w5regular_">'w'</span>を渡して呼び出してこれらのファイルを作成します(<span class="codeannotation" aria-label="annotation1">❶</span><span class="codeannotation" aria-label="annotation2">❷</span>)。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">write()</span>文で生徒が埋める設問のヘッダー部分を作成します(<span class="codeannotation" aria-label="annotation3">❸</span>)。最後に、<span class="thesansmonocd_w5regular_">random.shuffle()</span>関数を利用してランダムな順番に並べたアメリカ合衆国の州のリストを取得します(<span class="codeannotation" aria-label="annotation4">❹</span>)。</p>
</section>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1689"><span id="calibre_link-249"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：選択肢を作成する</span></h4>
<p class="tni">次は別の<span class="thesansmonocd_w5regular_">for</span>ループで各設問に対するAからDの選択肢を作成します。あとで入れ子の<span class="thesansmonocd_w5regular_">for</span>ループで選択肢をファイルに書き込みます。コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># randomQuizGenerator.py - 設問と選択肢を
# ランダムな順番で作成し、解答ファイルも作成する

<var class="calibre20">--snip--</var>

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1690" aria-label="238"></span>    # 50の州をループして各設問を作成
<b class="calibre10">    for num in range(50):</b>

        # 正解と不正解を取得
<b class="calibre10">        correct_answer = capitals[states[num]]</b>
<b class="calibre10">        wrong_answers = list(capitals.values())</b>
<b class="calibre10">        del wrong_answers[wrong_answers.index(correct_answer)]</b>
<b class="calibre10">        wrong_answers = random.sample(wrong_answers, 3)</b>
<b class="calibre10">        answer_options = wrong_answers + [correct_answer]</b>
<b class="calibre10">        random.shuffle(answer_options)</b>

        # TODO：設問と選択肢を設問ファイルに書き込み

        # TODO：解答ファイルの書き込み
</code></pre>
<p class="tx">正解を作成するのは簡単です。辞書<span class="thesansmonocd_w5regular_">capitals</span>の値に格納されています。このループではシャッフルされたリスト<span class="thesansmonocd_w5regular_">states</span>の州を反復処理し、<span class="thesansmonocd_w5regular_">capitals</span>から州を探し、その州の州都を<span class="thesansmonocd_w5regular_">correct_answer</span>に格納します。</p>
<p class="tx">不正解の選択肢のリストを作成するのは少しややこしいです。辞書<span class="thesansmonocd_w5regular_">capitals</span>の値を複製して、正解を削除し、<span class="thesansmonocd_w5regular_">random.sample()</span>関数を使ってリストから3つの値をランダムに選びます。第一引数がリスト、第二引数が取得する個数です。これら3つの不正解の選択肢と正解の選択肢を結合して選択肢のリストを作成します。最後に、正解が常にDになってしまわないように、この選択肢の順番をランダムに並べ替えます。</p>
</section>
<section type="division" aria-labelledby="sec22">
<h4 class="h1" id="calibre_link-1691"><span id="calibre_link-250"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ4：ファイルへの書き込み</span></h4>
<p class="tni">あとは設問と解答をファイルに書き込みます。コードは次のようになります。</p>
<pre class="pre"><code class="calibre9"># randomQuizGenerator.py - 設問と選択肢を
# ランダムな順番で作成し、解答ファイルも作成する

<var class="calibre20">--snip--</var>

    # 50の州をループして各設問を作成
    for num in range(50):
        <var class="calibre20">--snip--</var>

        # 設問と選択肢を設問ファイルに書き込み
        <b class="calibre10">quiz_file.write(f'{num + 1}. Capital of {states[num]}:\n')</b>
        <span class="code_codeannotation" aria-label="annotation1">❶</span> <b class="calibre10">for i in range(4):</b>
            <span class="code_codeannotation" aria-label="annotation2">❷</span> <b class="calibre10">quiz_file.write(f"    {'ABCD'[i]}. {answer_options[i]}\n") </b>
        <b class="calibre10">quiz_file.write('\n')</b>

        # 解答ファイルの書き込み
        <span class="code_codeannotation" aria-label="annotation3">❸</span> <b class="calibre10">answer_file.write(f"{num + 1}.{'ABCD'[answer_options.index(correct_answer)]}\n")</b>
    <b class="calibre10">quiz_file.close()</b>
    <b class="calibre10">answer_file.close()</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1692" aria-label="239"></span><span class="thesansmonocd_w5regular_">for</span>ループは、<span class="thesansmonocd_w5regular_">answer_options</span>リストの選択肢を<span class="thesansmonocd_w5regular_">0</span>から<span class="thesansmonocd_w5regular_">3</span>まで反復処理してファイルに書き込みます(<span class="codeannotation" aria-label="annotation1">❶</span>)。<span class="thesansmonocd_w5regular_">'ABCD'[i]</span>の部分では、文字列<span class="thesansmonocd_w5regular_">'ABCD'</span>を配列として扱い、ループの反復ごとに<span class="thesansmonocd_w5regular_">'A'</span>、<span class="thesansmonocd_w5regular_">'B'</span>、<span class="thesansmonocd_w5regular_">'C'</span>、<span class="thesansmonocd_w5regular_">'D'</span>と評価します(<span class="codeannotation" aria-label="annotation2">❷</span>)。</p>
<p class="tx">ループの最終行の<span class="thesansmonocd_w5regular_">answer_options.index(correct_answer)</span>では、ランダムに並べ替えられた選択肢の中から正解のインデックスを見つけて、正解ファイルに正解の選択肢のアルファベットを書き込みます(<span class="codeannotation" aria-label="annotation3">❸</span>)。</p>
<p class="tx">このプログラムを実行すると、以下のような<i class="calibre5">capitalsquiz1.txt</i>ファイルが作成されるはずです。もちろん、設問と解答は、<span class="thesansmonocd_w5regular_">random.shuffle()</span>呼び出しの結果によって変わります。</p>
<pre class="pre"><code class="calibre9">Name:

Date:

Period:

                    State Capitals Quiz (Form 1)

1. What is the capital of West Virginia?
    A. Hartford
    B. Santa Fe
    C. Harrisburg
    D. Charleston

2. What is the capital of Colorado?
    A. Raleigh
    B. Harrisburg
    C. Denver
    D. Lincoln

<var class="calibre20">--snip--</var>
</code></pre>
<p class="tx">対応する<i class="calibre5">capitalsquiz_answers1.txt</i>テキストファイルは次のようになっています。</p>
<pre class="pre"><code class="calibre9">1. D
2. C

<var class="calibre20">--snip--</var>
</code></pre>
<p class="tx">設問をランダムに並べて対応する解答を手動で作成するには何時間もかかりますが、少しプログラミングの知識があればその退屈な作業を自動化できます。州都の設問に限らず、どのような選択式の試験にでも使えます。</p>
</section>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec23">
<h3 class="h" id="calibre_link-1693"><span id="calibre_link-251"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">OSはファイルをフォルダ（ディレクトリとも呼ばれます）にまとめて整理し、その場所をパスで表します。コンピュータ上で実行するプログラムにはすべて現在の作業ディレクトリがあり、ファイルパスをフルパス（絶対パス）で指定しなくても、そのディレクトリからの相対的な位置で指定できます。<span class="thesansmonocd_w5regular_">pathlib</span>モジュールと<span class="thesansmonocd_w5regular_">os.path</span>モジュールにはファイルパスを操作する関数がたくさんあります。</p>
<p class="tx">プログラムがテキストファイルを直接扱うこともできます。<span class="thesansmonocd_w5regular_">open()</span>関数でファイルを開くと、（<span class="thesansmonocd_w5regular_">read()</span>メソッドで）ファイルの中身を一つの大きな文字列として読み取るか、（<span class="thesansmonocd_w5regular_">readlines()</span>メソッドで）文字列のリストとして読み取ります。<span class="thesansmonocd_w5regular_">open()</span>関数は書き込みモードや追記モードでファイルを開くこともでき、そうすれば新しいテキストファイルを作成したり既存のテキストファイルに追記したりできます。</p>
<p class="tx">前章では、大量のテキストをプログラムで使うために、手で入力するのではなくクリップボードを活用しました。本章ではハードドライブのファイルを読み取る方法を学びました。ファイルはクリップボードよりも安定しています。</p>
<p class="tx">次章では、コピー、削除、リネーム、移動など、ファイル自体を操作する方法を説明します。</p>
</section>
<section type="division" aria-labelledby="sec24">
<h3 class="h" id="calibre_link-1694"><span id="calibre_link-252"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. 相対パスは何に対して相対的ですか？</p>
<p class="listnumber">  2. 絶対パスは何で始まりますか？</p>
<p class="listnumber">  3. Windowsで<span class="thesansmonocd_w5regular_">Path('C:/Users') / 'Al'</span>は何に評価されますか？</p>
<p class="listnumber">  4. Windowsで<span class="thesansmonocd_w5regular_">'C:/Users' / 'Al'</span>は何に評価されますか？</p>
<p class="listnumber">  5. <span class="thesansmonocd_w5regular_">os.getcwd()</span>関数と<span class="thesansmonocd_w5regular_">os.chdir()</span>関数は何を行いますか？</p>
<p class="listnumber">  6. <i class="calibre5">.</i>フォルダと<i class="calibre5">..</i>フォルダとは何ですか？</p>
<p class="listnumber">  7. <i class="calibre5">C:\bacon\eggs\spam.txt</i>について、どの部分がディレクトリ名で、どの部分がファイル名ですか？</p>
<p class="listnumber">  8. プレーンテキストファイルについて<span class="thesansmonocd_w5regular_">open()</span>を呼び出すときの3つのモード引数は何ですか？</p>
<p class="listnumber">  9. 既存のファイルを書き込みモードで開くとどうなりますか？</p>
<p class="listnumber">10. <span class="thesansmonocd_w5regular_">read()</span>メソッドと<span class="thesansmonocd_w5regular_">readlines()</span>メソッドはどう違いますか？</p>
<p class="listnumber">11. shelf値はどのデータ構造と似ていますか？</p>
</section>
<section type="division" aria-labelledby="sec25">
<h3 class="h" id="calibre_link-1695"><span id="calibre_link-253"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">練習のために以下のプログラムを設計して書いてください。</p>
<section type="division" aria-labelledby="sec26">
<h4 class="h1" id="calibre_link-1696"><span id="calibre_link-254"></span><span class="sans_futura_std_heavy_oblique_bi_">Mad Libs（訳注：あらかじめ用意された物語の空欄に入れる適当な言葉を、一人が別の人にまとめて言ってもらい、完成した文章を読み上げる言葉遊び）</span></h4>
<p class="tni">テキストファイルを読み取り、そのテキストファイル中の<i class="calibre5">ADJECTIVE</i>、<i class="calibre5">NOUN</i>、<i class="calibre5">ADVERB</i>、<i class="calibre5">VERB</i>にユーザーがテキストを入力する、Mad Libsプログラムを作成してください。例えば、次のテキストが用意されているとします。</p>
<pre class="pre"><code class="calibre9">The ADJECTIVE panda walked to the NOUN and then VERB. A nearby NOUN was
unaffected by these events.
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1284" aria-label="241"></span>このプログラムは、ユーザーに置き換える言葉を尋ねます。</p>
<pre class="pre"><code class="calibre9">Enter an adjective:
<b class="calibre10">silly</b>
Enter a noun:
<b class="calibre10">chandelier</b>
Enter a verb:
<b class="calibre10">screamed</b>
Enter a noun:
<b class="calibre10">pickup truck</b>
</code></pre>
<p class="tx">次のようなテキストファイルが作成されます。</p>
<pre class="pre"><code class="calibre9">The silly panda walked to the chandelier and then screamed. A nearby
pickup truck was unaffected by these events.
</code></pre>
<p class="tx">このプログラムは、結果を新しいテキストファイルとして保存するとともに、画面にも表示します。</p>
</section>
<section type="division" aria-labelledby="sec27">
<h4 class="h1" id="calibre_link-1697"><span id="calibre_link-255"></span><span class="sans_futura_std_heavy_oblique_bi_">正規表現によるファイル内検索</span></h4>
<p class="tni">フォルダ内のすべての<i class="calibre5">.txt</i>ファイルを開き、ユーザーが入力した正規表現にマッチするすべての行を検索して表示するプログラムを書いてください。</p>
</section>
</section>
</section>
</div>


</div>



</body></html>