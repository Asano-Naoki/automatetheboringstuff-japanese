<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-481">
<section type="chapter" role="doc-chapter" aria-labelledby="ch18">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1092" aria-label="437"></span>
<hgroup>
<h2 class="title" id="calibre_link-1952">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">18</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">CSV、JSON、XML</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">CSV、JSON、XMLは、データをプレーンテキストで保存するために用いる<i class="calibre18">直列化フォーマット</i>です。データを直列化して文字列に変換して保存します。プログラムでの作業をテキストファイルに保存して、インターネットで転送したり、メールに貼り付けたりできるようになります。Pythonには、これらのファイルフォーマットを扱いやすくしてくれる<span class="sans_thesansmonocd_w5regular_">csv</span>と<span class="sans_thesansmonocd_w5regular_">json</span>と<span class="sans_thesansmonocd_w5regular_">xml</span>のモジュールが同梱されています。</p>
<p class="tx">これらのフォーマットのファイルは、本質的に、Pythonの<span class="thesansmonocd_w5regular_">open()</span>関数その他の<span>第10章</span>で紹介した入出力関数で読み書きできるテキストファイルです。しかし、<span>第13章</span>でHTML形式のテキストを扱うのにBeautiful Soupを使ったように、Pythonの専用モジュールを利用するほうが簡便です。この3つのフォーマットには以下のような特徴があります。</p>
<p class="listplain"><b class="calibre10">CSV</b> （Comma Separated Valuesの略でシーエスブイと発音します）は、スプレッドシートを単純化したフォーマットで、同じカラムを持つ複数の行のデータを保存するのに最適です。</p>
<p class="listplain"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1082" aria-label="438"></span><b class="calibre10">JSON</b> （JavaScript Object Notationの略でジェイソンと発音します）は、JavaScriptプログラミング言語のオブジェクトや配列というデータ型と同じ構文を使いますが、JavaScriptでのプログラミングを知らなくても大丈夫です。XMLよりシンプルになるように作られました。</p>
<p class="listplain"><b class="calibre10">XML</b> （Extensible Markup Languageの略でエックスエムエルと発音します）は、比較的古く、構造がはっきりとしたデータ直列化フォーマットで、企業向けソフトウェアで広く用いられています。高度な機能が必要でなければ複雑すぎます。</p>
<p class="tx">本章では、これらのフォーマットの基本とPythonのコードを紹介します。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1953"><span id="calibre_link-482"></span><span class="sans_futura_std_bold_b_">CSV</span></h3>
<p class="tni">（<i class="calibre5">.csv</i>ファイル拡張子の）CSVファイルの各行は、スプレッドシートの行と同じようなものであり、行内のセルはカンマで区切られています。例えば、<a href="https://nostarch.com/automate-boring-stuff-python-3rd-edition" class="calibre1">https://<wbr></wbr>nostarch<wbr></wbr>.com<wbr></wbr>/automate<wbr></wbr>-boring<wbr></wbr>-stuff<wbr></wbr>-python<wbr></wbr>-3rd<wbr></wbr>-edition</a></i>の本書のオンライン素材にある<i class="calibre5">example3.xlsx</i>のスプレッドシートは、CSVファイルでは以下のようになります。</p>
<pre class="pre"><code class="calibre9">4/5/2035 13:34,Apples,73
4/5/2035 3:41,Cherries,85
4/6/2035 12:46,Pears,14
4/8/2035 8:59,Oranges,52
4/10/2035 2:07,Apples,152
4/10/2035 18:10,Bananas,23
4/10/2035 2:40,Strawberries,98
</code></pre>
<p class="tx">本章のCSVの対話型シェルの例ではこのファイルを使用します。ダウンロードするか上記のテキストを<i class="calibre5">example3.csv</i>という名前で保存してください。</p>
<p class="tx">CSVファイルは値のリストのリスト（二次元リスト）だと考えることができます。Pythonのコードは<span class="thesansmonocd_w5regular_">[['4/5/2035 13:34', 'Apples', '73'], ['4/5/2035 3:41', 'Cherries', '85'],</span> <span class="sans_thesansmonocd_w5regular_italic_">...</span> <span class="thesansmonocd_w5regular_">['4/10/2035 2:40', 'Strawberries', '98']]</span>のような値として<i class="calibre5">example3.csv</i>の内容を表現できます。CSVファイルはシンプルであり、以下に例示するようにExcelファイルに存在する機能の多くが欠けています。</p>
<ul class="ul">
<li class="bl">複数のデータ型は存在せず、値はすべて文字列</li>
<li class="bl">フォントサイズや色の設定はない</li>
<li class="bl">複数のワークシートは存在しない</li>
<li class="bl">セルの幅や高さを設定できない</li>
<li class="bl">セル結合はできない</li>
<li class="bl">図表を埋め込めない</li>
</ul>
<p class="tx">CSVファイルにはシンプルであるという優位性があります。多くのアプリやプログラミング言語でサポートされていますし、（Muなどの）テキストエディタで中身を確認できますし、スプレッドシートのデータを直接表現できます。</p>
<p class="tx">CSVファイルはテキストファイルですから、文字列として読み取ってその文字列を<span>第8章</span>で学んだテクニックで処理しようと思われるかもしれません。例えば、CSVファイルの各セルはカンマで区切られていますから、各行について<span class="thesansmonocd_w5regular_">split(',')</span>を呼び出してカンマ区切りの値を文字列のリストとして取得しようと考えるかもしれません。しかし、CSVファイルのカンマがすべてセルの区切りを表しているとは限りません。CSVファイルには、カンマその他の記号を値の中に含められるエスケープ記号があります。<span class="thesansmonocd_w5regular_">split()</span>メソッドはこうしたエスケープ記号を考慮しません。こうした潜在的な落とし穴があるため、<span class="thesansmonocd_w5regular_">csv</span>モジュールを使ったほうがCSVファイルの読み書きを信頼して行えます。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1954"><span id="calibre_link-483"></span><span class="sans_futura_std_heavy_oblique_bi_">CSVファイルの読み取り</span></h4>
<p class="tni">CSVファイルを読み取るには、CSVファイルの行を反復処理できる<span class="thesansmonocd_w5regular_">csv.reader</span>オブジェクトを作成します。<span class="thesansmonocd_w5regular_">csv</span>モジュールはPythonに同梱されていますから、改めてインストールしなくてもインポートできます。<i class="calibre5">example3.csv</i>を現在の作業ディレクトリに置いてから、対話型シェルで以下の内容を実行してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import csv</b>
&gt;&gt;&gt; <b class="calibre10">example_file = open('example3.csv')</b>
&gt;&gt;&gt; <b class="calibre10">example_reader = csv.reader(example_file)</b>
&gt;&gt;&gt; <b class="calibre10">example_data = list(example_reader)</b>
&gt;&gt;&gt; <b class="calibre10">example_data</b>
[['4/5/2035 13:34', 'Apples', '73'], ['4/5/2035 3:41', 'Cherries', '85'],
['4/6/2035 12:46', 'Pears', '14'], ['4/8/2035 8:59', 'Oranges', '52'],
['4/10/2035 2:07', 'Apples', '152'], ['4/10/2035 18:10', 'Bananas', '23'],
['4/10/2035 2:40', 'Strawberries', '98']]
&gt;&gt;&gt; <b class="calibre10">example_file.close()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">csv</span>モジュールでCSVファイルを読み取るには、他のテキストファイルと同じように、<span class="thesansmonocd_w5regular_">open()</span>関数でファイルを開きます。次に、<span class="thesansmonocd_w5regular_">open()</span>が返す<span class="thesansmonocd_w5regular_">File</span>オブジェクトについて<span class="thesansmonocd_w5regular_">read()</span>メソッドや<span class="thesansmonocd_w5regular_">readlines()</span>メソッドを呼び出すのではなく、<span class="thesansmonocd_w5regular_">File</span>オブジェクトを<span class="thesansmonocd_w5regular_">csv.reader()</span>関数に渡します。この関数は<span class="thesansmonocd_w5regular_">reader</span>オブジェクトを返します。<span class="thesansmonocd_w5regular_">csv.reader()</span>関数にファイル名の文字列を直接渡すことはできません。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">reader</span>オブジェクト内の値にアクセスする最も簡単な方法は、<span class="thesansmonocd_w5regular_">list()</span>に渡してPythonのリストに変換することです。<span class="thesansmonocd_w5regular_">reader</span>オブジェクトについて<span class="thesansmonocd_w5regular_">list()</span>を使うとリストのリストが返され、これを<span class="thesansmonocd_w5regular_">example_data</span>のような変数に格納できます。シェルで<span class="thesansmonocd_w5regular_">example_data</span>と入力するとリストのリストが表示されます。</p>
<p class="tx">これでCSVファイルをリストのリストにできましたから、<span class="thesansmonocd_w5regular_">example_data[row][col]</span>という式で行と列を指定して値にアクセスできます。<span class="thesansmonocd_w5regular_">row</span>は<span class="thesansmonocd_w5regular_">example_data</span>リストのインデックスで、<span class="thesansmonocd_w5regular_">col</span>はそのリストから取得する要素のインデックスです。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">example_data[0][0]</b>  # 1行目の1列目
'4/5/2035 13:34'
&gt;&gt;&gt; <b class="calibre10">example_data[0][1]</b>  # 1行目の2列目
'Apples'
&gt;&gt;&gt; <b class="calibre10">example_data[0][2]</b>  # 1行目の3列目
'73'
&gt;&gt;&gt; <b class="calibre10">example_data[1][1]</b>  # 2行目の2列目
'Cherries'
&gt;&gt;&gt; <b class="calibre10">example_data[6][1]</b>  # 7行目の2列目
'Strawberries'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1084" aria-label="440"></span>この出力からわかるように、<span class="thesansmonocd_w5regular_">example_data[0][0]</span>は最初のリストの最初の文字列で、<span class="thesansmonocd_w5regular_">example_data[0][2]</span>は最初のリストの3つ目の文字列です。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h4 class="h1" id="calibre_link-1955"><span id="calibre_link-484"></span><span class="sans_futura_std_heavy_oblique_bi_">forループでデータにアクセスする</span></h4>
<p class="tni">大きなCSVファイルでは、（リストのリストに変換せずに）<span class="thesansmonocd_w5regular_">reader</span>オブジェクトを<span class="thesansmonocd_w5regular_">for</span>ループで使います。そうするとファイル全体を一度にメモリにロードしなくてすみます。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import csv</b>
&gt;&gt;&gt; <b class="calibre10">example_file = open('example3.csv')</b>
&gt;&gt;&gt; <b class="calibre10">example_reader = csv.reader(example_file)</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">for row in example_reader:</b>
...   <span class="code_codeannotation" aria-label="annotation2">❷</span> <b class="calibre10">print('Row #' + str(example_reader.line_num) + ' ' + str(row))</b>
...
Row #1 ['4/5/2035 13:34', 'Apples', '73']
Row #2 ['4/5/2035 3:41', 'Cherries', '85']
Row #3 ['4/6/2035 12:46', 'Pears', '14']
Row #4 ['4/8/2035 8:59', 'Oranges', '52']
Row #5 ['4/10/2035 2:07', 'Apples', '152']
Row #6 ['4/10/2035 18:10', 'Bananas', '23']
Row #7 ['4/10/2035 2:40', 'Strawberries', '98']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">csv</span>モジュールをインポートしてCSVファイルから<span class="thesansmonocd_w5regular_">reader</span>オブジェクトを作成すると、<span class="thesansmonocd_w5regular_">reader</span>オブジェクトの行をループで回せます(<span class="codeannotation" aria-label="annotation1">❶</span>)。各行は変数rowに格納される値のリストで、そのリスト内の各値がセルに相当します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">print()</span>関数を呼び出して現在の行番号とその行の内容を表示しています(<span class="codeannotation" aria-label="annotation2">❷</span>)。<span class="thesansmonocd_w5regular_">reader</span>オブジェクトの<span class="thesansmonocd_w5regular_">line_num</span>属性で整数の行番号を取得できます。CSVファイルの最初の行が見出し行なら、<span class="thesansmonocd_w5regular_">line_num</span>で最初の行かどうかを判定し、<span class="thesansmonocd_w5regular_">continue</span>でヘッダー行を飛ばすことができます。Pythonのリストのインデックスとは異なり、<span class="thesansmonocd_w5regular_">line_num</span>の行番号は0ではなく1から始まります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">reader</span>オブジェクトは1回に限りループできます。CSVファイルをもう一度読み込みたければ、<span class="thesansmonocd_w5regular_">open()</span>と<span class="thesansmonocd_w5regular_">csv.reader()</span>をもう一度呼び出して別の<span class="thesansmonocd_w5regular_">reader</span>オブジェクトを作成します。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1956"><span id="calibre_link-485"></span><span class="sans_futura_std_heavy_oblique_bi_">CSVファイルの書き込み</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">csv.writer</span>オブジェクトではCSVファイルへの書き込みができます。<span class="thesansmonocd_w5regular_">writer</span>オブジェクトを作成するには、<span class="thesansmonocd_w5regular_">csv.writer()</span>関数を使います。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import csv</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">output_file = open('output.csv', 'w', newline='')</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">output_writer = csv.writer(output_file)</b>
&gt;&gt;&gt; <b class="calibre10">output_writer.writerow(['spam', 'eggs', 'bacon', 'ham'])</b>
21
&gt;&gt;&gt; <b class="calibre10">output_writer.writerow(['Hello, world!', 'eggs', 'bacon', 'ham'])</b>
32
&gt;&gt;&gt; <b class="calibre10">output_writer.writerow([1, 2, 3.141592, 4])</b>
16
&gt;&gt;&gt; <b class="calibre10">output_file.close()</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1219" aria-label="441"></span><span class="thesansmonocd_w5regular_">'w'</span>を渡して<span class="thesansmonocd_w5regular_">open()</span>を呼び出し書き込みモードでファイルを開きます(<span class="codeannotation" aria-label="annotation1">❶</span>)。それを<span class="thesansmonocd_w5regular_">csv.writer()</span>に渡して<span class="thesansmonocd_w5regular_">writer</span>オブジェクトを作成します(<span class="codeannotation" aria-label="annotation2">❷</span>)。</p>
<p class="tx">Windowsでは、<span class="thesansmonocd_w5regular_">open()</span>関数の<span class="thesansmonocd_w5regular_">newline</span>キーワード引数に空文字列を渡す必要があります。技術的な理由により（本書では扱いません）、<span class="thesansmonocd_w5regular_">newline</span>引数を指定しないと、<i class="calibre5">output.csv</i>の行が図18-1のように1行おきになってしまいます。</p>
<figure class="img"><img class="img2" id="calibre_link-800" src="images/000046.jpg" alt="Screenshot of a Windows computer desktop showing six overlapping calculator programs" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 18-1：1行おきのCSVファイル</span></p></figcaption>
</figure>
<p class="tx"><span class="thesansmonocd_w5regular_">writer</span>オブジェクトの<span class="thesansmonocd_w5regular_">writerow()</span>メソッドはリストを引数に取ります。リストの各値が出力CSVファイルの各セルに入ります。このメソッドの返り値は、ファイルに書き込んだその行の文字数（改行文字を含む）です。例えば、先ほどの例のコードを実行すると、以下のような<i class="calibre5">output.csv</i>ファイルが作成されます。</p>
<pre class="pre"><code class="calibre9">spam,eggs,bacon,ham
"Hello, world!",eggs,bacon,ham
1,2,3.141592,4
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">writer</span>オブジェクトは自動的に値<span class="thesansmonocd_w5regular_">'Hello, world!'</span>中のカンマをダブルクォートでエスケープすることに注目してください。<span class="thesansmonocd_w5regular_">csv</span>モジュールを使うと、こうした特殊例を自分で処理しなくてすみます。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1957"><span id="calibre_link-486"></span><span class="sans_futura_std_heavy_oblique_bi_">カンマではなくタブで区切る</span></h4>
<p class="tni"><i class="calibre5">TSV（Tab-separated value）</i>ファイルは、CSVファイルと似ていますが、カンマではなくタブで区切られており、<i class="calibre5">.tsv</i>というファイル拡張子です。カンマではなくタブでセルを区切り、1行おきにしたいとすると、対話型シェルで以下のような内容を実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import csv</b>
&gt;&gt;&gt; <b class="calibre10">output_file = open('output.tsv', 'w', newline='')</b>
&gt;&gt;&gt; <b class="calibre10">output_writer = csv.writer(output_file, delimiter='\t', lineterminator='\n\n')</b> <span class="code_codeannotation" aria-label="annotation1">❶</span>
&gt;&gt;&gt; <b class="calibre10">output_writer.writerow(['spam', 'eggs', 'bacon', 'ham'])</b>
21
&gt;&gt;&gt; <b class="calibre10">output_writer.writerow(['Hello, world!', 'eggs', 'bacon', 'ham'])</b>
30
&gt;&gt;&gt; <b class="calibre10">output_writer.writerow([1, 2, 3.141592, 4])</b>
16
&gt;&gt;&gt; <b class="calibre10">output_file.close()</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1080" aria-label="442"></span>このコードでは、区切りと行末記号を変更しています。<i class="calibre5">delimiter</i>（区切り）は行の中のセルとセルの間を区切る記号です。デフォルトでは、CSVファイルの区切りはカンマです。<i class="calibre5">line terminator</i>（行末記号）は行の最後に来る記号です。デフォルトでは改行記号です。<span class="thesansmonocd_w5regular_">csv.writer()</span>の<span class="thesansmonocd_w5regular_">delimiter</span>と<span class="thesansmonocd_w5regular_">lineterminator</span>のキーワード引数を使えばその記号を変更できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">delimiter='\t'</span>と<span class="thesansmonocd_w5regular_">lineterminator='\n\n'</span>を渡すと(<span class="codeannotation" aria-label="annotation1">❶</span>)、区切りをタブに、行末記号を2つの改行記号に変更します。<span class="thesansmonocd_w5regular_">writerow()</span>を3回呼び出して3行作成し、以下の内容の<i class="calibre5">output.tsv</i>という名前のファイルを作成します。</p>
<pre class="pre"><code class="calibre9">spam    eggs    bacon   ham

Hello, world!   eggs    bacon   ham

1   2   3.141592    4   
</code></pre>
<p class="tx">タブがセルを区切っています。</p>
</section>
<section type="division" aria-labelledby="sec6">
<h4 class="h1" id="calibre_link-1958"><span id="calibre_link-487"></span><span class="sans_futura_std_heavy_oblique_bi_">見出し行の処理</span></h4>
<p class="tni">見出し行を含むCSVファイルでは、<span class="thesansmonocd_w5regular_">reader</span>オブジェクトと<span class="thesansmonocd_w5regular_">writer</span>オブジェクトよりも、<span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトと<span class="thesansmonocd_w5regular_">DictWriter</span>オブジェクトを使うほうが便利です。<span class="thesansmonocd_w5regular_">reader</span>と<span class="thesansmonocd_w5regular_">writer</span>はリストでCSVファイルを読み書きするのに対し、<span class="thesansmonocd_w5regular_">DictReader</span>と<span class="thesansmonocd_w5regular_">DictWriter</span>は最初の行をキーとする辞書で読み書きします。</p>
<p class="tx">次の例のために、本書のオンライン素材から<i class="calibre5">exampleWithHeader3.csv</i>をダウンロードしてください。このファイルは最初の行に<i class="calibre5">Timestamp</i>、<i class="calibre5">Fruit</i>、<i class="calibre5">Quantity</i>という見出し行がある以外は<i class="calibre5">example3.csv</i>と同じです。対話型シェルに次の内容を入力してこのファイルを読み取ってください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import csv</b>
&gt;&gt;&gt; <b class="calibre10">example_file = open('exampleWithHeader3.csv')</b>
&gt;&gt;&gt; <b class="calibre10">example_dict_reader = csv.DictReader(example_file)</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">example_dict_data = list(example_dict_reader)</b>
&gt;&gt;&gt; <b class="calibre10">example_dict_data</b>
[{'Timestamp': '4/5/2035 3:41', 'Fruit': 'Cherries', 'Quantity': '85'},
{'Timestamp': '4/6/2035 12:46', 'Fruit': 'Pears', 'Quantity': '14'},
{'Timestamp': '4/8/2035 8:59', 'Fruit': 'Oranges', 'Quantity': '52'},
{'Timestamp': '4/10/2035 2:07', 'Fruit': 'Apples', 'Quantity': '152'},
{'Timestamp': '4/10/2035 18:10', 'Fruit': 'Bananas', 'Quantity': '23'},
{'Timestamp': '4/10/2035 2:40', 'Fruit': 'Strawberries', 'Quantity': '98'}]
&gt;&gt;&gt; <b class="calibre10">example_file = open('exampleWithHeader3.csv')</b>
&gt;&gt;&gt; <b class="calibre10">example_dict_reader = csv.DictReader(example_file)</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">for row in example_dict_reader:</b>
...     <b class="calibre10">print(row['Timestamp'], row['Fruit'], row['Quantity'])</b>
...
4/5/2035 13:34 Apples 73
4/5/2035 3:41 Cherries 85
4/6/2035 12:46 Pears 14
4/8/2035 8:59 Oranges 52
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1081" aria-label="443"></span>4/10/2035 2:07 Apples 152
4/10/2035 18:10 Bananas 23
4/10/2035 2:40 Strawberries 98
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトを<span class="thesansmonocd_w5regular_">list()</span>に渡すことにより、CSVのデータを辞書のリストとして取得します(<span class="codeannotation" aria-label="annotation1">❶</span>)。各行がリスト中の一つの辞書に対応します。あるいは、<span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトを<span class="thesansmonocd_w5regular_">for</span>ループ内で使うこともできます(<span class="codeannotation" aria-label="annotation2">❷</span>)。<span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトの<span class="thesansmonocd_w5regular_">row</span>は、最初の行の見出しから取ってきたキーを持つ辞書オブジェクトです。<span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトを使えば、最初の行の見出し情報を飛ばすコードを書かずにすみます。<span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトがその処理をしてくれます。</p>
<p class="tx">最初の行が見出しではない<i class="calibre5">example3.csv</i>で<span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトを使おうとすると、<span class="thesansmonocd_w5regular_">DictReader</span>オブジェクトは<span class="thesansmonocd_w5regular_">'4/5/2035 13:34'</span>、<span class="thesansmonocd_w5regular_">'Apples'</span>、<span class="thesansmonocd_w5regular_">'73'</span>を辞書のキーに使います。これを避けるためには、<span class="thesansmonocd_w5regular_">DictReader()</span>に見出しの名前を含む第二引数を渡します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import csv</b>
&gt;&gt;&gt; <b class="calibre10">example_file = open('example3.csv')</b>
&gt;&gt;&gt; <b class="calibre10">example_dict_reader = csv.DictReader(example_file, ['time', 'name', 'amount'])</b>
&gt;&gt;&gt; <b class="calibre10">for row in example_dict_reader:</b>
...     <b class="calibre10">print(row['time'], row['name'], row['amount'])</b>
...
4/5/2035 13:34 Apples 73
4/5/2035 3:41 Cherries 85
4/6/2035 12:46 Pears 14
4/8/2035 8:59 Oranges 52
4/10/2035 2:07 Apples 152
4/10/2035 18:10 Bananas 23
4/10/2035 2:40 Strawberries 98
</code></pre>
<p class="tx"><i class="calibre5">example3.csv</i>の最初の行は見出しではありませんので、自分で<span class="thesansmonocd_w5regular_">'time'</span>、<span class="thesansmonocd_w5regular_">'name'</span>、<span class="thesansmonocd_w5regular_">'amount'</span>という見出しを作りました。<span class="thesansmonocd_w5regular_">DictWriter</span>オブジェクトはCSVファイルの作成に辞書を使います。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import csv</b>
&gt;&gt;&gt; <b class="calibre10">output_file = open('output.csv', 'w', newline='')</b>
&gt;&gt;&gt; <b class="calibre10">output_dict_writer = csv.DictWriter(output_file, ['Name', 'Pet', 'Phone'])</b>
&gt;&gt;&gt; <b class="calibre10">output_dict_writer.writeheader()</b>
16
&gt;&gt;&gt; <b class="calibre10">output_dict_writer.writerow({'Name': 'Alice', 'Pet': 'cat', 'Phone': '555-1234'})</b>
20
&gt;&gt;&gt; <b class="calibre10">output_dict_writer.writerow({'Name': 'Bob', 'Phone': '555-9999'})</b>
15
&gt;&gt;&gt; <b class="calibre10">output_dict_writer.writerow({'Phone': '555-5555', 'Name': 'Carol', 'Pet': 'dog'})</b>
20
&gt;&gt;&gt; <b class="calibre10">output_file.close()</b>
</code></pre>
<p class="tx">作成するファイルに見出し行を含めたければ、<span class="thesansmonocd_w5regular_">writeheader()</span>を呼び出します。<span class="thesansmonocd_w5regular_">writeheader()</span>を呼び出さなければ、ファイルに見出し行は含まれません。<span class="thesansmonocd_w5regular_">writerow()</span>メソッドを呼び出すとCSVファイルの各行を書き込めます。見出しをキーとする辞書のデータを渡して書き込みます。</p>
<p class="tx">このコードは次のような<i class="calibre5">output.csv</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">Name,Pet,Phone
Alice,cat,555-1234
Bob,,555-9999
Carol,dog,555-5555
</code></pre>
<p class="tx">カンマが2つ続いているのは、Bobのpetの値が空白であることを示しています。<span class="thesansmonocd_w5regular_">writerow()</span>に渡した辞書のキーと値のペアの順番は関係ありません。<span class="thesansmonocd_w5regular_">DictWriter()</span>に渡したキーの順序で書き込まれます。例えば、Carolの行の<span class="thesansmonocd_w5regular_">Phone</span>のキーと値は、<span class="thesansmonocd_w5regular_">Name</span>と<span class="thesansmonocd_w5regular_">Pet</span>のキーと値よりも前に渡していますが、それでも電話番号は出力の最後に来ています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">{'Name': 'Bob', 'Phone': '555-9999'}</span>の<span class="thesansmonocd_w5regular_">'Pet'</span>のようにキーがなければ、CSVファイルでは空のセルになります。</p>
<p class="ph"><span id="calibre_link-488"></span><span class="sans_futura_std_heavy_b_">プロジェクト13：CSVファイルから見出しを取り除く</span></p>
<p class="tni">数百のCSVファイルから最初の行を取り除くという退屈な作業があるとします。すでに自動化された別の工程で見出し行ではなくデータだけを読み取らせるためにその作業が必要になるのでしょう。Excelでファイルを一つずつ開き、最初の行を削除して、上書き保存することはできます。しかし数時間かかります。その作業をしてくれるプログラムを書きましょう。</p>
<p class="tx">現在の作業ディレクトリにある<i class="calibre5">.csv</i>拡張子のファイルをすべて開き、そのCSVファイルの内容を読み取って、最初の行以外を同じ名前のファイルに書き出します。これで元ファイルの内容から見出し行のない新しいファイルを作成できます。</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_1">警告</span></p>
</blockquote>
<p class="note-txt"><i class="calibre5">ファイルを変更するプログラムを書く際は、プログラムが期待通りに動かない場合に備えて、必ず先にファイルのバックアップをしてください。元ファイルを誤って消してしまいたくはないはずです。</i></p>
<p class="tx">このプログラムには以下の内容が必要です。</p>
<ul class="ul">
<li class="bl">現在の作業ディレクトリにあるCSVファイルをすべて見つける</li>
<li class="bl">各ファイルの内容を全部読み取る</li>
<li class="bl">最初の行を飛ばして内容を新しいCSVファイルに書き込む</li>
</ul>
<p class="tx">コードには以下の内容が必要になります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">os.listdir()</span>のファイルリストを反復処理し、CSVファイル以外は飛ばす</li>
<li class="bl"><span class="thesansmonocd_w5regular_">reader</span>オブジェクトを作成して、ファイルの内容を読み取り、<span class="thesansmonocd_w5regular_">line_num</span>属性で飛ばす行を判定する</li>
<li class="bl"><span class="thesansmonocd_w5regular_">writer</span>オブジェクトを作成して、読み取ったデータを新しいファイルに書き込む</li>
</ul>
<p class="tx">このプロジェクト用に、新しいファイルエディタウィンドウを開いて<i class="calibre5">removeCsvHeader.py</i>という名前で保存してください。</p>
</section>
<section type="division" aria-labelledby="sec7">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1959" aria-label="445"></span>
<h4 class="h1" id="calibre_link-1960"><span id="calibre_link-489"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：各ファイルを反復処理する</span></h4>
<p class="tni">このプログラムでは、最初に現在の作業ディレクトリにあるすべてのCSVファイル名のリストを反復処理します。<i class="calibre5">removeCsvHeader.py</i>はこのようになります。</p>
<pre class="pre"><code class="calibre9"># CSVファイルから見出しを取り除く
import csv, os

os.makedirs('headerRemoved', exist_ok=True)

# 現在の作業ディレクトリのすべてのファイルを反復処理する
for csv_filename in os.listdir('.'):
    if not csv_filename.endswith('.csv'):
      <span class="code_codeannotation" aria-label="annotation1">❶</span> continue  # 非CSVファイルは飛ばす

    print('Removing header from ' + csv_filename + '...')

    # TODO：CSVファイルの読み取り（見出し行は飛ばす）

    # TODO：CSVファイルの書き込み
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">os.makedirs()</span>呼び出しにより、見出し行のないCSVファイルを保存する<i class="calibre5">headerRemoved</i>フォルダを作成します。<span class="thesansmonocd_w5regular_">os.listdir('.')</span>について<span class="thesansmonocd_w5regular_">for</span>ループを実行すればよさそうですが、これでは現在の作業ディレクトリの<i class="calibre5">すべての</i>ファイルを反復処理してしまうので、<i class="calibre5">.csv</i>で終わらないファイル名を飛ばすコードをループの冒頭に書く必要があります。非CSVファイルの場合は<span class="thesansmonocd_w5regular_">continue</span>文(<span class="codeannotation" aria-label="annotation1">❶</span>)で<span class="thesansmonocd_w5regular_">for</span>ループを次のファイル名に進めます。</p>
<p class="tx">プログラムを実行したときに出力を確認できるように、処理しているCSVファイルを示すメッセージを表示します。それから、プログラムの残りの部分の<span class="thesansmonocd_w5regular_">TODO</span>コメントを書き加えます。</p>
</section>
<section type="division" aria-labelledby="sec8">
<h4 class="h1" id="calibre_link-1961"><span id="calibre_link-490"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：ファイルを読み取る</span></h4>
<p class="tni">このプログラムでは、CSVファイルの最初の行を削除するのではありません。そうではなく、最初の行を除くCSVファイルの新しいコピーを作成します。このようにすれば、バグにより新しいファイルを誤って作成しても、元ファイルが残ります。</p>
<p class="tx">このプログラムでは最初の行を処理しているのかどうかを判定しなければなりません。<i class="calibre5">removeCsvHeader.py</i>に次の内容を追加します。</p>
<pre class="pre"><code class="calibre9"># CSVファイルから見出しを取り除く
import csv, os

<var class="calibre20">--snip--</var>

<b class="calibre10">    # CSVファイルの読み取り（見出し行は飛ばす）</b>
    <b class="calibre10">csv_rows = []</b>
    <b class="calibre10">csv_file_obj = open(csv_filename)</b>
<b class="calibre10">    reader_obj = csv.reader(csv_file_obj)</b>
    <b class="calibre10">for row in reader_obj:</b>
        <b class="calibre10">if reader_obj.line_num == 1:</b>
            <b class="calibre10">continue  </b># 見出し行は飛ばす
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1962" aria-label="446"></span>        <b class="calibre10">csv_rows.append(row)</b>
    <b class="calibre10">csv_file_obj.close()</b>

    # TODO：CSVファイルの書き込み
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">reader</span>オブジェクトの<span class="thesansmonocd_w5regular_">line_num</span>属性を使えば、現在読み取っているのがCSVファイルの何行目かを判定できます。内側の<span class="thesansmonocd_w5regular_">for</span>ループは<span class="thesansmonocd_w5regular_">reader</span>オブジェクトが返す行を反復処理し、最初の行以外のすべての行が<span class="thesansmonocd_w5regular_">csv_rows</span>に追加されます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループは各行を反復処理しますから、このコードでは<span class="thesansmonocd_w5regular_">reader_obj.line_num</span>が<span class="thesansmonocd_w5regular_">1</span>かどうかをチェックしています。条件を満たせば<span class="thesansmonocd_w5regular_">continue</span>を実行して<span class="thesansmonocd_w5regular_">csv_rows</span>に追加せずに次の行に進みます。以降の行はすべて条件が<span class="thesansmonocd_w5regular_">False</span>になるので、その行を<span class="thesansmonocd_w5regular_">csv_rows</span>に追加します。</p>
</section>
<section type="division" aria-labelledby="sec9">
<h4 class="h1" id="calibre_link-1963"><span id="calibre_link-491"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：新しいCSVファイルに書き込む</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">csv_rows</span>には最初の行以外のすべての行が入っていますから、このリストを<i class="calibre5">headerRemoved</i>フォルダ内のCSVファイルに書き込みます。<i class="calibre5">removeCsvHeader.py</i>に以下の内容を加えてください。</p>
<pre class="pre"><code class="calibre9"># CSVファイルから見出しを取り除く
import csv, os

<var class="calibre20">--snip--</var>

# 現在の作業ディレクトリのすべてのファイルを反復処理する
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> for csv_filename in os.listdir('.'):
    if not csv_filename.endswith('.csv'):
        continue    # 非CSVファイルは飛ばす

    <var class="calibre20">--snip--</var>

<b class="calibre10">    # CSVファイルの書き込み</b>
    <b class="calibre10">csv_file_obj = open(os.path.join('headerRemoved', csv_filename), 'w', </b>
<b class="calibre10">                 newline='')</b>
    <b class="calibre10">csv_writer = csv.writer(csv_file_obj)</b>
    <b class="calibre10">for row in csv_rows:</b>
        <b class="calibre10">csv_writer.writerow(row)</b>
    <b class="calibre10">csv_file_obj.close()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">writer</span>オブジェクトは、リストを<span class="thesansmonocd_w5regular_">headerRemoved</span>フォルダ内に<span class="thesansmonocd_w5regular_">csv_filename</span>という名前（CSVを読み取るときに使った名前）でCSVファイルに書き込みます。<span class="thesansmonocd_w5regular_">writer</span>オブジェクトを作成してから、<span class="thesansmonocd_w5regular_">csv_rows</span>に格納されたリストを反復処理してファイルに書き込みます。</p>
<p class="tx">外側の<span class="thesansmonocd_w5regular_">for</span>ループ(<span class="codeannotation" aria-label="annotation1">❶</span>)は、<span class="thesansmonocd_w5regular_">os.listdir('.')</span>が返した次のファイル名に進みます。このループが終了すれば、プログラムは完了です。</p>
<p class="tx">本書のオンライン素材から<i class="calibre5">removeCsvHeader.zip</i>をダウンロードしてから展開してこのプログラムをテストしてください。展開したフォルダ内で<i class="calibre5">removeCsvHeader.py</i>を実行すると、出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">Removing header from NAICS_data_1048.csv...
Removing header from NAICS_data_1218.csv...
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-927" aria-label="447"></span><var class="calibre20">--snip--</var>
Removing header from NAICS_data_9834.csv...
Removing header from NAICS_data_9986.csv...
</code></pre>
<p class="tx">このプログラムは、CSVファイルから最初の行を取り除くたびにファイル名を表示します。</p>
</section>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1964"><span id="calibre_link-492"></span><span class="sans_futura_std_heavy_oblique_bi_">似たようなプログラムのアイデア</span></h4>
<p class="tni">CSVファイルを操作するプログラムはExcelファイルを操作するプログラムと似ています。CSVもExcelもスプレッドシートファイルだからです。例えば、以下のようなプログラムを書くことができます。</p>
<ul class="ul">
<li class="bl">CSVファイルの行の差異や複数のCSVファイルの差異を調べる</li>
<li class="bl">CSVファイルから指定したデータをExcelファイルにコピーする、あるいは逆にExcelファイルからCSVファイルにコピーする</li>
<li class="bl">CSVファイルの不適切なデータやフォーマットの誤りを調べ、ユーザーに警告を発する</li>
<li class="bl">CSVファイルからデータを読み取りPythonプログラムの入力とする</li>
</ul>
</section>
</section>
<section type="division" aria-labelledby="sec11">
<h3 class="h" id="calibre_link-1965"><span id="calibre_link-493"></span><span class="sans_futura_std_bold_b_">多用途のプレーンテキストフォーマット</span></h3>
<p class="tni">CSVファイルはカラムが共通しているデータの行を保存するのに便利ですが、JSONやXMLフォーマットではさまざまなデータ構造を保存できます（本書ではJSONやXMLほど一般的に使われないYAMLとTOMLフォーマットは扱いません）。これらはPythonに固有のフォーマットではなく、多くのプログラミング言語の関数で読み書きできます。</p>
<p class="tx">これらのフォーマットでは、Pythonの辞書とリストを入れ子にしたものに相当する構造でデータを整理します。他のプログラミング言語では、Pythonで言うところの辞書を、<i class="calibre5">マッピング</i>、<i class="calibre5">ハッシュマップ</i>、<i class="calibre5">ハッシュテーブル</i>、<i class="calibre5">連想配列</i>と呼ぶことがあります（キーと値をマッピングしたり連想させたりするのでこのように呼ばれます）。同様に、他のプログラミング言語では、Pythonで言うところのリストを<i class="calibre5">配列</i>と呼ぶことがあります。呼び方は違っていても考え方は同じです。データをキーと値のペアやリストに整理します。</p>
<p class="tx">辞書とリストは、別の辞書やリストの内部に入れ子にして複雑なデータ構造を形成できます。しかし、そのデータ構造をテキストファイルに保存したいなら、JSONやXMLのようなデータ直列化フォーマットを選択しなければなりません。本章で紹介するPythonのモジュールは、これらのフォーマットで記述されたテキストを<i class="calibre5">解析</i>（読み取って理解）して、Pythonのデータ構造を作成できます。</p>
<p class="tx">これらの人間に読めるプレーンテキストのフォーマットは、ディスク容量やメモリを効率的に利用していませんが、テキストエディタで簡単に見て編集でき、プログラミング言語に中立だという利点があります。どのプログラミング言語で書かれたプログラムでもテキストファイルを読み書きはできます。対照的に、<span>第10章</span>で紹介した<span class="thesansmonocd_w5regular_">shelve</span>モジュールは、あらゆるPythonのデータ型をバイナリshelfファイルで保存できますが、他のプログラミング言語にはこのデータをプログラムにロードできるモジュールがありません。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1206" aria-label="448"></span>本章の以降の部分では、Aliceという人物についての個人情報を保存した以下のPythonのデータ構造を例に取り、JSONとXMLのフォーマットを比較対照します。</p>
<pre class="pre"><code class="calibre9">{
    "name": "Alice Doe",
    "age": 30,
    "car": None,
    "programmer": True,
    "address": {
        "street": "100 Larkin St.",
        "city": "San Francisco",
        "zip": "94102"
    },
    "phone": [
        {
            "type": "mobile",
            "number": "415-555-7890"
        },
        {
            "type": "work",
            "number": "415-555-1234"
        }
    ]
}
</code></pre>
<p class="tx">これらのテキストフォーマットには固有の歴史があり、コンピュータ関係の生態系の中で独自の地位を占めています。データを保存する直列化フォーマットを選ぶ必要があるなら、JSONがXMLよりもシンプルでYAMLよりも広く採用されており、TOMLは主に設定ファイル用のフォーマットとして用いられているということを踏まえるとよいでしょう。独自のデータ直列化フォーマットを編み出そうと考えることがあるかもしれませんが、それは車輪の再発明であり、その独自フォーマット用のパーサーを書かなければならなくなるので、おすすめしません。既存のフォーマットから選ぶのがベターです。</p>
<section type="division" aria-labelledby="sec12">
<h4 class="h1" id="calibre_link-1966"><span id="calibre_link-494"></span><span class="sans_futura_std_heavy_oblique_bi_">JSON</span></h4>
<p class="tni">JSONは情報をJavaScriptのソースコードとして保存します。JavaScript以外の多くのアプリケーションでも利用されています。特に、ウェブサイトは、<span>第13章</span>で紹介したOpenWeather APIのようなAPIを通じて、JSON形式でプログラマーにデータを提供している場合が多いです。ここではJSON形式のプレーンテキストのファイルを<i class="calibre5">.json</i>というファイル拡張子で保存します。JSONテキストでフォーマットしたデータ構造の例を示します。</p>
<pre class="pre"><code class="calibre9">{
  "name": "Alice Doe",
  "age": 30,
  "car": null,
  "programmer": true,
  "address": {
    "street": "100 Larkin St.",
    "city": "San Francisco",
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1248" aria-label="449"></span>    "zip": "94102"
  },
  "phone": [
    {
      "type": "mobile",
      "number": "415-555-7890"
    },
    {
      "type": "work",
      "number": "415-555-1234"
    }
  ]
}
</code></pre>
<p class="tx">JSONはPythonの構文に似ていることにすぐ気づくでしょう。Pythonの辞書とJSONのオブジェクトは、どちらも、波かっこを使い、キーと値のペアをコロンで区切ります。PythonのリストとJSONの配列は、どちらも、角かっこを使い、カンマ区切りの値を含みます。JSONでは、ダブルクォートで囲まれた文字列以外でスペースは意味を持ちません。どのようにでもスペースを入れられます。とはいえ、Pythonのコードのようにブロックをインデントして入れ子のオブジェクトや配列を見やすくしたほうがよいです。先ほどの例では、電話番号のリストを2文字分インデントしています。リスト中のそれぞれの電話番号の辞書は4文字分インデントしています。</p>
<p class="tx">スペースの使い方以外にもJSONとPythonの違いがあります。Pythonの<span class="thesansmonocd_w5regular_">None</span>値の代わりに、JSONではJavaScriptのキーワード<span class="thesansmonocd_w5regular_">null</span>を使います。ブール値はJavaScriptで小文字のキーワード<span class="thesansmonocd_w5regular_">true</span>と<span class="thesansmonocd_w5regular_">false</span>で表します。JSONではJavaScriptのコメントや複数行文字列を記入することができません。JSON中での文字列はすべてダブルクォートで囲まなければなりません。Pythonのリストとは異なり、JSONの配列は末尾にカンマを入れられません。<span class="thesansmonocd_w5regular_">["spam", "eggs"]</span>は正しいJSONですが、<span class="thesansmonocd_w5regular_">["spam", "eggs",]</span>は正しくありません。</p>
<p class="tx">Facebook、Twitter、Yahoo!、Google、Tumblr、Wikipedia、Flickr、Data.gov、Reddit、IMDb、Rotten Tomatoes、LinkedInその他の人気サイトではJSONデータでAPIを提供しています。これらのサイトの中には登録が要求されるものがありますが、たいてい無料です。ほしいデータを取得するためにプログラムからリクエストを送信するURLや、返されるJSONデータの構造の一般的なフォーマットなどを説明したドキュメントがあるはずです。APIを提供しているサイトに開発者ページがあれば、そこでドキュメントを探してください。</p>
<p class="tx">Pythonの<span class="thesansmonocd_w5regular_">json</span>モジュールは、<span class="thesansmonocd_w5regular_">json.loads()</span>関数と<span class="thesansmonocd_w5regular_">json.dumps()</span>関数で、JSON形式の文字列とそれに対応するPythonの値との間の変換の細かい処理をしてくれます。JSONにすべての種類のPythonの値を保存できるわけではなく、文字列型、整数型、浮動小数点数型、ブール型、リスト型、辞書型、<span class="thesansmonocd_w5regular_">None型</span>の基本的な型しか保存できません。JSONでは、<span class="thesansmonocd_w5regular_">File</span>オブジェクトやCSVの<span class="thesansmonocd_w5regular_">reader</span>オブジェクトと<span class="thesansmonocd_w5regular_">writer</span>オブジェクトや、Seleniumの<span class="thesansmonocd_w5regular_">WebElement</span>オブジェクトのような、Python固有のオブジェクトを表すことはできません。<span class="thesansmonocd_w5regular_">json</span>モジュールのドキュメントは<i class="calibre5"><a href="https://docs.python.org/3/library/json.html" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/json<wbr></wbr>.html</a></i>にあります。</p>
<section type="division" aria-labelledby="sec13">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1126" aria-label="450"></span>
<h5 class="h2" id="calibre_link-1967"><span class="sans_futura_std_bold_b_">JSONデータの読み取り</span></h5>
<p class="tni">JSONデータを含む文字列をPythonの値に変換するには、<span class="thesansmonocd_w5regular_">json.loads()</span>関数にその文字列を渡します（“loads”ではなく“load string”という意味です）。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">import json</b>
&gt;&gt;&gt; <b class="calibre10">json_string = '{"name": "Alice Doe", "age": 30, "car": null, "programmer":</b>
<b class="calibre10"> true, "address": {"street": "100 Larkin St.", "city": "San Francisco", "zip":</b>
<b class="calibre10"> "94102"}, "phone": [{"type": "mobile", "number": "415-555-7890"}, {"type": </b>
<b class="calibre10">"work", "number": "415-555-1234"}]}'</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">python_data = json.loads(json_string)</b>
&gt;&gt;&gt; <b class="calibre10">python_data</b>
{'name': 'Alice Doe', 'age': 30, 'car': None, 'programmer': True, 'address':
{'street': '100 Larkin St.', 'city': 'San Francisco', 'zip': '94102'},
'phone': [{'type': 'mobile', 'number': '415-555-7890'}, {'type': 'work',
'number': '415-555-1234'}]}
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">json</span>モジュールをインポートして(<span class="codeannotation" aria-label="annotation1">❶</span>)、JSONデータの文字列を渡して<span class="thesansmonocd_w5regular_">loads()</span>を呼び出します(<span class="codeannotation" aria-label="annotation2">❷</span>)。JSON文字列はダブルクォートを使うことに注意してください。この関数は、Pythonの辞書としてデータを返すはずです。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h5 class="h2" id="calibre_link-1968"><span class="sans_futura_std_bold_b_">JSONデータの書き込み</span></h5>
<p class="tni">Pythonの値をJSON形式の文字列に変換するには、<span class="thesansmonocd_w5regular_">json.dumps()</span>関数を使います（“dumps”ではなく“dump string”という意味です）。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import json</b>
&gt;&gt;&gt; <b class="calibre10">python_data = {'name': 'Alice Doe', 'age': 30, 'car': None, 'programmer': True, 'address':</b>
<b class="calibre10">{'street': '100 Larkin St.', 'city': 'San Francisco', 'zip': '94102'}, 'phone': [{'type': </b>
<b class="calibre10">'mobile', 'number': '415-555-7890'}, {'type': 'work', 'number': '415-555-1234'}]}</b>
&gt;&gt;&gt; <b class="calibre10">json_string = json.dumps(python_data)</b> <span class="code_codeannotation" aria-label="annotation1">❶</span>
&gt;&gt;&gt; <b class="calibre10">print(json_string) </b><span class="code_codeannotation" aria-label="annotation2">❷</span>
{"name": "Alice Doe", "age": 30, "car": null, "programmer": true, "address": {"street":
"100 Larkin St.", "city": "San Francisco", "zip": "94102"}, "phone": [{"type": "mobile",
"number": "415-555-7890"}, {"type": "work", "number": "415-555-1234"}]}
&gt;&gt;&gt; <b class="calibre10">json_string = json.dumps(python_data, indent=2)</b> <span class="code_codeannotation" aria-label="annotation3">❸</span>
&gt;&gt;&gt; <b class="calibre10">print(json_string)</b>
{
  "name": "Alice Doe",
  "age": 30,
  "car": null,
  "programmer": true,
  "address": {
    "street": "100 Larkin St.",
    "city": "San Francisco",
<var class="calibre20">--snip--</var>
}
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">json.dumps()</span>に渡す値(<span class="codeannotation" aria-label="annotation1">❶</span>)には、文字列型、整数型、浮動小数点数型、ブール型、リスト型、辞書型、<span class="thesansmonocd_w5regular_">None型</span>の基本的な型しか含められません。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-909" aria-label="451"></span>デフォルトでは、JSONテキスト全体が1行で書き込まれます(<span class="codeannotation" aria-label="annotation2">❷</span>)。このように詰め込まれた形でもプログラムがJSONを読み書きするには問題ありませんが、複数行でインデントされた形式のほうが人間にとっては読みやすいです。<span class="thesansmonocd_w5regular_">indent=2</span>キーワード引数(<span class="codeannotation" aria-label="annotation3">❸</span>)を指定すると、JSONテキストが複数行になり、辞書やリストの入れ子ではスペース2文字分インデントされます。JSONがメガバイトを超えるような大きさでなければ、スペースや改行を追加してサイズが増えても読みやすくする価値があります。</p>
<p class="tx">JSONテキストをPythonの文字列値に変換すれば、<i class="calibre5">.json</i>ファイルに書き込んだり、関数に渡したり、ウェブのリクエストに使ったり、その他文字列でできることは何でもできます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec15">
<h4 class="h1" id="calibre_link-1969"><span id="calibre_link-495"></span><span class="sans_futura_std_heavy_oblique_bi_">XML</span></h4>
<p class="tni">XMLはJSONよりも古いフォーマットですが、今でも広く用いられています。構文は、<span>第13章</span>で紹介したHTMLと似ており、山かっこの開始タグと終了タグの間に内容を入れます。こうしたタグのことを<i class="calibre5">要素</i>と呼びます。SVG画像ファイルはXMLで書かれたテキストで成り立っていますし、RSSとAtomのウェブフィードのフォーマットもXMLですし、Microsoft Word文書は<i class="calibre5">.docx</i>ファイル拡張子のXMLファイルを含むZIPファイルです。</p>
<p class="tx">ここではXML形式のテキストファイルを<i class="calibre5">.xml</i>というファイル拡張子で保存します。以下はXML形式のデータ構造の例です。</p>
<pre class="pre"><code class="calibre9">&lt;person&gt;
    &lt;name&gt;Alice Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
    &lt;programmer&gt;true&lt;/programmer&gt;
    &lt;car xsi:nil="true" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/&gt;
    &lt;address&gt;
        &lt;street&gt;100 Larkin St.&lt;/street&gt;
        &lt;city&gt;San Francisco&lt;/city&gt;
        &lt;zip&gt;94102&lt;/zip&gt;
    &lt;/address&gt;
    &lt;phone&gt;
        &lt;phoneEntry&gt;
            &lt;type&gt;mobile&lt;/type&gt;
            &lt;number&gt;415-555-7890&lt;/number&gt;
        &lt;/phoneEntry&gt;
        &lt;phoneEntry&gt;
            &lt;type&gt;work&lt;/type&gt;
            &lt;number&gt;415-555-1234&lt;/number&gt;
        &lt;/phoneEntry&gt;
    &lt;/phone&gt;
&lt;/person&gt;
</code></pre>
<p class="tx">この例では、<span class="thesansmonocd_w5regular_">&lt;person&gt;</span>要素には<span class="thesansmonocd_w5regular_">&lt;name&gt;</span>、<span class="thesansmonocd_w5regular_">&lt;age&gt;</span>その他の要素が含まれています。<span class="thesansmonocd_w5regular_">&lt;name&gt;</span>や<span class="thesansmonocd_w5regular_">&lt;age&gt;</span>の要素は<i class="calibre5">子要素</i>で、<span class="thesansmonocd_w5regular_">&lt;person&gt;</span>はその<i class="calibre5">親要素</i>です。正しいXML文書には<i class="calibre5">ルート要素</i>が一つだけあり、他の要素はすべてそのルート要素に含まれます。この例では<span class="thesansmonocd_w5regular_">&lt;person&gt;</span>要素がルート要素です。以下のように複数のルート要素がある文書は正しいXMLではありません。</p>
<pre class="pre"><code class="calibre9">&lt;person&gt;&lt;name&gt;Alice Doe&lt;/name&gt;&lt;/person&gt;
&lt;person&gt;&lt;name&gt;Bob Smith&lt;/name&gt;&lt;/person&gt;
&lt;person&gt;&lt;name&gt;Carol Watanabe&lt;/name&gt;&lt;/person&gt;
</code></pre>
<p class="tx">XMLはJSONのようなより新しい直列化フォーマットと比較するとかなり冗長です。各要素には、<span class="thesansmonocd_w5regular_">&lt;age&gt;</span>と<span class="thesansmonocd_w5regular_">&lt;/age&gt;</span>のように、開始タグと終了タグがあります。XML要素はキーと値のペアです。キーは要素のタグで（この例なら<span class="thesansmonocd_w5regular_">&lt;age&gt;</span>）値は開始タグと終了タグの間のテキストです。XMLのテキストにはデータ型がありません。開始タグと終了タグの間にあるものは、この例での<span class="thesansmonocd_w5regular_">94102</span>や<span class="thesansmonocd_w5regular_">true</span>も含めて、すべて文字列だと解釈されます。<span class="thesansmonocd_w5regular_">&lt;phone&gt;</span>要素のようなデータのリストの個々の要素にも<span class="thesansmonocd_w5regular_">&lt;phoneEntry&gt;</span>のような名前をつけなければなりません。慣習的に“Entry”という接尾辞をつけることが多いです。</p>
<p class="tx">XMLのコメントはHTMLのコメントと同じで、<span class="thesansmonocd_w5regular_">&lt;!--</span>と<span class="thesansmonocd_w5regular_">--&gt;</span>の間にあるものはコメントとして無視されます。</p>
<p class="tx">開始タグと終了タグの外側のスペースは意味を持たないので、好きなようにスペースを入れられます。XMLには“null”値はありませんが、タグに<span class="thesansmonocd_w5regular_">xsi:nil="true"</span>と<span class="thesansmonocd_w5regular_">xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span>という属性を入れると“null”値に近くなります。XMLの属性は、開始タグ内に<span class="sans_thesansmonocd_w5regular_italic_">key="value"</span>という形式で書かれたキーと値のペアです。タグは終了タグを用いずに<span class="thesansmonocd_w5regular_">/&gt;</span>で終わる<i class="calibre5">自己終了タグ</i>で書きます。例えば、<span class="thesansmonocd_w5regular_">&lt;car xsi:nil="true" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/&gt;</span>のように書きます。</p>
<p class="tx">タグと属性の名前は大文字でも小文字でも構いませんが、慣習的には小文字を使います。属性値はシングルクォートでもダブルクォートでも囲めますが、ダブルクォートで囲むほうが一般的です。</p>
<p class="tx">子要素にするか属性にするかはしばしば曖昧になります。先ほどの例では住所データを以下の要素で表していました。</p>
<pre class="pre"><code class="calibre9">&lt;address&gt;
    &lt;street&gt;100 Larkin St.&lt;/street&gt;
    &lt;city&gt;San Francisco&lt;/city&gt;
    &lt;zip&gt;94102&lt;/zip&gt;
&lt;/address&gt;
</code></pre>
<p class="tx">しかし、子要素を<span class="thesansmonocd_w5regular_">&lt;address&gt;</span>要素の自己終了タグの属性で表すこともできます。</p>
<pre class="pre"><code class="calibre9">&lt;address street="100 Larkin St." city="San Francisco" zip="94102" /&gt;</code></pre>
<p class="tx">このような曖昧さがあり、タグは冗長なことも相まって、XMLはかつてほど使われなくなってきました。XMLは1990年代から2000年代にかけて広く用いられ、現役で使用されているソフトウェアもたくさんあります。しかし、今では、XMLを使う特別な理由がなければ、JSONを使ったほうがよいでしょう。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1115" aria-label="453"></span>大まかに言うと、XMLソフトウェアライブラリには、XML文書を読み取る2つの方法があります。<i class="calibre5">Document Object Model（DOM）</i>アプローチでは、一気にXML文書全体をメモリに読み取ります。このアプローチではXML文書内のどこにあるデータでもすぐにアクセスできますが、一般にサイズが中程度くらいのXML文書でないとうまく動きません。<i class="calibre5">Simple API for XML（SAX）</i>アプローチでは、XML文書を要素のストリームとして読み取るので、一気に文書全体をメモリに読み取る必要はありません。このアプローチはギガバイト単位のXML文書に適していますが、文書中で反復処理しなければならないので、あまり便利ではありません。</p>
<p class="tx">Pythonの標準ライブラリには、XMLテキスト処理用の<span class="thesansmonocd_w5regular_">xml.dom</span>モジュール、<span class="thesansmonocd_w5regular_">xml.sax</span>モジュール、<span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールがあります。ここでのシンプルな例には、一気にXML文書全体を読み取るPythonの<span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールを使用します。
</p>
<section type="division" aria-labelledby="sec16">
<h5 class="h2" id="calibre_link-1970"><span class="sans_futura_std_bold_b_">XMLファイルの読み取り</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールは<span class="thesansmonocd_w5regular_">Element</span>オブジェクトでXML要素と子要素を表します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">import xml.etree.ElementTree as ET</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">xml_string = """&lt;person&gt;&lt;name&gt;Alice Doe&lt;/name&gt;&lt;age&gt;30&lt;/age&gt;</b>
<b class="calibre10">&lt;programmer&gt;true&lt;/programmer&gt;&lt;car xsi:nil="true" xmlns:xsi=</b>
<b class="calibre10">"http://www.w3.org/2001/XMLSchema-instance”/&gt;&lt;address&gt;&lt;street&gt;</b>
<b class="calibre10">100 Larkin St.&lt;/street&gt;&lt;city&gt;San Francisco&lt;/city&gt;&lt;zip&gt;94102&lt;/zip&gt;</b>
<b class="calibre10">&lt;/address&gt;&lt;phone&gt;&lt;phoneEntry&gt;&lt;type&gt;mobile&lt;/type&gt;&lt;number&gt;415-555-</b>
<b class="calibre10">7890&lt;/number&gt;&lt;/phoneEntry&gt;&lt;phoneEntry&gt;&lt;type&gt;work&lt;/type&gt;&lt;number&gt;</b>
<b class="calibre10">415-555-1234&lt;/number&gt;&lt;/phoneEntry&gt;&lt;/phone&gt;&lt;/person&gt;"""</b>
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> &gt;&gt;&gt; <b class="calibre10">root = ET.fromstring(xml_string)</b>
&gt;&gt;&gt; <b class="calibre10">root</b>
&lt;Element 'person' at 0x000001942999BBA0&gt;
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールを<span class="thesansmonocd_w5regular_">as ET</span>構文でインポートしています(<span class="codeannotation" aria-label="annotation1">❶</span>)。これにより、長い<span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>というモジュール名の代わりに<span class="thesansmonocd_w5regular_">ET</span>と書けるようになります。変数<span class="thesansmonocd_w5regular_">xml_string</span>には解析対象のXMLのテキストが入っています(<span class="codeannotation" aria-label="annotation2">❷</span>)。XMLのテキストは<i class="calibre5">.xml</i>拡張子のテキストファイルから読み取ることも簡単にできます。最後に、そのテキストを<span class="thesansmonocd_w5regular_">ET.fromstring()</span>関数に渡すと(<span class="codeannotation" aria-label="annotation3">❸</span>)、アクセスしたいデータを含む<span class="thesansmonocd_w5regular_">Element</span>オブジェクトが返されます。この<span class="thesansmonocd_w5regular_">Element</span>オブジェクトを<span class="thesansmonocd_w5regular_">root</span>という名前の変数に格納します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールには<span class="thesansmonocd_w5regular_">parse()</span>という関数もあります。XMLをロードするファイル名を渡せば、<span class="thesansmonocd_w5regular_">Element</span>オブジェクトが返されます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import xml.etree.ElementTree as ET</b>
&gt;&gt;&gt; <b class="calibre10">tree = ET.parse('my_data.xml')</b>
&gt;&gt;&gt; <b class="calibre10">root = tree.getroot()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Element</span>オブジェクトを取得したら、<span class="thesansmonocd_w5regular_">tag</span>属性でタグ名を、<span class="thesansmonocd_w5regular_">text</span>属性で開始タグと終了タグで囲まれたテキストを確認できます。<span class="thesansmonocd_w5regular_">list()</span>関数に<span class="thesansmonocd_w5regular_">Element</span>オブジェクトを渡すと、その直接の子要素のリストが返されます。対話型シェルで続けて以下のように入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">root.tag</b>
'person'
&gt;&gt;&gt; <b class="calibre10">list(root)</b>
[&lt;Element 'name' at 0x00000150BA4ADDF0&gt;, &lt;Element 'age' at
0x00000150BA4ADF30&gt;, &lt;Element 'programmer' at 0x00000150BA4ADEE0&gt;,
&lt;Element 'car' at 0x00000150BA4ADD00&gt;, &lt;Element 'address' at
0x00000150BA4ADCB0&gt;, &lt;Element 'phone' at 0x00000150BA4ADA30&gt;]
</code></pre>
<p class="tx">親要素の<span class="thesansmonocd_w5regular_">Element</span>オブジェクトについての子要素の<span class="thesansmonocd_w5regular_">Element</span>オブジェクトには、Pythonのリストと同じように整数のインデックスでアクセスできます。<span class="thesansmonocd_w5regular_">root</span>に<span class="thesansmonocd_w5regular_">&lt;person&gt;</span>要素が入っているとしたら、<span class="thesansmonocd_w5regular_">root[0]</span>は<span class="thesansmonocd_w5regular_">&lt;name&gt;</span>要素で<span class="thesansmonocd_w5regular_">root[1]</span>は<span class="thesansmonocd_w5regular_">&lt;age&gt;</span>要素です。これらの<span class="thesansmonocd_w5regular_">Element</span>オブジェクトではすべて<span class="thesansmonocd_w5regular_">tag</span>属性と<span class="thesansmonocd_w5regular_">text</span>属性にアクセスできます。しかし、<span class="thesansmonocd_w5regular_">&lt;car/&gt;</span>のような自己終了タグについては、<span class="thesansmonocd_w5regular_">text</span>属性が<span class="thesansmonocd_w5regular_">None</span>になります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">root[0].tag</b>
'name'
&gt;&gt;&gt; <b class="calibre10">root[0].text</b>
'Alice Doe'
&gt;&gt;&gt; <b class="calibre10">root[3].tag</b>
'car'
&gt;&gt;&gt; <b class="calibre10">root[3].text == None</b>  # &lt;car/&gt;にはtextがない<b class="calibre10"> </b>
True
&gt;&gt;&gt; <b class="calibre10">root[4].tag</b>
'address'
&gt;&gt;&gt; <b class="calibre10">root[4][0].tag</b>
'street'
&gt;&gt;&gt; <b class="calibre10">root[4][0].text</b>
'100 Larkin St.'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">ルート</span>要素からXML文書全体のデータを探ることができます。<span class="thesansmonocd_w5regular_">Element</span>オブジェクトを<span class="thesansmonocd_w5regular_">for</span>ループで回すと直接の子要素を反復処理できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">for elem in root:</b>
...     <b class="calibre10">print(elem.tag, '--', elem.text)</b>
...
name -- Alice Doe
age -- 30
programmer -- true
car -- None
address -- None
phone -- None
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Element</span>の配下の子要素をすべて反復処理したければ、<span class="thesansmonocd_w5regular_">for</span>ループで<span class="thesansmonocd_w5regular_">iter()</span>メソッドを呼び出します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">for elem in root.iter():</b>
...     <b class="calibre10">print(elem.tag, '--', elem.text)</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1204" aria-label="455"></span>...
person -- None
name -- Alice Doe
age -- 30
programmer -- true
car -- None
address -- None
street -- 100 Larkin St.
city -- San Francisco
zip -- 94102
phone -- None
phoneEntry -- None
type -- mobile
number -- 415-555-7890
phoneEntry -- None
type -- work
number -- 415-555-1234
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">iter()</span>メソッドに文字列を渡してXML要素でマッチするタグを抽出することもできます。この例では、<span class="thesansmonocd_w5regular_">iter('number')</span>を呼び出し、ルート要素の<span class="thesansmonocd_w5regular_">&lt;number&gt;</span>子要素だけを反復処理します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">for elem in root.iter('number'):</b>
...     <b class="calibre10">print(elem.tag, '--', elem.text)</b>
...
number -- 415-555-7890
number -- 415-555-1234
</code></pre>
<p class="tx">この節で紹介した属性やメソッド以外にも、XML文書でデータを確認する方法はいろいろあります。例えば、<span>第13章</span>で紹介したウェブページのHTMLで要素を見つけるCSSセレクタのように、<i class="calibre5">XPath</i>と呼ばれる言語でXML文書中の要素を特定できます。これは本章の範囲外ですが、<i class="calibre5"><a href="https://docs.python.org/3/library/xml.etree.elementtree.html" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/xml<wbr></wbr>.etree<wbr></wbr>.elementtree<wbr></wbr>.html</a></i>のPythonのドキュメントで説明されています。</p>
<p class="tx">PythonのXMLモジュールではXMLテキストをPythonのデータ構造に変換できません。しかし、サードパーティの<span class="thesansmonocd_w5regular_">xmltodict</span>モジュール（<i class="calibre5"><a href="https://pypi.org/project/xmltodict/" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org<wbr></wbr>/project<wbr></wbr>/xmltodict<wbr></wbr>/</a></i>）を使えば変換できます。<span>付録A</span>の指示に従ってインストールしてください。例を示します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import xmltodict</b>
&gt;&gt;&gt; <b class="calibre10">xml_string = """&lt;person&gt;&lt;name&gt;Alice Doe&lt;/name&gt;&lt;age&gt;30&lt;/age&gt;</b>
<b class="calibre10">&lt;programmer&gt;true&lt;/programmer&gt;&lt;car xsi:nil="true" xmlns:xsi=</b>
<b class="calibre10">"http://www.w3.org/2001/XMLSchema-instance”/&gt;&lt;address&gt;&lt;street&gt;</b>
<b class="calibre10">100 Larkin St.&lt;/street&gt;&lt;city&gt;San Francisco&lt;/city&gt;&lt;zip&gt;94102</b>
<b class="calibre10">&lt;/zip&gt;&lt;/address&gt;&lt;phone&gt;&lt;phoneEntry&gt;&lt;type&gt;mobile&lt;/type&gt;&lt;number&gt;</b>
<b class="calibre10">415-555-7890&lt;/number&gt;&lt;/phoneEntry&gt;&lt;phoneEntry&gt;&lt;type&gt;work&lt;/type&gt;</b>
<b class="calibre10">&lt;number&gt;415-555-1234&lt;/number&gt;&lt;/phoneEntry&gt;&lt;/phone&gt;&lt;/person&gt;"""</b>
&gt;&gt;&gt; <b class="calibre10">python_data = xmltodict.parse(xml_string)</b>
&gt;&gt;&gt; <b class="calibre10">python_data</b>
{'person': {'name': 'Alice Doe', 'age': '30', 'programmer': 'true',
'car': {'@xsi:nil': 'true', '@xmlns:xsi': 'http://www.w3.org/2001/
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-991" aria-label="456"></span>XMLSchema-instance'}, 'address': {'street': '100 Larkin St.', 'city':
'San Francisco', 'zip': '94102'}, 'phone': {'phoneEntry': [{'type':
'mobile', 'number': '415-555-7890'}, {'type': 'work', 'number':
'415-555-1234'}]}}}
</code></pre>
<p class="tx">JSONと比べてXMLが脇に押しやられた一つの理由は、XMLでデータ型を表現するのが難しいことです。例えば、<span class="thesansmonocd_w5regular_">&lt;programmer&gt;</span>要素はブール値の<span class="thesansmonocd_w5regular_">True</span>ではなく文字列値の<span class="thesansmonocd_w5regular_">'true'</span>と解釈されます。<span class="thesansmonocd_w5regular_">&lt;car&gt;</span>要素は、<span class="thesansmonocd_w5regular_">None</span>値ではなく、<span class="thesansmonocd_w5regular_">'car': {'@xsi:nil': 'true', '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'}</span>という見苦しいキーと値のペアに解釈されます。XMLモジュールを使う際は、意図したとおりにデータを表現できているか、入出力をダブルチェックしなければなりません。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h5 class="h2" id="calibre_link-1971"><span class="sans_futura_std_bold_b_">XMLファイルの書き込み</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールは少し扱いづらいですから、小さなプロジェクトでは<span class="thesansmonocd_w5regular_">open()</span>関数と<span class="thesansmonocd_w5regular_">write()</span>メソッドでXMLテキストを自分で書き出すほうがよいでしょう。<span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールでXML文書を作成するなら、ルート<span class="thesansmonocd_w5regular_">Element</span>オブジェクト（先ほどの例で言うなら<span class="thesansmonocd_w5regular_">&lt;person&gt;</span>要素）を作成してから、<span class="thesansmonocd_w5regular_">SubElement()</span>関数を呼び出して子要素を作成します。<span class="thesansmonocd_w5regular_">set()</span>メソッドで要素に任意のXML属性を設定できます。例えば、次のようにします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import xml.etree.ElementTree as ET</b>
&gt;&gt;&gt; <b class="calibre10">person = ET.Element('person')</b>  # ルートXML要素の作成
&gt;&gt;&gt; <b class="calibre10">name = ET.SubElement(person, 'name')</b>  # &lt;name&gt;を作成して&lt;person&gt;の下に入れる
&gt;&gt;&gt; <b class="calibre10">name.text = 'Alice Doe'</b>  # &lt;name&gt;と&lt;/name&gt;の間にテキストを入れる
&gt;&gt;&gt; <b class="calibre10">age = ET.SubElement(person, 'age')</b>
&gt;&gt;&gt; <b class="calibre10">age.text = '30'</b>  # XMLの内容はすべて文字列
&gt;&gt;&gt; <b class="calibre10">programmer = ET.SubElement(person, 'programmer')</b>
&gt;&gt;&gt; <b class="calibre10">programmer.text = 'true'</b>
&gt;&gt;&gt; <b class="calibre10">car = ET.SubElement(person, 'car')</b>
&gt;&gt;&gt; <b class="calibre10">car.set('xsi:nil', 'true')</b>
&gt;&gt;&gt; <b class="calibre10">car.set('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')</b>
&gt;&gt;&gt; <b class="calibre10">address = ET.SubElement(person, 'address')</b>
&gt;&gt;&gt; <b class="calibre10">street = ET.SubElement(address, 'street')</b>
&gt;&gt;&gt; <b class="calibre10">street.text = '100 Larkin St.'</b>
</code></pre>
<p class="tx">長くなるので<span class="thesansmonocd_w5regular_">&lt;address&gt;</span>要素と<span class="thesansmonocd_w5regular_">&lt;phone&gt;</span>要素の残りの部分は省略しました。ルート<span class="thesansmonocd_w5regular_">Element</span>オブジェクトについて<span class="thesansmonocd_w5regular_">ET.tostring()</span>関数と<span class="thesansmonocd_w5regular_">decode()</span>関数を呼び出せば、XMLテキストのPythonの文字列を取得できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">ET.tostring(person, encoding='utf-8').decode('utf-8')</b>
'&lt;person&gt;&lt;name&gt;Alice Doe&lt;/name&gt;&lt;age&gt;30&lt;/age&gt;&lt;programmer&gt;true&lt;/programmer&gt;
&lt;car xsi:nil="true" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/&gt;
&lt;address&gt;&lt;street&gt;100 Larkin St.&lt;/street&gt;&lt;/address&gt;&lt;/person&gt;'
</code></pre>
<p class="tx">あいにく、<span class="thesansmonocd_w5regular_">tostring()</span>関数は、文字列ではなく<span class="thesansmonocd_w5regular_">bytes</span>オブジェクトを返すので、<span class="thesansmonocd_w5regular_">decode()</span>メソッドを呼び出して実際の文字列を取得しなければなりません。しかし、一度XMLテキストをPythonの文字列値として取得すれば、<i class="calibre5">.xml</i>ファイルに書き込んだり、関数に渡したり、ウェブリクエストに用いたり、その他文字列でできることなら何でもできます。</p>
</section>
</section>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec18">
<h3 class="h" id="calibre_link-1972"><span id="calibre_link-496"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">CSV、JSON、XMLはデータを保存するための一般的なプレーンテキストフォーマットです。人間にとって読みやすいと同時に、プログラムにとっても解析しやすいです。そのため、単純なスプレッドシートやウェブアプリのデータを扱うのによく使われます。Pythonの標準ライブラリにある<span class="thesansmonocd_w5regular_">csv</span>モジュール、<span class="thesansmonocd_w5regular_">json</span>モジュール、<span class="thesansmonocd_w5regular_">xml.etree.ElementTree</span>モジュールにより、これらのファイルの読み書きは非常に単純化されています。<span class="thesansmonocd_w5regular_">open()</span>関数でファイルを開いて自分で解析する必要はありません。</p>
<p class="tx">これらのフォーマットはPythonに固有のものではなく、他の多くのプログラミング言語やアプリケーションでも用いられます。これらのフォーマットを使用するアプリケーションとやり取りするPythonプログラムを書くのに、本章で学んだことが役立つことでしょう。</p>
</section>
<section type="division" aria-labelledby="sec19">
<h3 class="h" id="calibre_link-1973"><span id="calibre_link-497"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. ExcelにはあってCSVにはない機能は何ですか？</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">reader</span>オブジェクトや<span class="thesansmonocd_w5regular_">writer</span>オブジェクトを作成するために<span class="thesansmonocd_w5regular_">csv.reader()</span>や<span class="thesansmonocd_w5regular_">csv.writer()</span>に渡すものは何ですか？</p>
<p class="listnumber">  3. <span class="thesansmonocd_w5regular_">reader</span>オブジェクトや<span class="thesansmonocd_w5regular_">writer</span>オブジェクトを使用するためには<span class="thesansmonocd_w5regular_">File</span>オブジェクトをどのモードで開く必要がありますか？</p>
<p class="listnumber">  4. リストを引数に取り、CSVファイルに書き込むメソッドは何ですか？</p>
<p class="listnumber">  5. キーワード引数の<span class="thesansmonocd_w5regular_">delimiter</span>と<span class="thesansmonocd_w5regular_">lineterminator</span>はそれぞれどのような働きをしますか？</p>
<p class="listnumber">  6. CSV、JSON、XMLのうち、テキストエディタで編集しやすいのはどれですか？</p>
<p class="listnumber">  7. JSONデータの文字列を取りPythonのデータ構造を返す関数は何ですか？</p>
<p class="listnumber">  8. Pythonのデータ構造を取りJSONデータの文字列を返す関数は何ですか？</p>
<p class="listnumber">  9. 山かっこで囲まれたタグがあるHTMLと似ているデータ直列化フォーマットは何ですか？</p>
<p class="listnumber">10. JSONで<span class="thesansmonocd_w5regular_">None</span>値はどのように書きますか？</p>
<p class="listnumber">11. JSONでブール値はどのように書きますか？</p>
</section>
<section type="division" aria-labelledby="sec20">
<h3 class="h" id="calibre_link-1974"><span id="calibre_link-498"></span><span class="sans_futura_std_bold_b_">練習プログラム：Excel-CSV変換器</span></h3>
<p class="tni">Excelで数クリックすればスプレッドシートをCSVファイルとして保存できます。しかし、数百ものExcelファイルをCSVファイルに変換しなければならないとしたら、クリックするのに何時間もかかってしまいます。<span>第14章</span>で紹介した<span class="thesansmonocd_w5regular_">openpyxl</span>モジュールを使用して、現在の作業ディレクトリのExcelファイルをすべて読み取ってCSVファイルとして出力するプログラムを書いてください。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1975" aria-label="458"></span>一つのExcelファイルに複数のシートが存在する可能性がありますから、CSVファイルはシートごとに作成しなければなりません。CSVファイルの名前は<i class="calibre5">&lt;excel filename&gt;_&lt;sheet title&gt;.csv</i>としてください。<i class="calibre5">&lt;excel filename&gt;</i>は拡張子なしのExcelファイルの名前で（例えば、<i class="calibre5">spam_data.xlsx</i>ではなく<i class="calibre5">spam_data</i>）、<i class="calibre5">&lt;sheet title&gt;</i>は<span class="thesansmonocd_w5regular_">Worksheet</span>オブジェクトの<span class="thesansmonocd_w5regular_">title</span>属性に入っている文字列です。</p>
<p class="tx">このプログラムでは<span class="thesansmonocd_w5regular_">for</span>ループが多重の入れ子になります。プログラムの骨組みは以下のようになります。</p>
<pre class="pre"><code class="calibre9">for excel_file in os.listdir('.'):
    # 非xlsxファイルは飛ばし、workbookオブジェクトをロード
    for sheet_name in wb.sheetnames:
        # ワークブックのすべてのシートを反復処理
        # Excelのファイル名とシート名からCSVファイル名を作成
        # CSVファイル用のcsv.writerオブジェクトの作成

        # シートのすべての行を反復処理
        for row_num in range(1, sheet.max_row + 1):
            row_data = []    # 各セルとこのリストに追加
            # 行内の各セルを反復処理
            for col_num in range(1, sheet.max_column + 1):
                # row_dataに各セルのデータを追加
           
            # CSVファイルにrow_dataリストを書き込み

        csv_file.close()
</code></pre>
<p class="tx">本書のオンライン素材からZIPファイルの<i class="calibre5">excelSpreadsheets.zip</i>をダウンロードして、スプレッドシートをプログラムと同じディレクトリに展開してください。このファイルを使ってプログラムをテストできます。</p>
</section>
</section>
</div>


</div>



</body></html>