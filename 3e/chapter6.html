<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">







<div type="bodymatter" class="calibre" id="calibre_link-108">
<section type="chapter" role="doc-chapter" aria-labelledby="ch6">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1527" aria-label="109"></span>
<hgroup>
<h2 class="title" id="calibre_link-1528">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">6</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">リスト</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">本格的にプログラムを書き始める前に理解しておく必要がある事柄がもう少しあります。リスト型とタプル型のデータ型です。リストとタプルは複数の値を保持できるので、これらを使うと大量のデータを扱うプログラムを書きやすくなります。リストの中にリストを入れることができるので、階層構造のデータを扱えます。</p>
<p class="tx">本章では、リストの基礎を説明します。特定のデータ型と結びついた関数である、メソッドの説明をします。シーケンス型（リスト、タプル、文字列）について簡単に解説し、その異同を確認します。次章では、辞書型のデータ型を紹介します。</p>
<section type="division" aria-labelledby="sec1">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-870" aria-label="110"></span>
<h3 class="h" id="calibre_link-1529"><span id="calibre_link-109"></span><span class="sans_futura_std_bold_b_">リスト型</span></h3>
<p class="tni"><i class="calibre5">リスト</i> は複数の値を順番に保持する値です。<i class="calibre5">リスト値</i> という語は、リスト自体（ほかの値と同じように変数に格納したり関数に渡したりできます）を指し示すのであって、リスト値の中に入っている値を指し示すのではありません。リスト値は<span class="thesansmonocd_w5regular_">['cat', 'bat', 'rat', 'elephant']</span>のような形をしています。文字列値がクォーテーションマーク（'）で囲まれるのと同じように、リストは開き角かっこ（<span class="thesansmonocd_w5regular_">[</span>）で始まり閉じ角かっこ（<span class="thesansmonocd_w5regular_">]</span>）で終わります。</p>
<p class="tx">リストの中に入っている値を<i class="calibre5">要素（アイテム）</i>と呼びます。要素はカンマで分割されます（<i class="calibre5">カンマ区切り</i>）。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">[1, 2, 3]</b>  # 3つの整数のリスト
[1, 2, 3]
&gt;&gt;&gt; <b class="calibre10">['cat', 'bat', 'rat', 'elephant']</b>  # 4つの文字列のリスト
['cat', 'bat', 'rat', 'elephant']
&gt;&gt;&gt; <b class="calibre10">['hello', 3.1415, True, None, 42]</b>  # いろいろな値のリスト
['hello', 3.1415, True, None, 42]
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'bat', 'rat', 'elephant']
</code></pre>
<p class="tx">変数<span class="thesansmonocd_w5regular_">spam</span>には一つの値が代入されています(<span class="codeannotation" aria-label="annotation1">❶</span>)。リスト値です。リスト値は他の値を含みます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">[]</span>は中に値が入っていない空リストです。<span class="thesansmonocd_w5regular_">''</span>が空文字列であるのと似ています。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1530"><span id="calibre_link-110"></span><span class="sans_futura_std_heavy_oblique_bi_">インデックス</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">spam</span>という名前の変数に<span class="thesansmonocd_w5regular_">['cat', 'bat', 'rat', 'elephant']</span>というリストが格納されているとします。Pythonの<span class="thesansmonocd_w5regular_">spam[0]</span>というコードは<span class="thesansmonocd_w5regular_">'cat'</span>に評価され、<span class="thesansmonocd_w5regular_">spam[1]</span>は<span class="thesansmonocd_w5regular_">'bat'</span>に評価されます。リストに続く角かっこ内の整数は<i class="calibre5">インデックス</i>と呼ばれます。リストの最初の値はインデックス<span class="thesansmonocd_w5regular_">0</span>で、2番目の値がインデックス<span class="thesansmonocd_w5regular_">1</span>、3番目の値がインデックス<span class="thesansmonocd_w5regular_">2</span>です。図6-1は<span class="thesansmonocd_w5regular_">spam</span>に代入されたリスト値をインデックスとともに示しています。インデックスは<span class="thesansmonocd_w5regular_">0</span>から始まりますから、最後のインデックスはリストのサイズより1小さくなります。4つの要素のリストの最後のインデックスは<span class="thesansmonocd_w5regular_">3</span>です。</p>
<figure class="img"><img class="img2" id="calibre_link-705" src="images/000097.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 6-1：変数spamに格納されたリストとインデックスの対応</span></p></figcaption>
</figure>
<p class="tx">インデックスを試してみるために、次の式を対話型シェルに入力してください。変数<span class="thesansmonocd_w5regular_">spam</span>にリストを代入するところから始めます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam[0]</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1039" aria-label="111"></span>'cat'
&gt;&gt;&gt; <b class="calibre10">spam[1]</b>
'bat'
&gt;&gt;&gt; <b class="calibre10">spam[2]</b>
'rat'
&gt;&gt;&gt; <b class="calibre10">spam[3]</b>
'elephant'
&gt;&gt;&gt; <b class="calibre10">['cat', 'bat', 'rat', 'elephant'][3]</b>
'elephant'
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">'Hello, ' + spam[0]</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> 'Hello, cat'
&gt;&gt;&gt; <b class="calibre10">'The ' + spam[1] + ' ate the ' + spam[0] + '.'</b>
'The bat ate the cat.'
</code></pre>
<p class="tx">式<span class="thesansmonocd_w5regular_">'Hello, '</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">spam[0]</span>(<span class="codeannotation" aria-label="annotation1">❶</span>)が<span class="thesansmonocd_w5regular_">'Hello, '</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">'cat'</span>に評価されます。<span class="thesansmonocd_w5regular_">spam[0]</span>が<span class="thesansmonocd_w5regular_">'cat'</span>に評価されるからです。この式はさらに文字列<span class="thesansmonocd_w5regular_">'Hello, cat'</span>に評価されます(<span class="codeannotation" aria-label="annotation2">❷</span>)。</p>
<p class="tx">リストに入っている要素の個数を超えるインデックスを使うと、Pythonは<span class="thesansmonocd_w5regular_">IndexError</span> というエラーメッセージを表示します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam[10000]</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    spam[10000]
IndexError: list index out of range
</code></pre>
<p class="tx">リストの中にリストを入れることもできます。次のように、インデックスを複数書けば、リストの中のリストにアクセスできます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = [['cat', 'bat'], [10, 20, 30, 40, 50]]</b>
&gt;&gt;&gt; <b class="calibre10">spam[0]</b>
['cat', 'bat']
&gt;&gt;&gt; <b class="calibre10">spam[0][1]</b>
'bat'
&gt;&gt;&gt; <b class="calibre10">spam[1][4]</b>
50
</code></pre>
<p class="tx">最初のインデックスがどのリスト値かを指定し、2つ目のインデックスがそのリスト値の中の値を指し示します。例えば、<span class="thesansmonocd_w5regular_">spam[0][1]</span>は<span class="thesansmonocd_w5regular_">'bat'</span>になります。最初のリスト値の中の2番目の値です。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h4 class="h1" id="calibre_link-1531"><span id="calibre_link-111"></span><span class="sans_futura_std_heavy_oblique_bi_">負の数のインデックス</span></h4>
<p class="tni">インデックスは<span class="thesansmonocd_w5regular_">0</span>から始まって増えていきますが、負の整数をインデックスに使うこともできます。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam[-1]</b>  # 最後のインデックス
'elephant'
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-871" aria-label="112"></span>&gt;&gt;&gt; <b class="calibre10">spam[-3]</b>  # 最後から3番目のインデックス
'bat'
&gt;&gt;&gt; <b class="calibre10">'The ' + spam[-1] + ' is afraid of the ' + spam[-3] + '.'</b>
'The elephant is afraid of the bat.'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">-1</span>という整数はリストの最後のインデックスで、<span class="thesansmonocd_w5regular_">-2</span>は最後から2番目のインデックスです。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1532"><span id="calibre_link-112"></span><span class="sans_futura_std_heavy_oblique_bi_">スライス</span></h4>
<p class="tni">インデックスでリストから1つの値を取り出せるように、<i class="calibre5">スライス</i>でリストから複数の値を新しいリストの形式で取り出せます。スライスは、インデックスと同じように、角カッコの中で指定しますが、コロンの前後に2つの数値が入ります。インデックスとスライスの違いは次のとおりです。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">spam[2]</span>はリストのインデックスです（角かっこの中に整数が1つ）</li>
<li class="bl"><span class="thesansmonocd_w5regular_">spam[1:4]</span>はリストのスライスです（角かっこの中に整数が2つ）</li>
</ul>
<p class="tx">スライスでは、最初の整数がスライスを開始するインデックスで、2つ目の整数がスライスを終了するインデックスです。スライスにより作られたリストは、2つ目の整数のインデックスが指す値まで元のリストを切り取りますが、その値は含みません。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam[0:4]</b>
['cat', 'bat', 'rat', 'elephant']
&gt;&gt;&gt; <b class="calibre10">spam[1:3]</b>
['bat', 'rat']
&gt;&gt;&gt; <b class="calibre10">spam[0:-1]</b>
['cat', 'bat', 'rat']
</code></pre>
<p class="tx">短縮記法として、コロンの片側あるいは両側のインデックスを省略できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam[:2]</b>
['cat', 'bat']
&gt;&gt;&gt; <b class="calibre10">spam[1:]</b>
['bat', 'rat', 'elephant']
&gt;&gt;&gt; <b class="calibre10">spam[:]</b>
['cat', 'bat', 'rat', 'elephant']
</code></pre>
<p class="tx">最初のインデックス（コロンの左側）を省略すると、<span class="thesansmonocd_w5regular_">0</span>を指定したのと同じになり、リストの最初からになります。2つ目のインデックス（コロンの右側）を省略すると、リストの長さを指定したのと同じになり、リストの最後までになります。</p>
</section>
<section type="division" aria-labelledby="sec5">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-866" aria-label="113"></span>
<h4 class="h1" id="calibre_link-1533"><span id="calibre_link-113"></span><span class="sans_futura_std_heavy_oblique_bi_">len()関数</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">len()</span>関数にリスト値を渡すと、そのリストに入っている値の個数を返します。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'dog', 'moose']</b>
&gt;&gt;&gt; <b class="calibre10">len(spam)</b>
3
</code></pre>
<p class="tx">これはこの関数が文字列値の文字数をカウントするのに似ています。</p>
</section>
<section type="division" aria-labelledby="sec6">
<h4 class="h1" id="calibre_link-1534"><span id="calibre_link-114"></span><span class="sans_futura_std_heavy_oblique_bi_">値の更新</span></h4>
<p class="tni">通常、<span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">42</span>のように、代入文の左側には変数名が来ます。リストのインデックスを使って、そのインデックスの値を変更することもできます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam[1] = 'aardvark'</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'aardvark', 'rat', 'elephant']
&gt;&gt;&gt; <b class="calibre10">spam[2] = spam[1]</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'aardvark', 'aardvark', 'elephant']
&gt;&gt;&gt; <b class="calibre10">spam[-1] = 12345</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'aardvark', 'aardvark', 12345]
</code></pre>
<p class="tx">この例で、<span class="thesansmonocd_w5regular_">spam[1]</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'aardvark'</span>は「リスト<span class="thesansmonocd_w5regular_">spam</span>のインデックス<span class="thesansmonocd_w5regular_">1</span>の値に文字列<span class="thesansmonocd_w5regular_">'aardvark'</span>を代入する」という意味になります。<span class="thesansmonocd_w5regular_">-1</span>のような負の数をインデックスに指定して値を更新することもできます。</p>
</section>
<section type="division" aria-labelledby="sec7">
<h4 class="h1" id="calibre_link-1535"><span id="calibre_link-115"></span><span class="sans_futura_std_heavy_oblique_bi_">結合と繰り返し</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">+</span>演算子と<span class="thesansmonocd_w5regular_">*</span>演算子でリストの結合と繰り返しをできます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">[1, 2, 3] + ['A', 'B', 'C']</b>
[1, 2, 3, 'A', 'B', 'C']
&gt;&gt;&gt; <b class="calibre10">['X', 'Y', 'Z'] * 3</b>
['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z']
&gt;&gt;&gt; <b class="calibre10">spam = [1, 2, 3]</b>
&gt;&gt;&gt; <b class="calibre10">spam = spam + ['A', 'B', 'C']</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
[1, 2, 3, 'A', 'B', 'C']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">+</span>演算子は2つのリストを結合して新しいリスト値を作ります。<span class="thesansmonocd_w5regular_">*</span>演算子はリストを整数回繰り返して結合します。</p>
</section>
<section type="division" aria-labelledby="sec8">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-898" aria-label="114"></span>
<h4 class="h1" id="calibre_link-1536"><span id="calibre_link-116"></span><span class="sans_futura_std_heavy_oblique_bi_">del文</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">del</span>文はリストのインデックスを指定してその値を削除します。削除された値よりあとにある値はすべてインデックスが1つ繰り上がります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">del spam[2]</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'bat', 'elephant']
&gt;&gt;&gt; <b class="calibre10">del spam[2]</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'bat']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">del</span>文は「非代入」文のように変数自体を削除するのにも使えます。変数を削除してから使おうとすると、もうその変数は存在しなくなっているので、<span class="thesansmonocd_w5regular_">NameError</span>エラーが発生します。実務的には、変数自体を削除する必要はまずありませんが、リストから値を削除するのに<span class="thesansmonocd_w5regular_">del</span>文は使えます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec9">
<h3 class="h" id="calibre_link-1537"><span id="calibre_link-117"></span><span class="sans_futura_std_bold_b_">リストの操作</span></h3>
<p class="tni">プログラムを書き始めた頃には、一連の値を格納する変数をバラバラに作りたくなるかもしれません。例えば、自分が飼っているネコの名前を格納しようと、次のようなコードを書くかもしれません。</p>
<pre class="pre"><code class="calibre9">cat_name_1 = 'Zophie'
cat_name_2 = 'Pooka'
cat_name_3 = 'Simon'
cat_name_4 = 'Lady Macbeth'
</code></pre>
<p class="tx">これはよろしくないコードです。一つには、ネコの数が変わった場合に（飼っているネコが増える可能性があります）、変数を用意した数以上のネコの名前を保持することができません。また、このプログラムにはほとんど同じコードの繰り返しが多いという問題もあります。このことを確認するために、次のコードを<i class="calibre5">allMyCats1.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">print('Enter the name of cat 1:')
cat_name_1 = input()
print('Enter the name of cat 2:')
cat_name_2 = input()
print('Enter the name of cat 3:')
cat_name_3 = input()
print('Enter the name of cat 4:')
cat_name_4 = input()
print('The cat names are:')
print(cat_name_1 + ' ' + cat_name_2 + ' ' + cat_name_3 + ' ' + cat_name_4)
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-707" aria-label="115"></span>複数の繰り返しのような変数を使わずに、リスト値を含む1つの変数を使うことができます。例えば、以下のように<i class="calibre5">allMyCats1.py</i>プログラムを改良します。この新しいバージョンでは、1つのリストを使い、何匹のネコの名前でも保持できます。新しいファイルエディタウィンドウで、次のコードを<i class="calibre5">allMyCats2.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">cat_names = []
while True:
    print('Enter the name of cat ' + str(len(cat_names) + 1) +
      ' (Or enter nothing to stop.):')
    name = input()
    if name == '':
        break
    cat_names = cat_names + [name]  # リストの結合
print('The cat names are:')
for name in cat_names:
    print('  ' + name)
</code></pre>
<p class="tx">このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">Enter the name of cat 1 (Or enter nothing to stop.):
<b class="calibre10">Zophie</b>
Enter the name of cat 2 (Or enter nothing to stop.):
<b class="calibre10">Pooka</b>
Enter the name of cat 3 (Or enter nothing to stop.):
<b class="calibre10">Simon</b>
Enter the name of cat 4 (Or enter nothing to stop.):
<b class="calibre10">Lady Macbeth</b>
Enter the name of cat 5 (Or enter nothing to stop.):

The cat names are:
  Zophie
  Pooka
  Simon
  Lady Macbeth
</code></pre>
<p class="tx">リストを使えばデータが構造化され、繰り返しのような変数を使う場合よりも柔軟にデータを処理できます。</p>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1538"><span id="calibre_link-118"></span><span class="sans_futura_std_heavy_oblique_bi_">forループとリスト</span></h4>
<p class="tni"><span>第3章</span>では、<span class="thesansmonocd_w5regular_">for</span>ループを使ってコードのブロックを指定した回数だけ実行する方法を学習しました。技術的には、<span class="thesansmonocd_w5regular_">for</span>ループはコードブロックをリスト中の要素の個数回だけ繰り返し実行します。例えば、次のコードを実行してください。</p>
<pre class="pre"><code class="calibre9">for i in range(4):
    print(i)
</code></pre>
<p class="tni"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1195" aria-label="116"></span>このプログラムの出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">0
1
2
3
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">range(4)</span>が返す値は、<span class="thesansmonocd_w5regular_">[0, 1, 2, 3]</span>と似たシーケンス値（連続値）です。以下のプログラムは上のプログラムと同じ出力になります。</p>
<pre class="pre"><code class="calibre9">for i in [0, 1, 2, 3]:
    print(i)
</code></pre>
<p class="tx">この<span class="thesansmonocd_w5regular_">for</span>ループは、変数<span class="thesansmonocd_w5regular_">i</span>にリスト<span class="thesansmonocd_w5regular_">[0, 1, 2, 3]</span>の値を順番に設定して節を実行します。</p>
<p class="tx">Pythonでは、<span class="thesansmonocd_w5regular_">for</span>ループで<span class="thesansmonocd_w5regular_">range(len(</span><span class="sans_thesansmonocd_w5regular_italic_">some_list</span><span class="thesansmonocd_w5regular_">))</span>を使ってリストのインデックスを反復処理することがよくあります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">supplies = ['pens', 'staplers', 'flamethrowers', 'binders']</b>
&gt;&gt;&gt; <b class="calibre10">for i in range(len(supplies)):</b>
...     <b class="calibre10">print('Index ' + str(i) + ' in supplies is: ' + supplies[i])</b>
...
Index 0 in supplies is: pens
Index 1 in supplies is: staplers
Index 2 in supplies is: flamethrowers
Index 3 in supplies is: binders
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span> ループで<span class="thesansmonocd_w5regular_">range(len(supplies))</span>を使うと、ループ中のコードでインデックス（<span class="thesansmonocd_w5regular_">i</span>）とそのインデックスに対応する値（<span class="thesansmonocd_w5regular_">supplies[i]</span>）の両方にアクセスできるので便利です。何と言っても、<span class="thesansmonocd_w5regular_">range(len(supplies))</span>はリスト<span class="thesansmonocd_w5regular_">supplies</span>の中に入っている要素の個数に関わらずすべてのインデックスを反復処理できます。</p>
</section>
<section type="division" aria-labelledby="sec11">
<h4 class="h1" id="calibre_link-1539"><span id="calibre_link-119"></span><span class="sans_futura_std_heavy_oblique_bi_">in演算子とnot in演算子</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">in</span>演算子と<span class="thesansmonocd_w5regular_">not in</span>演算子を使うと、ある値がリストの中に入っているかどうかを判定できます。他の演算子と同様に、<span class="thesansmonocd_w5regular_">in</span>と<span class="thesansmonocd_w5regular_">not in</span>は式中の2つの値の間で使います。探す値と探すリストの間で使います。その式はブール値に評価されます。対話型シェルに以下のコードを入力して確かめてみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'howdy' in ['hello', 'hi', 'howdy', 'heyas']</b>
True
&gt;&gt;&gt; <b class="calibre10">spam = ['hello', 'hi', 'howdy', 'heyas']</b>
&gt;&gt;&gt; <b class="calibre10">'cat' in spam</b>
False
&gt;&gt;&gt; <b class="calibre10">'howdy' not in spam</b>
False
&gt;&gt;&gt; <b class="calibre10">'cat' not in spam</b>
True
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1241" aria-label="117"></span>以下のプログラムは、ユーザーが入力したペットの名前がリストの中にあるかどうかを判定します。新しいファイルエディタウィンドウを開いて、以下のコードを<i class="calibre5">myPets.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">my_pets = ['Zophie', 'Pooka', 'Fat-tail']
print('Enter a pet name:')
name = input()
if name not in my_pets:
    print('I do not have a pet named ' + name)
else:
    print(name + ' is my pet.')
</code></pre>
<p class="tx">出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">Enter a pet name:
<b class="calibre10">Footfoot</b>
I do not have a pet named Footfoot
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">not in</span>演算子は<span class="thesansmonocd_w5regular_">not</span>ブール演算子と別物であることに注意してください。</p>
</section>
<section type="division" aria-labelledby="sec12">
<h4 class="h1" id="calibre_link-1540"><span id="calibre_link-120"></span><span class="sans_futura_std_heavy_oblique_bi_">多重代入</span></h4>
<p class="tni"><i class="calibre5">多重代入</i>は、技術的には<i class="calibre5">タプルアンパック</i>と呼ばれますが、複数の変数にリストの値を1行で代入する短縮記法です。次のようにする代わりに</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">cat = ['fat', 'gray', 'loud']</b>
&gt;&gt;&gt; <b class="calibre10">size = cat[0]</b>
&gt;&gt;&gt; <b class="calibre10">color = cat[1]</b>
&gt;&gt;&gt; <b class="calibre10">disposition = cat[2]</b>
</code></pre>
<p class="tni">次のようにできるということです。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">cat = ['fat', 'gray', 'loud']</b>
&gt;&gt;&gt; <b class="calibre10">size, color, disposition = cat</b>
</code></pre>
<p class="tx">変数の個数とリストの要素数は一致しなければなりません。一致しなければ<span class="thesansmonocd_w5regular_">ValueError</span>エラーが発生します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">cat = ['fat', 'gray', 'loud']</b>
&gt;&gt;&gt; <b class="calibre10">size, color, disposition, name = cat</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    size, color, disposition, name = cat
ValueError: not enough values to unpack (expected 4, got 3)
</code></pre>
<p class="tx">多重代入を使うと複数行で代入するよりもコードが短く読みやすくなります。</p>
</section>
<section type="division" aria-labelledby="sec13">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1017" aria-label="118"></span>
<h4 class="h1" id="calibre_link-1541"><span id="calibre_link-121"></span><span class="sans_futura_std_heavy_oblique_bi_">リストの要素の数え上げ</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">for</span>ループでリストの要素のインデックスを取得するのに、<span class="thesansmonocd_w5regular_">range(len(</span><span class="sans_thesansmonocd_w5regular_italic_">some_list</span><span class="thesansmonocd_w5regular_">))</span>の代わりに、<span class="thesansmonocd_w5regular_">enumerate()</span>関数を呼び出すこともできます。ループの反復ごとに、<span class="thesansmonocd_w5regular_">enumerate()</span>は、リストの要素のインデックスと要素そのものの2つの値を返します。例えば、このコードは<span>「forループとリスト」</span>で紹介したコードと同じ動きをします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">supplies = ['pens', 'staplers', 'flamethrowers', 'binders']</b>
&gt;&gt;&gt; <b class="calibre10">for index, item in enumerate(supplies):</b>
...     <b class="calibre10">print('Index ' + str(index) + ' in supplies is: ' + item)</b>
...
Index 0 in supplies is: pens
Index 1 in supplies is: staplers
Index 2 in supplies is: flamethrowers
Index 3 in supplies is: binders
</code></pre>
<p class="tx">ループで要素と要素のインデックスの両方が必要な場合に、<span class="thesansmonocd_w5regular_">enumerate()</span>関数が役立ちます。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1542"><span id="calibre_link-122"></span><span class="sans_futura_std_heavy_oblique_bi_">ランダム選択と順序</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">random</span>モジュールにはリストを引数に取る関数がいくつかあります。<span class="thesansmonocd_w5regular_">random.choice()</span>関数はリストから要素をランダムに選んで返します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import random</b>
&gt;&gt;&gt; <b class="calibre10">pets = ['Dog', 'Cat', 'Moose']</b>
&gt;&gt;&gt; <b class="calibre10">random.choice(pets)</b>
'Cat'
&gt;&gt;&gt; <b class="calibre10">random.choice(pets)</b>
'Cat'
&gt;&gt;&gt; <b class="calibre10">random.choice(pets)</b>
'Dog'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">random.choice(</span><span class="sans_thesansmonocd_w5regular_italic_">some_list</span><span class="thesansmonocd_w5regular_">)</span>は<span class="sans_thesansmonocd_w5regular_italic_">some_list</span><span class="thesansmonocd_w5regular_">[random.randint(0, len(</span><span class="sans_thesansmonocd_w5regular_italic_">some_list</span><span class="thesansmonocd_w5regular_">) – 1]</span>を簡単に書いたものだと考えられます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">random.shuffle()</span>関数はリストの要素の順番をその場でシャッフルします。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import random</b>
&gt;&gt;&gt; <b class="calibre10">people = ['Alice', 'Bob', 'Carol', 'David']</b>
&gt;&gt;&gt; <b class="calibre10">random.shuffle(people)</b>
&gt;&gt;&gt; <b class="calibre10">people</b>
['Carol', 'David', 'Alice', 'Bob']
&gt;&gt;&gt; <b class="calibre10">random.shuffle(people)</b>
&gt;&gt;&gt; <b class="calibre10">people</b>
['Alice', 'David', 'Bob', 'Carol']
</code></pre>
<p class="tx">この関数は、新しいリストを返すのではなく、リストをその場で変更します。</p>
</section>
</section>
<section type="division" aria-labelledby="sec15">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-843" aria-label="119"></span>
<h3 class="h" id="calibre_link-1543"><span id="calibre_link-123"></span><span class="sans_futura_std_bold_b_">累算代入演算子(複合代入演算子)</span></h3>
<p class="tni">文字列に対して使える<span class="thesansmonocd_w5regular_">+</span>演算子と<span class="thesansmonocd_w5regular_">*</span>演算子は、リストに対しても使えます。ちょっと寄り道して累算代入演算子の説明をします。変数に値を代入するときにその変数を使うことはよくあります。例えば、変数<span class="thesansmonocd_w5regular_">spam</span>に<span class="thesansmonocd_w5regular_">42</span>を代入してから、その値を<span class="thesansmonocd_w5regular_">1</span>増やす場合に、次のようなコードを書くでしょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = 42</b>
&gt;&gt;&gt; <b class="calibre10">spam = spam + 1</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
43
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">+=</span>累算代入演算子（イコール記号のあとに通常の演算子を書きます）を使えば同じ内容を短く書けます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = 42</b>
&gt;&gt;&gt; <b class="calibre10">spam += 1</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
43
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">+</span>、<span class="thesansmonocd_w5regular_">-</span>、<span class="thesansmonocd_w5regular_">*</span>、<span class="thesansmonocd_w5regular_">/</span>、<span class="thesansmonocd_w5regular_">%</span>の累算代入演算子を表6-1にまとめました。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-708"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 6-1：</span></span><span class="sans_futura_std_book_">累算代入演算子</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">累算代入演算子</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">同等の代入文</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">+=</span> <span class="thesansmonocd_w5regular_">1</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">1</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">spam -=</span> <span class="thesansmonocd_w5regular_">1</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam - 1</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">spam *=</span> <span class="thesansmonocd_w5regular_">1</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam * 1</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">spam /=</span> <span class="thesansmonocd_w5regular_">1</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam / 1</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">spam %=</span> <span class="thesansmonocd_w5regular_">1</span></p></td>
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam % 1</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span class="thesansmonocd_w5regular_">+=</span>演算子は文字列の結合やリストの結合ができますし、<span class="thesansmonocd_w5regular_">*=</span>演算子は文字列の繰り返しやリストの繰り返しができます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = 'Hello,'</b>
&gt;&gt;&gt; <b class="calibre10">spam += ' world!'  </b># spam = spam + 'world!'と同じ
&gt;&gt;&gt; <b class="calibre10">spam</b>
'Hello, world!'
&gt;&gt;&gt; <b class="calibre10">bacon = ['Zophie']</b>
&gt;&gt;&gt; <b class="calibre10">bacon *= 3  </b># bacon = bacon * 3と同じ
&gt;&gt;&gt; <b class="calibre10">bacon</b>
['Zophie', 'Zophie', 'Zophie']
</code></pre>
<p class="tx">多重代入と同じように、累算代入演算子はコードを短くて読みやすくする短縮記法です。</p>
</section>
<section type="division" aria-labelledby="sec16">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-916" aria-label="120"></span>
<h3 class="h" id="calibre_link-1544"><span id="calibre_link-124"></span><span class="sans_futura_std_bold_b_">メソッド</span></h3>
<p class="tni"><i class="calibre5">メソッド</i>は、値について<i class="calibre5">呼び出される</i>関数のことです。例えば、<span class="thesansmonocd_w5regular_">spam</span>にリスト値が格納されているとしたら、<span class="thesansmonocd_w5regular_">spam.index('hello')</span>のようにそのリスト値について<span class="thesansmonocd_w5regular_">index()</span>リストメソッド（すぐあとで説明します）を呼び出せます。値とドット（.）に続けてメソッド名を書きます。</p>
<p class="tx">それぞれのデータ型には所定のメソッドがあります。リスト型だと、リストの中に入っている値の検索、追加、削除、その他の操作をできるメソッドがあります。メソッドは値と必然的に結びついている関数であると捉えることができます。リスト値が<span class="thesansmonocd_w5regular_">spam</span>に格納されている先ほどの例で言うと、<span class="thesansmonocd_w5regular_">index(spam, 'hello')</span>のように関数を呼び出すと考えることができます（実際にこのような呼び出し方はできず、あくまでも考え方です）。<span class="thesansmonocd_w5regular_">index()</span>はリストメソッドであって関数ではありませんから、<span class="thesansmonocd_w5regular_">spam.index('hello')</span>と呼び出します。リスト値について<span class="thesansmonocd_w5regular_">index()</span>を呼び出すと、Pythonは<span class="thesansmonocd_w5regular_">index()</span>をリストメソッドとして扱います。以下ではリストメソッドについて説明します。</p>
<section type="division" aria-labelledby="sec17">
<h4 class="h1" id="calibre_link-1545"><span id="calibre_link-125"></span><span class="sans_futura_std_heavy_oblique_bi_">値の検索</span></h4>
<p class="tni">リスト値には値を渡せる<span class="thesansmonocd_w5regular_">index()</span>メソッドがあります。その値がリストの中に存在すれば、その値のインデックスを返します。その値がリストの中に存在しなければ、<span class="thesansmonocd_w5regular_">ValueError</span>エラーが発生します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['hello', 'hi', 'howdy', 'heyas']</b>
&gt;&gt;&gt; <b class="calibre10">spam.index('hello')</b>
0
&gt;&gt;&gt; <b class="calibre10">spam.index('heyas')</b>
3
&gt;&gt;&gt; <b class="calibre10">spam.index('howdy howdy howdy')</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    spam.index('howdy howdy howdy')
ValueError: 'howdy howdy howdy' is not in list
</code></pre>
<p class="tx">その値がリストの中に複数存在すれば、最初に見つかった値のインデックスを返します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka']</b>
&gt;&gt;&gt; <b class="calibre10">spam.index('Pooka')</b>
1
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">index()</span>は<span class="thesansmonocd_w5regular_">3</span>ではなく<span class="thesansmonocd_w5regular_">1</span>を返します。</p>
</section>
<section type="division" aria-labelledby="sec18">
<h4 class="h1" id="calibre_link-1546"><span id="calibre_link-126"></span><span class="sans_futura_std_heavy_oblique_bi_">値の追加</span></h4>
<p class="tni">リストに新しい値を追加するには、<span class="thesansmonocd_w5regular_">append()</span>メソッドと<span class="thesansmonocd_w5regular_">insert()</span>メソッドを使います。<span class="thesansmonocd_w5regular_">append()</span>メソッドはリストの最後に値を追加します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'dog', 'bat']</b>
&gt;&gt;&gt; <b class="calibre10">spam.append('moose')</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'dog', 'bat', 'moose']
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-939" aria-label="121"></span><span class="thesansmonocd_w5regular_">insert()</span>メソッドは、リストのどこにでも値を追加することができます。<span class="thesansmonocd_w5regular_">insert()</span>の第一引数は値を挿入するインデックスで、第二引数は挿入する値です。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'dog', 'bat']</b>
&gt;&gt;&gt; <b class="calibre10">spam.insert(1, 'chicken'</b>)
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'chicken', 'dog', 'bat']
</code></pre>
<p class="tx">これは、<span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam.append('moose')</span>や<span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam.insert(1, 'chicken')</span>のような代入文ではないことに注意してください。<span class="thesansmonocd_w5regular_">append()</span>と<span class="thesansmonocd_w5regular_">insert()</span>の返り値は<span class="thesansmonocd_w5regular_">None</span>ですので、それを新しい変数の値として格納することはないでしょう。これらのメソッドはリストをその場で変更します。<span>「ミュータブルとイミュータブル」</span>で詳しく説明します。</p>
<p class="tx">データ型ごとにメソッドがあります。<span class="thesansmonocd_w5regular_">append()</span>と<span class="thesansmonocd_w5regular_">insert()</span>はリストメソッドで、リスト値についてのみ呼び出せます。文字列値や整数値について呼び出すことはできません。そのようなことをしようとするとどうなるか、対話型シェルで以下のコードを入力して確かめてみます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">eggs = 'hello'</b>
&gt;&gt;&gt; <b class="calibre10">eggs.append('world')</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    eggs.append('world')
AttributeError: 'str' object has no attribute 'append'
&gt;&gt;&gt; <b class="calibre10">bacon = 42</b>
&gt;&gt;&gt; <b class="calibre10">bacon.insert(1, 'world')</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    bacon.insert(1, 'world')
AttributeError: 'int' object has no attribute 'insert'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">AttributeError</span>エラーメッセージが表示されます。</p>
</section>
<section type="division" aria-labelledby="sec19">
<h4 class="h1" id="calibre_link-1547"><span id="calibre_link-127"></span><span class="sans_futura_std_heavy_oblique_bi_">値の削除</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">remove()</span>メソッドはリストから削除したい値を引数に取ります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam.remove('bat')</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['cat', 'rat', 'elephant']
</code></pre>
<p class="tx">リストの中に存在しない値を削除しようとすると、<span class="thesansmonocd_w5regular_">ValueError</span>エラーが発生します。例えば、対話型シェルで次のように入力して、エラーメッセージが表示されるのを確認してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'elephant']</b>
&gt;&gt;&gt; <b class="calibre10">spam.remove('chicken')</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1103" aria-label="122"></span>Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    spam.remove('chicken')
ValueError: list.remove(x): x not in list
</code></pre>
<p class="tx">リストの中に複数回登場する値については、最初の値のみが削除されます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'bat', 'rat', 'cat', 'hat', 'cat']</b>
&gt;&gt;&gt; <b class="calibre10">spam.remove('cat')</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['bat', 'rat', 'cat', 'hat', 'cat']
</code></pre>
<p class="tx">リストから削除したい値のインデックスがわかっている場合は<span class="thesansmonocd_w5regular_">del</span>文を使い、値をもとに削除したい場合は<span class="thesansmonocd_w5regular_">remove()</span>メソッドを使います。</p>
</section>
<section type="division" aria-labelledby="sec20">
<h4 class="h1" id="calibre_link-1548"><span id="calibre_link-128"></span><span class="sans_futura_std_heavy_oblique_bi_">値の並べ替え</span></h4>
<p class="tni">数値のリストまたは文字列のリストについては、<span class="thesansmonocd_w5regular_">sort()</span>メソッドで並べ替えできます。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = [2, 5, 3.14, 1, -7]</b>
&gt;&gt;&gt; <b class="calibre10">spam.sort()</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
[-7, 1, 2, 3.14, 5]
&gt;&gt;&gt; <b class="calibre10">spam = ['Ants', 'Cats', 'Dogs', 'Badgers', 'Elephants']</b>
&gt;&gt;&gt; <b class="calibre10">spam.sort()</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['Ants', 'Badgers', 'Cats', 'Dogs', 'Elephants']
</code></pre>
<p class="tx">数値については小さい順、文字列についてはアルファベット順に並べ替えます。<span class="thesansmonocd_w5regular_">reverse</span>キーワード引数（名前付きパラメータ）に<span class="thesansmonocd_w5regular_">True</span>を渡すと、値を逆順に並べ替えられます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam.sort(reverse=True)</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['Elephants', 'Dogs', 'Cats', 'Badgers', 'Ants']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">sort()</span>メソッドについては次の3点に注意してください。第一に、リストをその場で並べ替えますので、<span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam.sort()</span>のように返り値を変数に格納しないでください。</p>
<p class="tx">第二に、数値と文字列値が混在しているリストを並べ替えることはできません。どのように並べ替えたらよいかわからないからです。以下のコードを対話型シェルに入力すると、 <span class="thesansmonocd_w5regular_">TypeError</span>エラーが発生します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = [1, 3, 2, 4, 'Alice', 'Bob']</b>
&gt;&gt;&gt; <b class="calibre10">spam.sort()</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    spam.sort()
TypeError: '&lt;' not supported between instances of 'str' and 'int'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-872" aria-label="123"></span>第三に、文字列については、正確に言うと、アルファベット順ではなく<i class="calibre5">ASCII順</i>に並べ替えます。大文字は小文字の後に来るので、小文字の<i class="calibre5">a</i>は大文字の<i class="calibre5">Z</i>の後に来ます。例えば、次のように対話型シェルに入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['Alice', 'ants', 'Bob', 'badgers', 'Carol', 'cats']</b>
&gt;&gt;&gt; <b class="calibre10">spam.sort()</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['Alice', 'Bob', 'Carol', 'ants', 'badgers', 'cats']
</code></pre>
<p class="tx">アルファベット順に値を並べ替えたければ、<span class="thesansmonocd_w5regular_">sort()</span>メソッドを呼び出すときに、キーワード引数<span class="thesansmonocd_w5regular_">key</span>に<span class="thesansmonocd_w5regular_">str.lower</span>を渡してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['a', 'z', 'A', 'Z']</b>
&gt;&gt;&gt; <b class="calibre10">spam.sort(key=str.lower)</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['a', 'A', 'z', 'Z']
</code></pre>
<p class="tx">この引数は、リストの中に入っている値を変更しませんが、あたかもすべて小文字であるかのように扱います。</p>
</section>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1549"><span id="calibre_link-129"></span><span class="sans_futura_std_heavy_oblique_bi_">値を逆の順番にする</span></h4>
<p class="tni">リストの中に入っている要素の順番を逆にする必要があれば、<span class="thesansmonocd_w5regular_">reverse()</span>リストメソッドを呼び出します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cat', 'dog', 'moose']</b>
&gt;&gt;&gt; <b class="calibre10">spam.reverse()</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
['moose', 'dog', 'cat']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">sort()</span>リストメソットと同様に、<span class="thesansmonocd_w5regular_">reverse()</span>はリストを返しません。ですので、<span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam.reverse()</span>ではなく<span class="thesansmonocd_w5regular_">spam.reverse()</span>と書きます。</p>
<aside class="box" aria-label="box-11">
<p class="bt" id="calibre_link-1550"><span class="sans_futura_std_bold_b_">Pythonのインデントルールの例外</span></p>
<p class="btni"><span class="sans_futura_std_book_">多くの場合、コードの行のインデント量によりPythonはブロックを判断しますが、このルールには例外があります。例えば、リストを複数行にわたって定義することができます。このとき、インデントは関係なくなります。角カッコが閉じられるまでリストの定義が終わっていないとわかるからです。つまり、次のようなコードを書くことができます。</span></p>
<pre class="pre"><code class="calibre9"><span class="thesansmonocd_w5regular_">spam = ['apples',</span>
 'oranges',
                  'bananas',
'cats']
print(spam[0]) # applesを表示
</code></pre>
<p class="boxb-last"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-845" aria-label="124"></span><span class="sans_futura_std_book_">もちろん、実際的には、あとで紹介する「リストを使った魔法の8ボール」の</span><span class="thesansmonocd_w5regular_">messages</span>リストのように、読みやすく書きます。</p>
<p class="boxb-last"><span class="sans_futura_std_book_"></span><span class="sans_futura_std_book_oblique_i_">行継続文字</span><span class="sans_futura_std_book_">（</span><span class="thesansmonocd_w5regular_">\</span><span class="sans_futura_std_book_">）を行末に置くと、1行の命令を複数行で書くことができます。</span><span class="thesansmonocd_w5regular_">\</span><span class="sans_futura_std_book_">は「この命令は次の行に続きます」と読めます。</span><span class="thesansmonocd_w5regular_">\</span><span class="sans_futura_std_book_">の後の行のインデントは関係なくなります。。例えば、次のコードはPythonの正しいコードです。</span></p>
<pre class="pre"><code class="calibre9"><span class="thesansmonocd_w5regular_">print('Four score and seven ' + \</span>
      'years ago...')
</code></pre>
<p class="boxb-last"><span class="sans_futura_std_book_">Pythonの長いコードを少し読みやすくするのに使えるテクニックです。</span></p>
</aside>
</section>
</section>
<section type="division" aria-labelledby="sec22">
<h3 class="h" id="calibre_link-1551"><span id="calibre_link-130"></span><span class="sans_futura_std_bold_b_">短絡ブール演算子</span></h3>
<p class="tni">ブール演算子には見逃しやすい振る舞いがあります。<span class="thesansmonocd_w5regular_">and</span>演算子でつながれた値のどちらか一方でも<span class="thesansmonocd_w5regular_">False</span>なら式全体が<span class="thesansmonocd_w5regular_">False</span>になり、<span class="thesansmonocd_w5regular_">or</span>演算子でつながれた値のどちらか一方でも<span class="thesansmonocd_w5regular_">True</span>なら式全体が<span class="thesansmonocd_w5regular_">True</span>になることを思い出してください。<span class="thesansmonocd_w5regular_">False and spam</span>という式があるとすると、変数<span class="thesansmonocd_w5regular_">spam</span>が<span class="thesansmonocd_w5regular_">True</span>だろうが<span class="thesansmonocd_w5regular_">False</span>だろうが関係なく、式全体は<span class="thesansmonocd_w5regular_">False</span>になります。同じことは<span class="thesansmonocd_w5regular_">True or spam</span>にも言え、<span class="thesansmonocd_w5regular_">spam</span>の値に関係なく式全体は<span class="thesansmonocd_w5regular_">True</span>になります。</p>
<p class="tx">Pythonは（他のプログラミング言語でもたいていそうですが）、この事実を利用してブール演算子の右側を調べずにコードを少しでも速く実行できるように最適化します。これは<i class="calibre5">短絡</i>と呼ばれます。多くの場合、Pythonが式全体を評価しなくても（数マイクロ秒速くなることを別として）振る舞いに変わりありません。ただし、この短絡という性質が違いをもたらす場合があります。リストの最初の要素が<span class="thesansmonocd_w5regular_">'cat'</span>かどうかを調べる次のプログラムを見てください。</p>
<pre class="pre"><code class="calibre9">spam = ['cat', 'dog']
if spam[0] == 'cat':
    print('A cat is the first item.')
else:
    print('The first item is not a cat.')
</code></pre>
<p class="tx">このプログラムは<span class="thesansmonocd_w5regular_">A cat is the first item.</span>と表示します。しかし、リスト<span class="thesansmonocd_w5regular_">spam</span>が空だと、<span class="thesansmonocd_w5regular_">spam[0]</span>が<span class="thesansmonocd_w5regular_">IndexError: list Index out of range</span>エラーを引き起こします。これを修正するために、短絡を活用して<span class="thesansmonocd_w5regular_">if</span>文の条件を調整します。 </p>
<pre class="pre"><code class="calibre9">spam = []
if len(spam) &gt; 0 and spam[0] == 'cat':
    print('A cat is the first item.')
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-710" aria-label="125"></span>else:
    print('The first item is not a cat.')
</code></pre>
<p class="tx">このプログラムがエラーを発生させることはありません。<span class="thesansmonocd_w5regular_">len(spam) &gt; 0</span> が<span class="thesansmonocd_w5regular_">False</span>だと（リスト<span class="thesansmonocd_w5regular_">spam</span>が空だと）、短絡<span class="thesansmonocd_w5regular_">and</span>演算子は、<span class="thesansmonocd_w5regular_">IndexError</span>エラーを発生させる<span class="thesansmonocd_w5regular_">spam[0]</span> <span class="thesansmonocd_w5regular_">==</span> <span class="thesansmonocd_w5regular_">'cat'</span>のコードを無視します。<span class="thesansmonocd_w5regular_">and</span>演算子や<span class="thesansmonocd_w5regular_">or</span>演算子を使うときには、この短絡を頭の片隅に置いておいてください。</p>
</section>
<section type="division" aria-labelledby="sec23">
<h3 class="h" id="calibre_link-1552"><span id="calibre_link-131"></span><span class="sans_futura_std_bold_b_">短いプログラム：リストを使った魔法の8ボール</span></h3>
<p class="tni">リストを使うと、<span>第4章</span>の<i class="calibre5">magic8Ball.py</i>プログラムをもっとエレガントに書くことができます。ほぼ同じ<span class="thesansmonocd_w5regular_">elif</span>文を何度も書かずに一つのリストを作成します。　新しいファイルエディタウィンドウを開いて、以下のコードを<i class="calibre5">magic8Ball2.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import random

messages = ['It is certain',
    'It is decidedly so',
    'Yes definitely',
    'Reply hazy try again',
    'Ask again later',
    'Concentrate and ask again',
    'My reply is no',
    'Outlook not so good',
    'Very doubtful']

print('Ask a yes or no question:')
input('&gt;')
print(messages[random.randint(0, len(messages) - 1)])
</code></pre>
<p class="tx">このプログラムを実行すると、第4章の<i class="calibre5">magic8Ball.py</i>と同じ動作をします。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">random.randint(0, len(messages) - 1)</span>を呼び出してランダムな数値を生成し、その数値をインデックスに使います。<span class="thesansmonocd_w5regular_">messages</span>のサイズが変わっても同じように動作します。つまり、<span class="thesansmonocd_w5regular_">0</span>から<span class="thesansmonocd_w5regular_">len(messages) - 1</span>までのランダムな数値を生成します。このアプローチでは、コードの他の行を変更せずにリスト<span class="thesansmonocd_w5regular_">messages</span>へのメッセージの追加や削除が簡単にできます。あとでコードを変更するときに変更しなければならない行が少なければ、それだけバグを混入する可能性も少なくなります。</p>
<p class="tx">リストからランダムに要素を選択することはよくありますから、<span class="thesansmonocd_w5regular_">random.randint(0, len(messages) – 1)</span>と同じ動作をする<span class="thesansmonocd_w5regular_">random.choice(messages)</span>関数が存在します。</p>
</section>
<section type="division" aria-labelledby="sec24">
<h3 class="h" id="calibre_link-1553"><span id="calibre_link-132"></span><span class="sans_futura_std_bold_b_">シーケンス型</span></h3>
<p class="tni">順序付けられた値を表すのはリストに限られません。例えば、文字列を文字のリストだと考えれば、文字列とリストは似ています。Pythonのシーケンス型には、リスト、文字列、<span class="thesansmonocd_w5regular_">range()</span>関数の返り値であるrangeオブジェクト、タプル（すぐあとの<span>「タプル型」</span>で説明します）が含まれます。リストでできることは文字列その他のシーケンス型でもできます。それを確かめるために、以下のように対話型シェルで試してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Zophie'</b>
&gt;&gt;&gt; <b class="calibre10">name[0]</b>
'Z'
&gt;&gt;&gt; <b class="calibre10">name[-2]</b>
'i'
&gt;&gt;&gt; <b class="calibre10">name[0:4]</b>
'Zoph'
&gt;&gt;&gt; <b class="calibre10">'Zo' in name</b>
True
&gt;&gt;&gt; <b class="calibre10">'z' in name</b>
False
&gt;&gt;&gt; <b class="calibre10">'p' not in name</b>
False
&gt;&gt;&gt; <b class="calibre10">for i in name:</b>
...     <b class="calibre10">print('* * * ' + i + ' * * *')</b>
...
* * * Z * * *
* * * o * * *
* * * p * * *
* * * h * * *
* * * i * * *
* * * e * * *
</code></pre>
<p class="tx">インデックスによる取得、スライス、<span class="thesansmonocd_w5regular_">for</span>ループ、<span class="thesansmonocd_w5regular_">len()</span>関数、<span class="thesansmonocd_w5regular_">in</span>演算子と<span class="thesansmonocd_w5regular_">not in</span>演算子といった、リストでできる操作をシーケンス型の値ではすべて行うことができます。</p>
<section type="division" aria-labelledby="sec25">
<h4 class="h1" id="calibre_link-1554"><span id="calibre_link-133"></span><span class="sans_futura_std_heavy_oblique_bi_">ミュータブルとイミュータブル</span></h4>
<p class="tni">リストと文字列には大きな違いが一つあります。リスト値は<i class="calibre5">ミュータブル</i>です。つまり、値の追加、削除、更新ができます。これに対し、文字列は<i class="calibre5">イミュータブル</i>で、変更できません。文字列に文字を再代入しようとしたら、<span class="thesansmonocd_w5regular_">TypeError</span>エラーが発生します。以下の対話型シェルで確認してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Zophie a cat'</b>
&gt;&gt;&gt; <b class="calibre10">name[7] = 'the'</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    name[7] = 'the'
TypeError: 'str' object does not support item assignment
</code></pre>
<p class="tx">文字列を「変化」させる正しいやり方は、スライスと結合を用いて<i class="calibre5">新しい</i>文字列を組み立てるというやり方です。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Zophie a cat'</b>
&gt;&gt;&gt; <b class="calibre10">new_name = name[0:7] + 'the' + name[8:12]</b>
&gt;&gt;&gt; <b class="calibre10">name</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-711" aria-label="127"></span>'Zophie a cat'
&gt;&gt;&gt;<b class="calibre10"> new_name</b>
'Zophie the cat'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">[0:7]</span>と<span class="thesansmonocd_w5regular_">[8:12]</span>で変化させない文字を取得しています。元の<span class="thesansmonocd_w5regular_">'Zophie a cat'</span>という文字列に手を加えていないことに注意してください。文字列はイミュータブルです。</p>
<p class="tx">リスト値はミュータブルで変更できるのですが、次のコードの2行目はリスト<span class="thesansmonocd_w5regular_">eggs</span>を変更していません。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">eggs = ['A', 'B', 'C']</b>
&gt;&gt;&gt; <b class="calibre10">eggs = ['x', 'y', 'z']</b>
&gt;&gt;&gt; <b class="calibre10">eggs</b>
['x', 'y', 'z']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">eggs</span>の中に入っている値は変更されていません。そうではなく、全く新しい別のリスト値（<span class="thesansmonocd_w5regular_">['x', 'y', 'z']</span>）が古いリスト値（<span class="thesansmonocd_w5regular_">['A', 'B', 'C']</span>）に置き換わっています。</p>
<p class="tx">元のリスト<span class="thesansmonocd_w5regular_">eggs</span>の中に入っている値を<span class="thesansmonocd_w5regular_">['x', 'y', 'z']</span>に変更する場合は、<span class="thesansmonocd_w5regular_">del</span>文と<span class="thesansmonocd_w5regular_">append()</span>メソッドを使い、このように行います。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">eggs = ['A', 'B', 'C']</b>
&gt;&gt;&gt; <b class="calibre10">del eggs[2]</b>
&gt;&gt;&gt; <b class="calibre10">del eggs[1]</b>
&gt;&gt;&gt; <b class="calibre10">del eggs[0]</b>
&gt;&gt;&gt; <b class="calibre10">eggs.append('x')</b>
&gt;&gt;&gt; <b class="calibre10">eggs.append('y')</b>
&gt;&gt;&gt; <b class="calibre10">eggs.append('z')</b>
&gt;&gt;&gt; <b class="calibre10">eggs</b>
['x', 'y', 'z']
</code></pre>
<p class="tx">この例では、変数<span class="thesansmonocd_w5regular_">eggs</span>が同じリスト値のままです。上書きされたのではなく変更されました。<i class="calibre5">リストのその場での変更</i>です。</p>
<p class="tx">ミュータブルとイミュータブルを区別することに意義が感じられないかもしれませんが、<span>「参照」</span>で関数の引数に取ったときの違いを説明します。 その前にイミュータブルなリストであるタプル型を紹介します。</p>
</section>
<section type="division" aria-labelledby="sec26">
<h4 class="h1" id="calibre_link-1555"><span id="calibre_link-134"></span><span class="sans_futura_std_heavy_oblique_bi_">タプル型</span></h4>
<p class="tni"><i class="calibre5">タプル</i>型とリスト型には2つの違いしかありません。1つ目の違いは、タプルは角かっこではなく丸かっこで作成するという点です。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">eggs = ('hello', 42, 0.5)</b>
&gt;&gt;&gt; <b class="calibre10">eggs[0]</b>
'hello'
&gt;&gt;&gt; <b class="calibre10">eggs[1:3]</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1220" aria-label="128"></span>(42, 0.5)
&gt;&gt;&gt; <b class="calibre10">len(eggs)</b>
3
</code></pre>
<p class="tx">2つ目の違いは、リストはミュータブルであるのに対し、タプルは文字列と同じようにイミュータブルだという点です。値の変更、追加、削除はできません。　以下のコードを対話型シェルに入力すると、<span class="thesansmonocd_w5regular_">TypeError</span>エラーが発生します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">eggs = ('hello', 42, 0.5)</b>
&gt;&gt;&gt; <b class="calibre10">eggs[1] = 99</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    eggs[1] = 99
TypeError: 'tuple' object does not support item assignment
</code></pre>
<p class="tx">要素を1つだけ持つタプルを作成する場合は、丸かっこ内の値のあとにカンマを入れてください。そうしないと、Pythonは値に丸かっこを付けたものだと解釈します（Pythonでは、他のプログラミング言語とは異なり、リストやタプルの最後の要素のあとにカンマを入れることができます）。<span class="thesansmonocd_w5regular_">type()</span>関数を呼び出している、以下の対話型シェルの実行で確認してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">type(('hello',))</b>
&lt;class 'tuple'&gt;
&gt;&gt;&gt; <b class="calibre10">type(('hello'))</b>
&lt;class 'str'&gt;
</code></pre>
<p class="tx">タプルを使うと、そのシーケンス型では値の変更を意図していないことをコードの読み手に伝えられます。決して変更されないシーケンス型の値が必要な場合はタプルを使いましょう。リストではなくタプルを使えば、イミュータブルで変更されないために最適化されており、リストよりも少し速く実行できるという利点もあります。</p>
</section>
<section type="division" aria-labelledby="sec27">
<h4 class="h1" id="calibre_link-1556"><span id="calibre_link-135"></span><span class="sans_futura_std_heavy_oblique_bi_">リストとタプルの変換</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">str(42)</span>が整数<span class="thesansmonocd_w5regular_">42</span>の文字列表現である<span class="thesansmonocd_w5regular_">'42'</span>を返すのと同じように、<span class="thesansmonocd_w5regular_">list()</span>と<span class="thesansmonocd_w5regular_">tuple()</span>はそれぞれ渡された値のリストとタプルを返します。以下のコードを対話型シェルに入力すると、返り値のデータ型が渡された値のデータ型と違っていることがわかります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">tuple(['cat', 'dog', 5])</b>
('cat', 'dog', 5)
&gt;&gt;&gt; <b class="calibre10">list(('cat', 'dog', 5))</b>
['cat', 'dog', 5]
&gt;&gt;&gt; <b class="calibre10">list('hello')</b>
['h', 'e', 'l', 'l', 'o']
</code></pre>
<p class="tx">タプルをミュータブルにしたければリストに変換します。</p>
</section>
</section>
<section type="bibliography" role="doc-bibliography" aria-labelledby="sec28">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-712" aria-label="129"></span>
<h3 class="h" id="calibre_link-1557"><span id="calibre_link-136"></span><span class="sans_futura_std_bold_b_">参照</span></h3>
<p class="tni">変数は文字列や整数などの値を格納する箱にたとえられることがよくあります。しかし、この説明はPythonが実際に行っていることを単純化しています。値にくくりつけたネームタグというたとえのほうが適切です。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">spam = 42</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">eggs = spam</b>
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> &gt;&gt;&gt; <b class="calibre10">spam = 99</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
99
&gt;&gt;&gt; <b class="calibre10">eggs</b>
42
</code></pre>
<p class="tx">変数<span class="thesansmonocd_w5regular_">spam</span>に<span class="thesansmonocd_w5regular_">42</span>を代入したときに、コンピュータのメモリに<span class="thesansmonocd_w5regular_">42</span>という値を作成して、その<i class="calibre5">参照</i>を変数<span class="thesansmonocd_w5regular_">spam</span>に格納しています。<span class="thesansmonocd_w5regular_">spam</span>の値をコピーして変数<span class="thesansmonocd_w5regular_">eggs</span>に代入したときには、その参照をコピーしています。変数<span class="thesansmonocd_w5regular_">spam</span>と<span class="thesansmonocd_w5regular_">eggs</span>の両方とも、コンピュータのメモリ内にある<span class="thesansmonocd_w5regular_">42</span>という値を参照しています。ネームタグのたとえで言うと、同じ<span class="thesansmonocd_w5regular_">42</span> という値に<span class="thesansmonocd_w5regular_">spam</span>というネームタグと<span class="thesansmonocd_w5regular_">eggs</span>というネームタグを付けました。<span class="thesansmonocd_w5regular_">spam</span>に新しく<span class="thesansmonocd_w5regular_">99</span>という値を代入すると<span class="thesansmonocd_w5regular_">spam</span>のネームタグの参照先が変わります。図6-2にその状況を示しました。</p>
<figure class="img"><img class="img2" id="calibre_link-713" src="images/000098.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 6-2：代入は値を書き換えず、参照を変えます</span></p></figcaption>
</figure>
<p class="tx">この変更は<span class="thesansmonocd_w5regular_">eggs</span>に影響を与えません。依然として<span class="thesansmonocd_w5regular_">42</span> という値を参照しています。</p>
<p class="tx">しかし、リストはこのような動作にはなりません。リストは<i class="calibre5">ミュータブル</i>で、その中に入っている値は変わることがあります。このことがわかる例を以下に示します。以下の内容を対話型シェルに入力してください。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">spam = [0, 1, 2, 3]</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">eggs = spam</b>  # リスト自体ではなく参照がコピーされる
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span> &gt;&gt;&gt; <b class="calibre10">eggs[1] = 'Hello!'</b>  # リスト値の変更
&gt;&gt;&gt; <b class="calibre10">spam</b>
[0, 'Hello!', 2, 3]
&gt;&gt;&gt; <b class="calibre10">eggs</b>  # 変数eggsは同じリストを参照している
[0, 'Hello!', 2, 3]
</code></pre>
<p class="tx">このコードの結果は奇妙に感じられるかもしれません。リスト<span class="thesansmonocd_w5regular_">eggs</span> にしか触れていないのに<span class="thesansmonocd_w5regular_">eggs</span>と<span class="thesansmonocd_w5regular_">spam</span>の両方のリストが変化しています。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-842" aria-label="130"></span>リストを作ったときに(<span class="codeannotation" aria-label="annotation1">❶</span>)、変数<span class="thesansmonocd_w5regular_">spam</span>にそのリストへの参照を代入しました。次の行では、リスト<span class="thesansmonocd_w5regular_">spam</span>の中に入っている値ではなく、そのリストへの参照を<span class="thesansmonocd_w5regular_">eggs</span>にコピーしました(<span class="codeannotation" aria-label="annotation2">❷</span>）。リストは1つしかなく、<span class="thesansmonocd_w5regular_">spam</span>と<span class="thesansmonocd_w5regular_">eggs</span>の両方ともがそのリストを参照しています。背後に存在するリスト自体はコピーされていないので、リストは1つしかありません。ですので、<span class="thesansmonocd_w5regular_">eggs</span>の最初の要素を変更したときに(<span class="codeannotation" aria-label="annotation3">❸</span>)、<span class="thesansmonocd_w5regular_">spam</span>が参照している同じリストの変更をしたことになります。図6-3にこの状況を示しました（訳注：下図では❶で「spam = 42」となっていますが、正しくは「spam = [0, 1, 2, 3]」です）。</p>
<figure class="img"><img class="img2" id="calibre_link-715" src="images/000099.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 6-3：</span><span class="sans_thesansmonocd_w5regular_italic_">spam</span><span class="sans_futura_std_book_oblique_i_">と</span><span class="sans_thesansmonocd_w5regular_italic_">eggs</span><span class="sans_futura_std_book_oblique_i_">は同じリストを参照しているので、一方を変更すれば他方も変更されます</span></p></figcaption>
</figure>
<p class="tx">リストが直接一連の値を格納しているのではなく、一連の値の参照を格納しているので、事態はやや複雑です。<span>「</span><span class="thesansmonocd_w5regular_">copy()</span> <span>関数と</span> <span class="thesansmonocd_w5regular_">deepcopy()</span><span>関数」</span>でさらに詳しく説明します。</p>
<p class="tx">技術的にPythonの変数は値の参照を格納しているのですが、変数が値を格納していると不用意に言ってしまうことがよくあります。次の2つのルールを覚えておいてください。</p>
<ul class="ul">
<li class="bl">Pythonでは、変数が値を格納することはなく、値への参照を格納します。</li>
<li class="bl">Pythonでは、<span class="thesansmonocd_w5regular_">=</span>代入演算子は参照をコピーするのであって、値をコピーするのではありません。</li>
</ul>
<p class="tx">多くの場合、このような詳細を気にする必要はありませんが、時々驚かされることがあるので、Pythonの動作を正確に理解してください。</p>
<section type="division" aria-labelledby="sec29">
<h4 class="h1" id="calibre_link-1558"><span id="calibre_link-137"></span><span class="sans_futura_std_heavy_oblique_bi_">引数</span></h4>
<p class="tni">引数がどのようにして関数に渡されるかを理解するのに、参照という概念は特に重要です。関数が呼び出されると、Pythonは引数への参照をパラメータ変数にコピーします。（<span>第7章</span>で説明する辞書や）リストのようなミュータブルな値であれば、関数内のコードが元の値をその場で変更することを意味します。この事実の帰結を確認するために、新しいファイルエディタウィンドウを開いて以下のコードを<i class="calibre5">passingReference.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">def eggs(some_parameter):
    some_parameter.append('Hello')

spam = [1, 2, 3]
eggs(spam)
print(spam)  # [1, 2, 3, 'Hello']を表示
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-717" aria-label="131"></span><span class="thesansmonocd_w5regular_">eggs()</span>を呼び出したときに、返り値に<span class="thesansmonocd_w5regular_">spam</span>の新しい値を代入していないことに注意してください。そうではなく、直接リストをその場で変更しています。このプログラムを実行すると、<span class="thesansmonocd_w5regular_">[1, 2, 3, 'Hello']</span>と表示します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">spam</span>と<span class="thesansmonocd_w5regular_">some_parameter</span>は別々の参照ではありますが、同じリストを参照しています。そのため、関数呼び出しが終わっても、関数内での<span class="thesansmonocd_w5regular_">append('Hello')</span>メソッドの呼び出しがリストに影響します。</p>
<p class="tx">この振る舞いを覚えておいてください。Pythonがリストや辞書をこのように扱うという事実を忘れると、予期せぬ振る舞いや混乱させられるようなバグにつながりかねません。</p>
</section>
<section type="division" aria-labelledby="sec30">
<h4 class="h1" id="calibre_link-1559"><span id="calibre_link-138"></span><span class="sans_futura_std_heavy_oblique_bi_">copy()関数とdeepcopy()関数</span></h4>
<p class="tni">リストと辞書に関して参照を関数に渡すのが簡便ではありますが、渡されたリストや辞書が関数内で変更される場合に、その変更が元のリストや辞書に反映されてほしくないこともあるでしょう。この振る舞いに対処するために、Pythonには<span class="thesansmonocd_w5regular_">copy()</span>関数と<span class="thesansmonocd_w5regular_">deepcopy()</span>関数を提供する<span class="thesansmonocd_w5regular_">copy</span>モジュールがあります。前者の<span class="thesansmonocd_w5regular_">copy.copy()</span>はリストや辞書のようなミュータブルな値のコピーを作成します。参照のコピーではありません。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import copy</b>
&gt;&gt;&gt; <b class="calibre10">spam = ['A', 'B', 'C']</b>
&gt;&gt;&gt; <b class="calibre10">cheese = copy.copy(spam)  </b># リスト自体の複製を作成する
&gt;&gt;&gt; <b class="calibre10">cheese[1] = 42</b>  # cheeseを変更
&gt;&gt;&gt; <b class="calibre10">spam</b>  # 変数spamは変更されていない
['A', 'B', 'C']
&gt;&gt;&gt; <b class="calibre10">cheese</b>  # 変数cheeseは変更されている
['A', 42, 'C']
</code></pre>
<p class="tx">変数<span class="thesansmonocd_w5regular_">spam</span>と<span class="thesansmonocd_w5regular_">cheese</span>は別々のリストを参照しています。よって、<span class="thesansmonocd_w5regular_">cheese</span>のインデックス<span class="thesansmonocd_w5regular_">1</span>に<span class="thesansmonocd_w5regular_">42</span>を代入しても、その変数の中にある値しか変更されません。</p>
<p class="tx">変数が値を格納するのではなく値を<i class="calibre5">参照する</i>のと同じように、リストは値そのものではなく値への<i class="calibre5">参照</i>を保持します。図6-4をご覧ください。</p>
<figure class="img"><img class="img2" id="calibre_link-718" src="images/000100.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 6-4：リストは値を直接保持するのではなく（左側）、値への参照を保持します（右側）</span></p></figcaption>
</figure>
<p class="tx">コピーしたいリストがその中にリストを保持しているときは（入れ子のリストになっているときは）、<span class="thesansmonocd_w5regular_">copy.copy()</span>ではなく<span class="thesansmonocd_w5regular_">copy.deepcopy()</span>を使ってください。<span class="thesansmonocd_w5regular_">copy.deepcopy()</span>関数は内側のリストもコピーします。</p>
</section>
</section>
<section type="division" aria-labelledby="sec31">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1231" aria-label="132"></span>
<h3 class="h" id="calibre_link-1560"><span id="calibre_link-139"></span><span class="sans_futura_std_bold_b_">短いプログラム：マトリックスのスクリーンセーバー</span></h3>
<p class="tni">ハッカーSF映画<i class="calibre5">マトリックス</i>の中で、コンピュータのモニターが光り輝く緑色の数字の羅列を表示する場面があります。ガラス窓をたたくデジタルの雨のように見えます。数字に意味はないのでしょうけれども、かっこいいです。趣味的に、Pythonで自前のマトリックススクリーンセイバーを作れます。以下のコードを<i class="calibre5">matrixscreensaver.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import random, sys, time

WIDTH = 70  # 列数

try:
    # 各列につき、カウンターが0なら数字の羅列は表示しない
    # カウンターが0ではない場合は、
    # その列に0または1を表示する回数になる
    columns = [0] * WIDTH
    while True:
        # 各列をループ
        for i in range(WIDTH):
            if random.random() &lt; 0.02:
                # この列のカウンターを設定
                # 数字の羅列は4から14の長さ
                columns[i] = random.randint(4, 14)

            # この列の出力
            if columns[i] == 0:
                # 空白部分を確認するには''を'.'に変更
                print(' ', end='')
            else:
                # 0または1を出力
                print(random.choice([0, 1]), end='')
                columns[i] -= 1  # この列のカウンターを減らす
        print()  # 1行分の出力が終わったら改行
        time.sleep(0.1)  # 各行で0.1秒停止
except KeyboardInterrupt:
    sys.exit()  # Ctrl-Cが押されたら終了
</code></pre>
<p class="tx">このプログラムを実行すると、図6-5のように、1と0のバイナリの羅列が表示されます。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1018" aria-label="133"></span>
<figure class="img"><img class="img1" id="calibre_link-719" src="images/000101.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 6-5：マトリックススクリーンセイバープログラム</span></p></figcaption>
</figure>
<p class="tx">前の章のグラフのスパイクやジグザグのプログラムと同様に、このプログラムは、<small class="calibre4">CTRL</small>-Cを押すと止められる無限ループ内でテキストを表示することにより、スクロールアニメーションを実現しています。このプログラムの主なデータ構造は、リスト<span class="thesansmonocd_w5regular_">columns</span>です。出力の各列に対応する70個の整数を保持しています。<span class="thesansmonocd_w5regular_">columns</span>の中に入っている整数が<span class="thesansmonocd_w5regular_">0</span>ならその列にスペースを表示します。整数が<span class="thesansmonocd_w5regular_">0</span>より大きければ、ランダムに<span class="thesansmonocd_w5regular_">0</span>または<span class="thesansmonocd_w5regular_">1</span>を表示し、その整数を減らします。その整数が<span class="thesansmonocd_w5regular_">0</span>に達したら、またその列にスペースを表示します。このプログラムでは、<span class="thesansmonocd_w5regular_">columns</span>の中に入っている整数に<span class="thesansmonocd_w5regular_">4</span>から<span class="thesansmonocd_w5regular_">14</span>の整数を設定します。これがバイナリの0と1の羅列を生み出します。</p>
<p class="tx">プログラムの各部を見ていきましょう。</p>
<pre class="pre"><code class="calibre9">import random, sys, time

WIDTH = 70  # 列数
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">choice()</span>関数と<span class="thesansmonocd_w5regular_">randint()</span>関数を使うために<span class="thesansmonocd_w5regular_">random</span>モジュールを、<span class="thesansmonocd_w5regular_">exit()</span>関数を使うために<span class="thesansmonocd_w5regular_">sys</span>モジュールを、<span class="thesansmonocd_w5regular_">sleep()</span>関数を使うために<span class="thesansmonocd_w5regular_">time</span>モジュールをインポートしています。70列の出力にするために、<span class="thesansmonocd_w5regular_">WIDTH</span>という名前の変数に<span class="thesansmonocd_w5regular_">70</span>を設定しています。プログラムを実行するウィンドウサイズに応じて、この値を適当に変えてください。</p>
<p class="tx">変数<span class="thesansmonocd_w5regular_">WIDTH</span>は、定数であることを示すために、すべて大文字の名前にしています。<i class="calibre5">定数</i>とは一度設定された後に変更されない変数のことです。定数を使うとコードが読みやすくなります。<span class="thesansmonocd_w5regular_">columns</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">[0] * 70</span>と書くとコードをあとで読み返したときに<span class="thesansmonocd_w5regular_">70</span>は何だろうと疑問に思うかもしれませんが、<span class="thesansmonocd_w5regular_">columns</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">[0] * WIDTH</span>と書くとわかりやすいです。Pythonでは、定数の値を変更することができますが、すべて大文字の名前にしておくと、定数なので変更してはいけないと思い出しやすくなります。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-967" aria-label="134"></span>大部分のプログラムは<span class="thesansmonocd_w5regular_">try</span>ブロック内にあります。ユーザーが<small class="calibre4">CTRL</small>-Cを押すと送出される<span class="thesansmonocd_w5regular_">KeyboardInterrupt</span>エラーを捕捉します。</p>
<pre class="pre"><code class="calibre9">try:
    # 各列につき、カウンターが0なら数字の羅列は表示しない
    # カウンターが0ではない場合は、
    # その列に0または1を表示する回数になる
    columns = [0] * WIDTH
</code></pre>
<p class="tx">変数<span class="thesansmonocd_w5regular_">columns</span>は整数<span class="thesansmonocd_w5regular_">0</span>を<span class="thesansmonocd_w5regular_">WIDTH</span>個含むリストです。それぞれの整数が、その列に0または1を出力するかしないかを決めます。</p>
<pre class="pre"><code class="calibre9">    while True:
        # 各列をループ
        for i in range(WIDTH):
            if random.random() &lt; 0.02:
                # この列のカウンターを設定
                # 数字の羅列は4から14の長さ
                columns[i] = random.randint(4, 14)
</code></pre>
<p class="tx">このプログラムを永遠に実行したいので、<span class="thesansmonocd_w5regular_">while True:</span>の無限ループの中にコードを書きます。このループ内には、各列を繰り返し処理する<span class="thesansmonocd_w5regular_">for</span>ループがあります。ループ変数<span class="thesansmonocd_w5regular_">i</span>は列のインデックスを表しています。<span class="thesansmonocd_w5regular_">0</span>から<span class="thesansmonocd_w5regular_">WIDTH</span>までです（<span class="thesansmonocd_w5regular_">WIDTH</span>は含まない）。<span class="thesansmonocd_w5regular_">columns[0]</span>の値は左端の列で、<span class="thesansmonocd_w5regular_">columns[1]</span>は左から2番目の列で…と続きます。</p>
<p class="tx">列ごとに、2パーセントの確率で<span class="thesansmonocd_w5regular_">columns[i]</span>に<span class="thesansmonocd_w5regular_">4</span>から<span class="thesansmonocd_w5regular_">14</span>までの整数が設定されます。<span class="thesansmonocd_w5regular_">0.0</span>から<span class="thesansmonocd_w5regular_">1.0</span>までの浮動小数点数を返す関数である<span class="thesansmonocd_w5regular_">random.random()</span>の値と0.02を比べることにより、2パーセントの確率にしています。0と1の羅列の密度を増やしたり減らしたりしたい場合は、この値を増やしたり減らしたりしてください。ここでは各列の整数を4から14までのランダムな整数にします。</p>
<pre class="pre"><code class="calibre9">            # この列の出力
            if columns[i] == 0:
                # 空白部分を確認するには''を'.'に変更
                print(' ', end='')
            else:
                # 0または1を出力
                print(random.choice([0, 1]), end='')
                columns[i] -= 1  # この列のカウンターを減らす
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループの内側には、<span class="thesansmonocd_w5regular_">0</span>または<span class="thesansmonocd_w5regular_">1</span>の数字を表示するかスペースを表示するかを決めるプログラムもあります。<span class="thesansmonocd_w5regular_">columns[i]</span>が<span class="thesansmonocd_w5regular_">0</span>なら、スペースを表示します。それ以外の場合は、<span class="thesansmonocd_w5regular_">random.choice()</span>関数にリスト<span class="thesansmonocd_w5regular_">[0, 1]</span>を渡し、そのリストからランダムに値を選んで表示します。そして、<span class="thesansmonocd_w5regular_">columns[i]</span>の整数値を減らし、スペースを表示することになる0に近づけます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1210" aria-label="135"></span>プログラムが表示するスペースを可視化したければ、<span class="thesansmonocd_w5regular_">' '</span>を<span class="thesansmonocd_w5regular_">'.'</span>に変えてプログラムをもう一度実行してみたください。出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">............................1.........................................
................0...........1......................1..................
................1...........0................1.....0..................
............1...0...........0.....0..........1.....0..................
............1.1.1...........0.....0..........1.....1..1...............
............0.0.0...........0.....1.........00.....1..1...............
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">else</span>ブロックが終わると、<span class="thesansmonocd_w5regular_">for</span>ループブロックが終わります。</p>
<pre class="pre"><code class="calibre9">        print()  # 1行分の出力が終わったら改行
        time.sleep(0.1)  # 各行で0.1秒停止
except KeyboardInterrupt:
    sys.exit()  # Ctrl-Cが押されたら終了
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループが終わったら、<span class="thesansmonocd_w5regular_">print()</span>を呼び出して改行を出力しています。それまでの各列についての<span class="thesansmonocd_w5regular_">print()</span>の呼び出しは<span class="thesansmonocd_w5regular_">end=''</span>キーワード引数を渡していたので改行を出力しませんでした。行が表示されるごとに、<span class="thesansmonocd_w5regular_">time.sleep(0.1)</span>を呼び出して0.1秒停止します。</p>
<p class="tx">プログラムの最後の部分は<span class="thesansmonocd_w5regular_">except</span>ブロックです。ユーザーが<small class="calibre4">CTRL</small>-Cを押して<span class="thesansmonocd_w5regular_">KeyboardInterrupt</span>例外が送出されると、プログラムは終了します。</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec32">
<h3 class="h" id="calibre_link-1561"><span id="calibre_link-140"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">リストを使うと、処理する値の個数が変わっても同じ一つの変数で扱えるので便利です。本書の後半では、リストを使わなければ不可能に近い作業を行います。</p>
<p class="tx">リストはシーケンス型のミュータブルなデータです。リストの中に入っている値を変更できます。タプルと文字列は、同じくシーケンス型のデータですが、イミュータブルで値を変更できません。タプルや文字列を格納している変数そのものを新しいタプルや文字列で上書きすることはできますが、それは<span class="thesansmonocd_w5regular_">append()</span>メソッドや<span class="thesansmonocd_w5regular_">remove()</span>メソッドがリストについて行うようにその場で既存の値を変更することとは異なります。</p>
<p class="tx">変数はリストの値を直接格納しているのではなく、リストへの参照を格納しています。リスト変数をコピーしたり関数呼び出しの引数として渡したりするときに、この点が重要になります。コピーされる値はリストへの参照ですので、そのリストに加えた変更は別の変数にも影響することに注意してください。<span class="thesansmonocd_w5regular_">copy()</span>ないし<span class="thesansmonocd_w5regular_">deepcopy()</span>を使うと、コピー先の変数に格納されている値を変更してもコピー元のリストに影響しません。</p>
</section>
<section type="division" aria-labelledby="sec33">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1038" aria-label="136"></span>
<h3 class="h" id="calibre_link-1562"><span id="calibre_link-141"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. <span class="thesansmonocd_w5regular_">[]</span>は何ですか？</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">spam</span>という名前の変数に格納されているリストの3番目の要素に<span class="thesansmonocd_w5regular_">'hello'</span>という値を代入してください（<span class="thesansmonocd_w5regular_">spam</span>は<span class="thesansmonocd_w5regular_">[2, 4, 6, 8, 10]</span>のリストを格納しているとします）。</p>
<p class="listnumber1">以下3問は、<span class="thesansmonocd_w5regular_">spam</span>がリスト<span class="thesansmonocd_w5regular_">['a', 'b', 'c', 'd']</span>を格納していることを前提に答えてください。</p>
<p class="listnumber">  3. <span class="thesansmonocd_w5regular_">spam[int(int('3' * 2) // 11)]</span>はどう評価されますか？</p>
<p class="listnumber">  4. <span class="thesansmonocd_w5regular_">spam[-1]</span>はどう評価されますか？</p>
<p class="listnumber">  5. <span class="thesansmonocd_w5regular_">spam[:2]</span>はどう評価されますか？</p>
<p class="listnumber1">以下3問は、<span class="thesansmonocd_w5regular_">bacon</span>がリスト<span class="thesansmonocd_w5regular_">[3.14, 'cat', 11, 'cat', True]</span>を格納していることを前提に答えてください。</p>
<p class="listnumber">  6. <span class="thesansmonocd_w5regular_">bacon.index('cat')</span>はどう評価されますか？</p>
<p class="listnumber">  7. <span class="thesansmonocd_w5regular_">bacon.append(99)</span>を実行すると、<span class="thesansmonocd_w5regular_">bacon</span>の中に入っている値はどうなりますか？</p>
<p class="listnumber">  8. <span class="thesansmonocd_w5regular_">bacon.remove('cat')</span>を実行すると<span class="thesansmonocd_w5regular_">bacon</span>の中に入っている値はどうなりますか？</p>
<p class="listnumber">  9. リストを結合する演算子と複製する演算子をそれぞれ答えてください。</p>
<p class="listnumber">10. リストメソッドの<span class="thesansmonocd_w5regular_">append()</span>と<span class="thesansmonocd_w5regular_">insert()</span>はどう違いますか？</p>
<p class="listnumber">11. リストから値を削除する方法を2つ挙げてください。</p>
<p class="listnumber">12. リストが文字列と似ている点を挙げてください。</p>
<p class="listnumber">13. リストとタプルの違いは何ですか？</p>
<p class="listnumber">14. <span class="thesansmonocd_w5regular_">42</span>という整数値を一つだけ持つタプルを作成してください。</p>
<p class="listnumber">15. リストからタプルを作成してください。また、タプルからリストを作成してください。</p>
<p class="listnumber">16. リスト値を格納している変数は実際にはリストを直接格納しているわけではありません。実際には何を格納していますか？</p>
<p class="listnumber">17. <span class="thesansmonocd_w5regular_">copy.copy()</span>と<span class="thesansmonocd_w5regular_">copy.deepcopy()</span>の違いを答えてください。</p>
</section>
<section type="division" aria-labelledby="sec34">
<h3 class="h" id="calibre_link-1563"><span id="calibre_link-142"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec35">
<h4 class="h1" id="calibre_link-1564"><span id="calibre_link-143"></span><span class="sans_futura_std_heavy_oblique_bi_">カンマコード</span></h4>
<p class="tni">次のようなリスト値があるとします。</p>
<pre class="pre"><code class="calibre9">spam = ['apples', 'bananas', 'tofu', 'cats']</code></pre>
<p class="tx">リスト値を引数に取り、すべての要素をカンマで区切って、最後の区切りには<i class="calibre5">and</i>を加える関数を作成してください。例えば、上記の<span class="thesansmonocd_w5regular_">spam</span>リストをその関数に渡すと<span class="thesansmonocd_w5regular_">'apples, bananas, tofu, and cats'</span>が返されます。このリストに限らず、どのリストを渡しても動作する関数を書いてください。空リスト<span class="thesansmonocd_w5regular_">[]</span>を渡した場合も考慮してください。</p>
</section>
<section type="division" aria-labelledby="sec36">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1030" aria-label="137"></span>
<h4 class="h1" id="calibre_link-1565"><span id="calibre_link-144"></span><span class="sans_futura_std_heavy_oblique_bi_">連続コイン投げ</span></h4>
<p class="tni">連続したコイン投げの実験をします。100回コインを投げて、表が出たら<i class="calibre5">H</i>を、裏が出たら<i class="calibre5">T</i> を記入します。<i class="calibre5">T T T T H H H H T T</i>のような結果を得ます。100回のランダムなコイン投げの結果を書いてくださいと人間に頼むと、<i class="calibre5">H T H T H H T H T T</i>のような表と裏の入れ替わりの多い結果を書きがちです。これは（人間にとっては）ランダムに見えますが、数学的にはランダムではありません。人間は6連続の表または裏をめったに書きませんが、本当にランダムなコイン投げだとそれが十分に起こり得ます。人間はランダムが苦手です。</p>
<p class="tx">ランダムに生成された100回分の表または裏の結果について、6連続の表または裏がどれくらいの頻度で出現するかを確かめるプログラムを書いてください。プログラムは2つの部分に分けられます。100個のランダムに選んだ<span class="thesansmonocd_w5regular_">'H'</span>または<span class="thesansmonocd_w5regular_">'T'</span>の値のリストを生成する部分と、6連続の表または裏があるかどうかを確かめる部分です。実験を10,000回行うループの中にその2つの部分のコードを入れてください。そうすれば、どれくらいのパーセンテージで6連続の表または裏を含むかを算出できます。ヒントとして、<span class="thesansmonocd_w5regular_">random.randint(0, 1)</span>関数を呼び出すと、半々の確率で<span class="thesansmonocd_w5regular_">0</span>または<span class="thesansmonocd_w5regular_">1</span>を返します。</p>
<p class="tx">以下のテンプレートをご活用ください。</p>
<pre class="pre"><code class="calibre9">import random
number_of_streaks = 0
for experiment_number in range(10000):  # 合計10,000回の実験を実行
    # 100個の表または裏の値のリストを作成するコード

    # 6連続の表または裏があるかどうかをチェックするコード

print('Chance of streak: %s%%' % (number_of_streaks / 100))
</code></pre>
<p class="tx">もちろん、これは推計に過ぎませんが、10,000回実験すればサンプルサイズとしては十分でしょう。数学の知識があればプログラムを書かずに正確な答えを出せるかもしれません（プログラマには数学が得意ではない人が多いです）。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループでランダムに選んだ<span class="thesansmonocd_w5regular_">'H'</span>または<span class="thesansmonocd_w5regular_">'T'</span>を100回リストに追加してください。6連続の表または裏があるかどうかを判定するには、<span class="thesansmonocd_w5regular_">some_list[i:i</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">6]</span>のようなスライス（インデックス<span class="thesansmonocd_w5regular_">i</span>から始まる6つの要素を含むリスト）を作成し、<span class="thesansmonocd_w5regular_">['H', 'H', 'H', 'H', 'H', 'H']</span>または<span class="thesansmonocd_w5regular_">['T', 'T', 'T', 'T', 'T', 'T']</span>と比較します。</p>
</section>
</section>
</section>
</div>

</div>



</body></html>