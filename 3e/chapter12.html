<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">







<div type="bodymatter" class="calibre" id="calibre_link-279">
<section type="chapter" role="doc-chapter" aria-labelledby="ch12">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1723" aria-label="257"></span>
<hgroup>
<h2 class="title" id="calibre_link-1724">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">12</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">コマンドラインプログラム</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">これまでのところは、もっぱらMu（あるいは別のコードエディタ）からプログラムを実行してきました。本章では、コマンドラインターミナルからプログラムを実行する方法を説明します。コマンドラインは恐ろしく感じられるかもしれません。暗号のようなコマンドとユーザーに優しくない見た目から、ほとんどのユーザーはコマンドラインを避けています。しかしコマンドラインに慣れることは本当に有益であり、これまでに行ってきたプログラミングより難しいということもありません。</p>
<p class="tx">何らかの作業を自動化するPythonプログラムを書いたなら、そのプログラムを実行するたびにMuを開かなければならないのは負担に感じられるでしょう。コマンドラインを使えばもっと簡便にPythonのスクリプトを実行できるようになります（特に自分が書いたプログラムを、Muを持っておらず、ひょっとしたらPythonもインストールしていない友人や同僚に共有する場合はそうです）。ソフトウェア開発では、ソフトウェアをコードエディタ以外から実行できるようにする手順を<i class="calibre5">デプロイ</i>と呼びます。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h"><span id="calibre_link-1725"></span><span id="calibre_link-280"></span><span class="sans_futura_std_bold_b_">プログラムの別の呼び方</span></h3>
<p class="tni">この章では（そしてプログラミングの世界一般でも）、<i class="calibre5">プログラム</i>を意味する用語がいろいろあります。以下の用語を全部プログラムと読んでも間違いではありませんが、意味合いに微妙な違いがあります。</p>
<p class="listplain"><b class="calibre10">プログラム</b> 大きさはいろいろですが、コンピュータが実行できる指示から成る完全なソフトウェアを指します。</p>
<p class="listplain"><b class="calibre10">スクリプト</b> マシンコードにコンパイルするのではなく、インタープリタがソースコードを実行するプログラムを指します。この語には曖昧な面があります。Pythonのコードは他の言語と同じようにコンパイルできるのですけれども（<span>「PyInstallerでPythonプログラムをコンパイルする」</span>で説明します）、それでもPythonのプログラムはしばしばスクリプトと呼ばれます。</p>
<p class="listplain"><b class="calibre10">コマンド</b> テキストベースのターミナルから実行され、GUIを持たないプログラムを指します。コマンド実行時にコマンドライン引数を指定することにより設定を変更します（“Are you sure? Y/N”のような質問を実行中に表示する<i class="calibre5">対話型コマンド</i>もあります）。「cd、pwd、dir、lsコマンド」で紹介する<span class="thesansmonocd_w5regular_">dir</span>や<span class="thesansmonocd_w5regular_">ls</span>はコマンドの例です。</p>
<p class="listplain"><b class="calibre10">シェルスクリプト</b> 一度に複数のターミナルコマンドを実行できるようにまとめられた一つのテキストファイルを指します。一つのシェルスクリプトを実行すれば、手動で複数のコマンドを個別に実行せずにすみます。macOSとLinuxでは、シェルスクリプトには拡張子<i class="calibre5">.sh</i>をつけるか拡張子なしにします。Windowsでは拡張子<i class="calibre5">.bat</i>でシェルスクリプト用のバッチファイルを作成します。</p>
<p class="listplain"><b class="calibre10">アプリケーション</b> GUIを持ち複数の機能があるプログラムを指します。ExcelやFirefoxがアプリケーションの例です。アプリケーションは、通常、コンピュータにコピーできる一つの実行ファイルではなく、<i class="calibre5">インストーラー</i>プログラムがそれぞれのコンピュータにセットアップする（<i class="calibre5">アンインストーラー</i>プログラムで削除する）複数のファイルから成り立ちます。</p>
<p class="listplain"><b class="calibre10">アプリ</b> 主にスマホやタブレット用のアプリケーションを想起させますが、デスクトップアプリケーションを指すこともあります。</p>
<p class="listplain"><b class="calibre10">ウェブアプリ</b> ウェブサーバーで実行されるプログラムです。ユーザーはウェブブラウザを通してインターネット越しに利用します。</p>
<p class="tx">これらの用語の正確な定義について細かく言い出すときりがありません。ここでの説明はあくまでも一般的な使われ方を示しています。用語についてもっと知りたければ、<i class="calibre5">Beyond the Basic Stuff with Python</i> (No Starch Press, 2020)の“Programming Jargon”の章で詳しく説明しています。</p>
</section>
<section type="division" aria-labelledby="sec2">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-907" aria-label="259"></span>
<h3 class="h"><span id="calibre_link-1726"></span><span id="calibre_link-281"></span><span class="sans_futura_std_bold_b_">ターミナルを使う</span></h3>
<p class="tni">AppleとMicrosoftが複数のプログラムを同時に実行できるGUIを備えたコンピュータを普及させた1990年代まで、プログラムは<i class="calibre5">コマンドラインインターフェイス</i>（CLI）から起動し、入出力はほぼテキストに限られていました。CLIは、<i class="calibre5">コマンドプロンプト</i>、<i class="calibre5">ターミナル</i>、<i class="calibre5">シェル</i>、<i class="calibre5">コンソール</i>とも呼ばれます。ソフトウェア開発者は今でもCLIを使い、常に複数のターミナルウィンドウを開いていることも珍しくありません。テキストベースのターミナルにはアイコンやボタンなどGUIのグラフィックスはありませんが、コマンドの使い方を知っていればコンピュータを効果的に活用できます。</p>
<p class="tx">以下の手順でターミナルウィンドウを開けます。</p>
<ul class="ul">
<li class="bl">Windowsでは、<b class="calibre10">スタート</b>ボタンをクリックし（あるいは<b class="calibre10">Windowsキー</b>を押し）、<b class="calibre10">コマンドプロンプト</b> （インストールされているなら<b class="calibre10">PowerShell</b>や<b class="calibre10">Terminal</b>）と入力します。</li>
<li class="bl">macOSでは、画面右上のSpotlightアイコンをクリックし（あるいは<span class="sans_futura_std_book_"></span>-<b class="calibre10">spacebar</b>を押し）、<b class="calibre10">Terminal</b>と入力します。</li>
<li class="bl">Ubuntu Linuxでは、<b class="calibre10">Windowsキー</b>を押してDashを開き、<b class="calibre10">Terminal</b>と入力します。<small class="calibre4">CTRL</small><b class="calibre10">-</b><small class="calibre4">ALT</small>-Tのキーボードショートカットでもターミナルウィンドウが開きます。</li>
</ul>
<p class="tx">対話型シェルには<span class="thesansmonocd_w5regular_">&gt;&gt;&gt;</span>プロンプトがあるように、ターミナルにもプロンプトが表示されます。Windowsでは、現在のフォルダのフルパスに続けて大なり記号（<span class="thesansmonocd_w5regular_">&gt;</span>）が表示されます。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">your commands go here</b></code></pre>
<p class="tx">macOSでは、ユーザー名とコンピュータ名と現在の作業ディレクトリ（ホームフォルダは<span class="thesansmonocd_w5regular_">~</span>と表されています）に続けてパーセント記号（<span class="thesansmonocd_w5regular_">%</span>）が表示されます。</p>
<pre class="pre"><code class="calibre9">al@Als-MacBook-Pro ~ % <b class="calibre10">your commands go here</b></code></pre>
<p class="tx">Ubuntu Linuxは、macOSと似ています。</p>
<pre class="pre"><code class="calibre9">al@al-VirtualBox:~$ <b class="calibre10">your commands go here</b></code></pre>
<p class="tx">Windowsならスタートメニューから、macOSならSpotlightから、プログラムを実行できますが、ターミナルから実行することもできます。Pythonインタープリタはターミナルから実行されることも多いです。</p>
<p class="tx">本章では、実行するPythonのプログラムが<i class="calibre5">yourScript.py</i>という名前で、ホームフォルダの<i class="calibre5">Scripts</i>フォルダ内にあると仮定します。Pythonの対話型シェルにアクセスするのにMuを開く必要はありません。ターミナルウィンドウから、Windowsでは<span class="thesansmonocd_w5regular_">python</span>、macOSとLinuxでは<span class="thesansmonocd_w5regular_">python3</span>と入力すれば、Pythonの対話型シェルが開きます（おなじみの<span class="thesansmonocd_w5regular_">&gt;&gt;&gt;</span>プロンプトが見えるはずです）。ターミナルからPythonファイル<i class="calibre5">.py</i>を実行するには、<span class="thesansmonocd_w5regular_">python</span>ないし<span class="thesansmonocd_w5regular_">python3</span>のあとにそのファイルのパスを入力します。現在の作業ディレクトリが<i class="calibre5">C:\Users\al\Scripts</i>であれば、<span class="thesansmonocd_w5regular_">python C:\Users\al\Scripts\yourScript.py</span>のような絶対パスでも、<i class="calibre5">yourScript.py</i>のような相対パスでも構いません。</p>
<section type="division" aria-labelledby="sec3">
<h4 class="h1"><span id="calibre_link-1727"></span><span id="calibre_link-282"></span><span class="sans_futura_std_heavy_oblique_bi_">cd、pwd、dir、lsコマンド</span></h4>
<p class="tni">すべての実行中のプログラムに相対パスの起点となる現在の作業ディレクトリ（CWD）があるように、ターミナルにも現在の作業ディレクトリがあります。このCWDはターミナルプロンプトの一部として見えていますし、macOSとLinuxでは<span class="thesansmonocd_w5regular_">pwd</span>（<i class="calibre5">print working directory</i>）、Windowsではコマンドライン引数なしで<span class="thesansmonocd_w5regular_">cd</span>を実行して確かめることもできます。</p>
<p class="tx">Pythonプログラムでは<span class="thesansmonocd_w5regular_">os.chdir()</span>関数を呼び出すとCWDを変更できます。ターミナルでは、<span class="thesansmonocd_w5regular_">cd</span>コマンドのあとに変更先のフォルダを入力すると（相対パスでも絶対パスでも構いません）、同じことができます。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">cd Desktop</b>
C:\Users\al\Desktop&gt;<b class="calibre10">cd ..</b>
C:\Users\al&gt;<b class="calibre10">cd C:\Windows\System32</b>
C:\Windows\System32&gt;
</code></pre>
<p class="tx">Windowsでは、ドライブ文字を変更するにはさらに別の手順が必要になります。<span class="thesansmonocd_w5regular_">cd</span>コマンドではドライブを変更することはできません。ドライブ文字とコロンを入力してから、<span class="thesansmonocd_w5regular_">cd</span>でそのドライブのディレクトリに変更します。</p>
<pre class="pre"><code class="calibre9">C:\Windows\System32&gt;<b class="calibre10">D:</b>
D:\&gt;<b class="calibre10">cd backup</b>
D:\backup&gt;
</code></pre>
<p class="tx">Windowsの<span class="thesansmonocd_w5regular_">dir</span>コマンド、macOSとLinuxの<span class="thesansmonocd_w5regular_">ls</span>コマンドは、CWDのファイルとサブフォルダを一覧表示します。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">dir</b>
<var class="calibre20">--snip--</var>
08/26/2036  06:42 PM           171,304 _recursive-centaur.png
08/18/2035  11:25 AM             1,278 _viminfo
08/13/2035  12:58 AM    &lt;DIR&gt;          __pycache__
              77 File(s)     83,805,114 bytes
             108 Dir(s)  149,225,267,200 bytes free
</code></pre>
<p class="tx">ターミナルでファイルシステムを動き回る際には、<span class="thesansmonocd_w5regular_">cd</span>でディレクトリを変更して<span class="thesansmonocd_w5regular_">dir</span>/<span class="thesansmonocd_w5regular_">ls</span>でそのディレクトリの中身を確認するという作業をしばしば繰り返します。Windowsでは<span class="thesansmonocd_w5regular_">dir *.exe</span>、macOSとLinuxでは<span class="thesansmonocd_w5regular_">file * | grep executable</span>を実行すれば、CWD内のすべての実行可能ファイルを一覧表示できます。プログラムを含むフォルダにいるなら、以下の方法でそのプログラムを実行できます。</p>
<ul class="ul">
<li class="bl">Windowsでは、プログラム名を入力します。<span class="thesansmonocd_w5regular_">example.exe</span>のように拡張子<i class="calibre5">.exe</i>をつけても、つけなくても構いません。</li>
<li class="bl">macOSとLinuxでは、<span class="thesansmonocd_w5regular_">./example</span>のように<span class="thesansmonocd_w5regular_">./</span>に続けてプログラム名を入力します。</li>
</ul>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-741" aria-label="261"></span><span class="thesansmonocd_w5regular_">C:\full\path\to\example.exe</span>や<span class="thesansmonocd_w5regular_">/full/path/to/example</span>のように、プログラムのフルパス（絶対パス）を入力しても実行できます。</p>
<p class="tx"><i class="calibre5">example.txt</i>という名前のテキストファイルなど、プログラムファイル以外のファイルを開く場合は、Windowsなら<span class="thesansmonocd_w5regular_">example.txt</span>、macOSとLinuxなら<span class="thesansmonocd_w5regular_">open example.txt</span>と入力すれば、関連づけられたアプリケーションでそのファイルを開きます。これはGUIの<i class="calibre5">example.txt</i>ファイルのアイコンをダブルクリックするのと同じことをターミナルからしています。<i class="calibre5">.txt</i>に関連づけられたアプリケーションが存在しなければ、ユーザーはそのファイルを開くアプリケーションを選ぶことを求められ、そのアプリケーションが将来のために記憶されます。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1"><span id="calibre_link-1728"></span><span id="calibre_link-283"></span><span class="sans_futura_std_heavy_oblique_bi_">PATH環境変数</span></h4>
<p class="tni">すべてのプログラムには、どのような言語で書かれていても、<i class="calibre5">環境変数</i>と呼ばれる文字列変数があります。その中の一つに<span class="thesansmonocd_w5regular_">PATH</span>環境変数があります。プログラム名を実行したときにターミナルが確認するフォルダの一覧です。例えば、Windowsで<span class="thesansmonocd_w5regular_">python</span>、あるいはmacOSとLinuxで<span class="thesansmonocd_w5regular_">python3</span>と入力すると、ターミナルはその名前のプログラムを<span class="thesansmonocd_w5regular_">PATH</span>に含まれるフォルダの中から探します。OSによって<span class="thesansmonocd_w5regular_">PATH</span>のルールが微妙に異なります。</p>
<ul class="ul">
<li class="bl">Windowsはその名前のプログラムをまずCWDで探し、次に<span class="thesansmonocd_w5regular_">PATH</span>のフォルダを探します。</li>
<li class="bl">LinuxとmacOSでは、<span class="thesansmonocd_w5regular_">PATH</span>のフォルダだけを探し、CWDは探しません。CWDの<i class="calibre5">example</i>という名前のプログラムを実行したければ、<span class="thesansmonocd_w5regular_">example</span>ではなく<span class="thesansmonocd_w5regular_">./example</span>と入力する必要があります。</li>
</ul>
<p class="tx">Windowsでは<span class="thesansmonocd_w5regular_">echo %PATH%</span>、macOSとLinuxでは<span class="thesansmonocd_w5regular_">echo $PATH</span>を実行すると、<span class="thesansmonocd_w5regular_">PATH</span>環境変数の中身を確認できます。<span class="thesansmonocd_w5regular_">PATH</span>に格納されている値はフォルダ名をセミコロン（Windows）またはコロン（macOSとLinux）で区切った長い文字列です。例えば、Ubuntu Linuxでは、<span class="thesansmonocd_w5regular_">PATH</span>環境変数は以下のようになっています。</p>
<pre class="pre"><code class="calibre9">al@al-virtual-machine:~$ <b class="calibre10">echo $PATH</b>
/home/al/.local/bin:/home/al/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/
usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
</code></pre>
<p class="tx">この<span class="thesansmonocd_w5regular_">PATH</span>のLinuxのターミナルで<span class="thesansmonocd_w5regular_">python3</span>と入力すると、まず<i class="calibre5">/home/al/.local/bin</i>フォルダ、次に<i class="calibre5">/home/al/bin</i>フォルダと順に<i class="calibre5">python3</i>という名前のプログラムを探します。<i class="calibre5">/usr/bin</i>で<i class="calibre5">python3</i>を見つけてそれを実行します。<span class="thesansmonocd_w5regular_">PATH</span>環境変数のフォルダ内にプログラムを置いておくと、プログラムを実行するたびごとにそのプログラムのあるフォルダに<span class="thesansmonocd_w5regular_">cd</span>で移動しなくてもすむので、便利です。</p>
<p class="tx">ターミナルは<span class="thesansmonocd_w5regular_">PATH</span>フォルダのサブフォルダは探さないことに注意してください。<i class="calibre5">C:\Users\al\Scripts</i>が<span class="thesansmonocd_w5regular_">PATH</span>に含まれているとしたら、<i class="calibre5">spam.exe</i>を実行すると、<i class="calibre5">C:\Users\al\Scripts\spam.exe</i>ファイルを実行できますが、<i class="calibre5">C:\Users\al\Scripts\eggs\spam.exe</i>ファイルは実行できません。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1"><span id="calibre_link-1729"></span><span id="calibre_link-284"></span><span class="sans_futura_std_heavy_oblique_bi_">PATHの編集</span></h4>
<p class="tni">これまで<i class="calibre5">.py</i>ファイルを、Muエディタがデフォルトで用いる<i class="calibre5">mu_code</i>フォルダに保存してきました。しかし、ホームフォルダ以下に<i class="calibre5">Scripts</i>フォルダを作成することをおすすめします。ユーザー名が<i class="calibre5">al</i>だとしたら、次のようなフォルダです。</p>
<ul class="ul">
<li class="bl">Windowsでは<i class="calibre5">C:\Users\al\Scripts</i></li>
<li class="bl">macOSでは<i class="calibre5">/Users/al/Scripts</i></li>
<li class="bl">Ubuntu Linuxでは<i class="calibre5">/home/al/Scripts</i></li>
</ul>
<p class="tx">このフォルダを<span class="thesansmonocd_w5regular_">PATH</span>に追加しましょう。</p>
<section type="division" aria-labelledby="sec6">
<h5 class="h2"><span id="calibre_link-1730"></span><span class="sans_futura_std_bold_b_">Windows</span></h5>
<p class="tni">Windowsには2種類の環境変数があります。すべてのユーザーに適用されるシステム環境変数と、システム環境変数をユーザーごとに上書きするユーザー環境変数です。これらの環境変数を編集するには、<b class="calibre10">スタート</b>メニューから<b class="calibre10">環境変数を編集</b>と入力し、<b class="calibre10">環境変数</b>ウィンドウを開きます。</p>
<p class="tx">（画面下部のシステム変数一覧ではなく）画面上部のユーザー変数一覧から<b class="calibre10">Path</b>を選び、<b class="calibre10">編集</b>をクリックして、新しいフォルダ名<b class="calibre10"><i class="calibre5">C:\Users\al\Scripts</i></b>をセミコロンで区切られたテキストフィールドに追加し、<b class="calibre10">OK</b>をクリックします。</p>
</section>
<section type="division" aria-labelledby="sec7">
<h5 class="h2"><span id="calibre_link-1731"></span><span class="sans_futura_std_bold_b_">macOSとLinux</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">PATH</span>環境変数にフォルダを追加するには、ターミナル起動スクリプトを編集します。macOSでは<i class="calibre5">.zshrc</i>ファイル、Linuxでは<i class="calibre5">.bashrc</i>ファイルです。これらのファイルはホームフォルダにあり、新しいターミナルウィンドウが開くたびに実行されるコマンドが書かれています。macOSでは、<i class="calibre5">.zshrc</i>ファイルの最後に以下の行を追加してください。</p>
<pre class="pre"><code class="calibre9">export PATH=/Users/al/Scripts:$PATH</code></pre>
<p class="tx">Linuxでは、<i class="calibre5">.bashrc</i>ファイルの最後に以下の行を追加してください。</p>
<pre class="pre"><code class="calibre9">export PATH=/home/al/Scripts:$PATH</code></pre>
<p class="tx">この行を追加すると、それ以後に開くターミナルウィンドウで<span class="thesansmonocd_w5regular_">PATH</span>を変更します。現在開いているターミナルウィンドウには変更が及びません。</p>
</section>
</section>
<section type="division" aria-labelledby="sec8">
<h4 class="h1"><span id="calibre_link-1732"></span><span id="calibre_link-285"></span><span class="sans_futura_std_heavy_oblique_bi_">whichコマンドとwhereコマンド</span></h4>
<p class="tni">プログラムが<span class="thesansmonocd_w5regular_">PATH</span>環境変数のどのフォルダにあるのかを知りたければ、macOSとLinuxでは<span class="thesansmonocd_w5regular_">which</span>を、Windowsでは<span class="thesansmonocd_w5regular_">where</span>を実行します。例えば、macOSで以下の<span class="thesansmonocd_w5regular_">which</span>コマンドを入力してください。</p>
<pre class="pre"><code class="calibre9">al@Als-MacBook-Pro ~ % <b class="calibre10">which python3</b>
/Library/Frameworks/Python.framework/Versions/3.13/bin/python3
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-840" aria-label="263"></span>Windowsでは、以下の<span class="thesansmonocd_w5regular_">where</span>コマンドを入力してください。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">where python</b>
C:\Users\al\AppData\Local\Programs\Python\Python313\python.exe
C:\Users\al\AppData\Local\Programs\Python\Python312\python.exe
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">where</span>コマンドは<i class="calibre5">python</i>という名前のプログラムが存在する<span class="thesansmonocd_w5regular_">PATH</span>のフォルダを表示します。一番上のフォルダが<span class="thesansmonocd_w5regular_">python</span>と入力したときに使われるものです。<span class="thesansmonocd_w5regular_">which</span>コマンドと<span class="thesansmonocd_w5regular_">where</span>コマンドは、<span class="thesansmonocd_w5regular_">PATH</span>がどのような設定になっているか不確かで、特定のプログラムの場所を知りたい場合に役立ちます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec9">
<h3 class="h"><span id="calibre_link-1733"></span><span id="calibre_link-286"></span><span class="sans_futura_std_bold_b_">仮想環境</span></h3>
<p class="tni">2つのPythonプログラムがあり、1つはあるパッケージのバージョン1.0を使っていて、もう1つは同じパッケージのバージョン2.0を使っているとします。Pythonは同じパッケージの2つのバージョンを同時にインストールすることはできません。バージョン2.0にバージョン1.0との後方互換性がなければ、実行するプログラムを切り替えるたびにあるバージョンをアンインストールして別のバージョンをインストールしなければなりません。</p>
<p class="tx">この問題は、<i class="calibre5">仮想環境</i>でPythonを別々にインストールしてサードパーティのパッケージをそれぞれにインストールすれば解決できます。アプリケーションごとに仮想環境を用意するのが一般的です。しかし、プログラムの学習中に作成する小さなスクリプトであれば、全部を一つの仮想環境で作成しても差し支えないでしょう。Pythonに組み込まれている<span class="thesansmonocd_w5regular_">venv</span>モジュールで仮想環境を作成します。<span class="sans_thesansmonocd_w7bold_b_">cd</span>で<i class="calibre5">Scripts</i>フォルダに移動して、<span class="sans_thesansmonocd_w7bold_b_">python –m venv .venv</span>を実行します（macOSとLinuxでは<span class="thesansmonocd_w5regular_">python</span>ではなく<span class="thesansmonocd_w5regular_">python3</span>としてください）。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;
C:\Users\al&gt;<b class="calibre10">cd Scripts</b>
C:\Users\al\Scripts&gt;<b class="calibre10">python -m venv .venv</b>
</code></pre>
<p class="tx">これにより<i class="calibre5">.venv</i>という名前の新しいフォルダ内に仮想環境のファイルを作成します。フォルダ名は何でもいいですが、<i class="calibre5">.venv</i>という名前にする慣習があります。ドットで始まる名前のフォルダは隠しフォルダです。隠しフォルダと隠しファイルを表示するようにOSの設定を調整してください。</p>
<p class="tx">ターミナルから<span class="thesansmonocd_w5regular_">python</span>ないし<span class="thesansmonocd_w5regular_">python3</span>を実行すると、Pythonをインストールしたときのインタープリタを起動します。仮想環境のPythonを使うには、仮想環境を有効化します。Windowsでは<i class="calibre5">C:\Users\al\Scripts\.venv\Scripts\activate.bat</i>を実行します。</p>
<pre class="pre"><code class="calibre9">C:\Users\al\Scripts&gt;<b class="calibre10">cd .venv\Scripts</b>
C:\Users\al\Scripts\.venv\Scripts&gt;<b class="calibre10">activate.bat</b>
(.venv) C:\Users\al\Scripts\.venv\Scripts&gt;<b class="calibre10">where python.exe</b>
C:\Users\Al\Scripts\.venv\Scripts\python.exe
C:\Users\Al\AppData\Local\Programs\Python\Python313\python.exe
C:\Users\Al\AppData\Local\Programs\Python\Python312\python.exe
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1262" aria-label="264"></span>仮想環境を有効化してから<span class="thesansmonocd_w5regular_">where python.exe</span>を実行すると、ターミナルから実行する<span class="thesansmonocd_w5regular_">python</span>が、システムのPythonではなく、<i class="calibre5">.venv\Scripts</i>フォルダのPythonインタープリタであることが示されます。</p>
<p class="tx">macOSとLinuxでは<i class="calibre5">~/Scripts/.venv/bin/activate</i>を実行するのですが、セキュリティのパーミッションにより直接実行することはできません。<b class="calibre10">source activate</b>コマンドを実行します。</p>
<pre class="pre"><code class="calibre9">al@al-virtual-machine:~/Scripts$ <b class="calibre10">cd .venv/bin</b>
al@al-virtual-machine:~/Scripts/.venv/bin$ <b class="calibre10">source activate</b>
(.venv) al@al-virtual-machine:~/Scripts/.venv/bin$ which python3
/home/al/Scripts/.venv/bin/python3
</code></pre>
<p class="tx">仮想環境を有効化すると<span class="thesansmonocd_w5regular_">PATH</span>環境変数が変更され、<span class="thesansmonocd_w5regular_">python</span>ないし<span class="thesansmonocd_w5regular_">python3</span>が、インストールしたシステムのPythonインタープリタではなく、<i class="calibre5">.venv</i>フォルダ内のPythonインタープリタを実行します。ターミナルプロンプトにも<span class="thesansmonocd_w5regular_">(.venv)</span>と表示されますから、仮想環境が有効化されていることがわかります。仮想環境を有効化して<span class="thesansmonocd_w5regular_">which python3</span>を実行すると、<span class="thesansmonocd_w5regular_">python3</span>が新しく作成した<i class="calibre5">.venv/bin</i>フォルダのPythonインタープリタを実行することがわかります。この変更は現在のターミナルウィンドウだけに適用され、別のターミナルウィンドウでは環境変数もプロンプトも変更されません。この新しいPython環境にはデフォルトのパッケージしか入っておらず、これまでにシステムのPythonにインストールしたパッケージは含まれていません。<span class="sans_thesansmonocd_w7bold_b_">python –m pip list</span>を実行すると、インストールされたパッケージを一覧表示するので、そのことを確かめられます。</p>
<pre class="pre"><code class="calibre9">(.venv) C:\Users\al\Scripts\.venv\Scripts&gt;<b class="calibre10">python -m pip list</b>
Package    Version
---------- -------
pip        23.0
setuptools 65.5.0
</code></pre>
<p class="tx">プロジェクトごとにパッケージの依存関係が異なりますから、プロジェクトごとに仮想環境を作成するのが標準的です。しかし、Windowsでは、もう少し緩く考え、<i class="calibre5">Scripts</i>フォルダで作成する小さなスクリプトをすべて同じ仮想環境で実行してもよいでしょう。</p>
<p class="tx">macOSとLinuxでは、OSにPythonが付属していてそれに依存しているプログラムがあります。このOSに付属しているPython（<i class="calibre5">システムのPython</i>）のパッケージをインストールしたりアップデートしたりすると、プログラムに悪影響を及ぼす可能性があります。自分で書いたスクリプトをシステムのPythonで実行しても何の問題もありません。システムのPythonでサードパーティーのパッケージをインストールするのは少しリスクがありますが、<i class="calibre5">Scripts</i>フォルダで仮想環境を作成すれば安心です。</p>
<p class="tx">Muにも固有の仮想環境があります。MuでF5を押してスクリプトを実行すると、<i class="calibre5">Scripts\.venv</i>フォルダの仮想環境にインストールしたパッケージを利用できません。プログラミングに習熟してくると、Muのウィンドウでコードを編集し、ターミナルウィンドウでそのコードを実行したくなるかもしれません。WindowsとLinuxでは<small class="calibre4">ALT</small>-<small class="calibre4">TAB</small>、macOSでは<span class="listbullet_menuarrow"></span>-<small class="calibre4">TAB</small>を押すと、ウィンドウを切り替えられます。</p>
<p class="tx">仮想環境を無効化するには、仮想環境を有効化したフォルダで、Windowsでは<span class="thesansmonocd_w5regular_">deactivate.bat</span>、macOSとLinuxでは<span class="thesansmonocd_w5regular_">deactivate</span>を実行します。ターミナルウィンドウを閉じて新しく開いてもよいでしょう。仮想環境とその環境にインストールしたパッケージを完全に削除したければ、<i class="calibre5">.venv</i>フォルダをその中身ごと削除します。</p>
<p class="tx">以下の節では仮想環境を有効化して<span class="thesansmonocd_w5regular_">PATH</span>に<i class="calibre5">Scripts</i>フォルダを追加した状態でスクリプトを開発します。</p>
</section>
<section type="division" aria-labelledby="sec10">
<h3 class="h"><span id="calibre_link-1734"></span><span id="calibre_link-287"></span><span class="sans_futura_std_bold_b_">pipでPythonのパッケージをインストールする</span></h3>
<p class="tni">Pythonには<i class="calibre5">pip</i>と呼ばれるコマンドラインパッケージ管理プログラムが付属しています。pipは<i class="calibre5">pip installs package</i>という再帰的頭字語です。Pythonには<span class="thesansmonocd_w5regular_">sys</span>、<span class="thesansmonocd_w5regular_">random</span>、<span class="thesansmonocd_w5regular_">os</span>などの標準ライブラリが付属していますが、<i class="calibre5"><a href="https://pypi.org" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org</a></i>の<i class="calibre5">PyPI</i>（パイピーアイ）には何十万ものサードパーティーのパッケージが登録されています。<i class="calibre5">パッケージ</i>は、Pythonのコードを集めたもので、PyPIからインストールできます。<i class="calibre5">module</i>は、Pythonのコードが書かれた個々の<i class="calibre5">.py</i>ファイルです。モジュールを含むパッケージをPyPIからインストールして、<span class="thesansmonocd_w5regular_">import</span>文でモジュールをインポートします。</p>
<p class="tx">pipは独立したプログラムで、Windowsなら<span class="thesansmonocd_w5regular_">pip</span>、macOSとLinuxでは<span class="thesansmonocd_w5regular_">pip3</span>で直接実行できますが、Windowsでは<span class="thesansmonocd_w5regular_">python –m pip</span>、macOSとLinuxでは<span class="thesansmonocd_w5regular_">python3 –m pip</span>で、Pythonインタープリタを通じて実行することもできます。インタープリタを通じて実行すれば、Pythonが複数インストールされていて<span class="thesansmonocd_w5regular_">PATH</span>の設定がまずく<span class="thesansmonocd_w5regular_">pip</span>/<span class="thesansmonocd_w5regular_">pip3</span>が別のPythonインタープリタにインストールするというエラーを防げます。</p>
<aside class="box" aria-label="box-13">
<p class="bt" id="calibre_link-1735"><span class="sans_futura_std_bold_b_">Anacondaでpipを使わないでください</span></p>
<p class="btni"><span class="sans_futura_std_book_oblique_i_"><a href="https://python.org" class="calibre1">https://<wbr></wbr>python<wbr></wbr>.org</a></span><span class="sans_futura_std_book_">から通常のディストリビューションをインストールせずにAnacondaをインストールした場合は、conda環境でpipを使わずに</span><span class="thesansmonocd_w5regular_">conda</span><span class="sans_futura_std_book_">コマンドでパッケージ管理をしてください。</span></p>
</aside>
<p class="tx">以下のコマンドでPyPIからパッケージをインストールします。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">python –m pip install </b><b class="calibre10"><var class="calibre20">package_name</var></b></code></pre>
<p class="tx">この種のコマンドに関して、macOSとLinuxでは<span class="thesansmonocd_w5regular_">python</span>の代わりに<span class="thesansmonocd_w5regular_">python3</span>としてください。また、このコマンドはPythonの対話型シェルではなく、ターミナルウィンドウから実行します。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-943" aria-label="266"></span><span class="sans_thesansmonocd_w7bold_b_">python –m pip list</span>を実行すると、インストールしたパッケージとそのバージョン番号を一覧表示します。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">python -m pip list</b>
Package                   Version     Editable project location
------------------------- ----------- -------------------------
altgraph                  0.17.3
argon2-cffi               21.3.0
argon2-cffi-bindings      21.2.0
async-generator           1.10
<var class="calibre20">--snip--</var>
wsproto                   1.2.0
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">python –m pip install –U</span> <span class="sans_thesansmonocd_w5regular_italic_">package_name</span>を実行するとPyPIからパッケージを最新のバージョンにアップグレードしますし、<span class="thesansmonocd_w5regular_">python –m pip install</span> <span class="sans_thesansmonocd_w5regular_italic_">package_name</span><span class="thesansmonocd_w5regular_">==1.17.4</span>のように実行すれば指定したバージョンのパッケージをインストールします。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">python –m pip uninstall</span> <span class="sans_thesansmonocd_w5regular_italic_">package_name</span>を実行するとパッケージをアンインストールします。<span class="thesansmonocd_w5regular_">python –m pip --help</span>を実行するとヘルプ情報を見ることができます。</p>
<aside class="box" aria-label="box-14">
<p class="bt" id="calibre_link-1736"><span class="sans_futura_std_bold_b_">automateboringstuff3パッケージのインストール</span></p>
<p class="btni"><span class="sans_futura_std_book_">本書ではサードパーティーのパッケージをいくつか利用しています。時間が経つとパッケージの作者がアップデートを行い、本書で利用しているバージョンと後方互換性が保たれなくなる可能性があります。本書に記載している情報の正確性を保つために、付録Aに記載されているバージョンをインストールしてください。最新のバージョンをインストールしても問題ない場合もありますが、新しい変更点についてそのパッケージのオンラインドキュメントを確認してください。</span></p>
<p class="boxb-last"><span class="sans_futura_std_book_">仮想環境でautomateboringstuff3パッケージをインストールすると、本書で利用しているすべてのパッケージを指定したバージョンでインストールできます。このパッケージは、本書で利用しているバージョンを揃えたすべてのパッケージを含む容器のようなものです。Windowsでは、仮想環境を有効化してから、次のコマンドを実行してください。</span></p>
<pre class="pre"><code class="calibre9"><b class="calibre10">python –m pip install automateboringstuff3</b></code></pre>
<p class="boxb-last"><span class="sans_futura_std_book_">macOSとLinuxでは、仮想環境を有効化してから、次のコマンドを実行してください。</span></p>
<pre class="pre"><code class="calibre9"><b class="calibre10">python3 –m pip install automateboringstuff3</b></code></pre>
</aside>
</section>
<section type="division" aria-labelledby="sec11">
<h3 class="h"><span id="calibre_link-1737"></span><span id="calibre_link-288"></span><span class="sans_futura_std_bold_b_">実行するPythonプログラムについての情報</span></h3>
<p class="tni">プログラムに感覚を持たせるPythonの標準モジュールは（今のところ）ありません。しかし、実行するPythonプログラムやOSやインタープリタなどについて有用な情報を提供する組み込み変数はあります。Pythonのインタープリタが自動的にそれらの変数を設定します。</p>
<p class="tx">変数<span class="thesansmonocd_w5regular_">__file__</span>には<i class="calibre5">.py</i>ファイルのパスが文字列として格納されています。例えば、ホームフォルダで<i class="calibre5">yourScript.py</i>を実行したとすると、<span class="thesansmonocd_w5regular_">'C:\Users\al\yourScript.py'</span>に評価されます。<span class="thesansmonocd_w5regular_">from pathlib import Path</span>とインポートしてから<span class="thesansmonocd_w5regular_">Path(__file__)</span>を呼び出すと、このファイルのパスオブジェクトが返されます。Pythonプログラムフォルダに存在するファイルを知りたければ、この情報を使うことができます。Pythonの対話型シェルでは変数<span class="thesansmonocd_w5regular_">__file__</span>は存在しません。</p>
<p class="tx">変数<span class="thesansmonocd_w5regular_">sys.executable</span>にはPythonインタープリタプログラム自体のフルパスとファイルが格納されており、変数<span class="thesansmonocd_w5regular_">sys.version</span>にはPythonインタープリタのバージョン情報など対話型シェルの上部に現れる文字列が格納されています。</p>
<p class="tx">変数<span class="thesansmonocd_w5regular_">sys.version_info.major</span>と<span class="thesansmonocd_w5regular_">sys.version_info.minor</span>にはPythonインタープリタのメジャーバージョン番号とマイナーバージョン番号の整数が格納されています。筆者の環境ではPythonバージョン3.13.1を使っているので、それぞれ<span class="thesansmonocd_w5regular_">3</span>と<span class="thesansmonocd_w5regular_">13</span>になります。<span class="thesansmonocd_w5regular_">sys.version_info</span> を<span class="thesansmonocd_w5regular_">list()</span>関数に渡すともっと詳細な情報を得られます。筆者の環境では、<span class="thesansmonocd_w5regular_">list(sys.version_info)</span> が<span class="thesansmonocd_w5regular_">[3, 13, 1 'final', 0]</span>を返しました。バージョン情報をこのように取得すると、<span class="thesansmonocd_w5regular_">sys.version</span>の文字列から抽出しようとするよりも簡単です。</p>
<p class="tx">変数<span class="thesansmonocd_w5regular_">os.name</span>には、Windowsで実行しているなら<span class="thesansmonocd_w5regular_">'nt'</span>が、macOSとLinuxで実行しているなら<span class="thesansmonocd_w5regular_">'posix'</span>が格納されます。Pythonのスクリプトが、実行しているOSに応じて別のコードを実行する必要がある場合に便利です。</p>
<p class="tx">OSに関するさらに詳細な情報は、変数<span class="thesansmonocd_w5regular_">sys.platform</span>に格納されています。Windowsなら<span class="thesansmonocd_w5regular_">'win32'</span>、macOSなら<span class="thesansmonocd_w5regular_">'darwin'</span>、Linuxなら<span class="thesansmonocd_w5regular_">'linux'</span>といった具合です。</p>
<p class="tx">OSのバージョンやCPUのタイプについて細かい情報が必要でしたら、組み込みの<span class="thesansmonocd_w5regular_">platform</span>モジュールで情報を取得できます。このモジュールについては<i class="calibre5"><a href="https://docs.python.org/3/library/platform.html" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/platform<wbr></wbr>.html</a></i>で説明されています。</p>
<p class="tx">あるモジュールがインストールされているかどうかをチェックする場合は、<span class="thesansmonocd_w5regular_">import</span>文を<span class="thesansmonocd_w5regular_">try</span>ブロックに入れて<span class="thesansmonocd_w5regular_">ModuleNotFoundError</span>例外を捕捉します。</p>
<pre class="pre"><code class="calibre9">try:
    import nonexistentModule
except ModuleNotFoundError:
    print('This code runs if nonexistentModule was not found.')
</code></pre>
<p class="tx">プログラムの動作に特定のモジュールが必要な場合に、ここで詳細なエラーメッセージを用意して、<span class="thesansmonocd_w5regular_">sys.exit()</span>でプログラムを終了できます。一般的なエラーメッセージとトレースバックを表示するよりもそのほうが親切でしょう。</p>
</section>
<section type="division" aria-labelledby="sec12">
<h3 class="h"><span id="calibre_link-1738"></span><span id="calibre_link-289"></span><span class="sans_futura_std_bold_b_">テキストベースのプログラム設計</span></h3>
<p class="tni">GUIをサポートするOSが一般的になるまでは、プログラムはすべてテキストでユーザーとやり取りしていました。本書で取り上げるプログラムはプロのソフトウェアアプリケーションではなく小規模な便利プログラムですから、ウィンドウやボタンがあるGUIのグラフィックはなく、（昔のプログラムと同じように）<span class="thesansmonocd_w5regular_">print()</span>と<span class="thesansmonocd_w5regular_">input()</span>でやり取りするコマンドラインインターフェイスです。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1042" aria-label="268"></span>テキストに限定されていた時代でも、現代的なGUIに似たユーザーインターフェイスを備えたソフトウェアアプリケーションがありました。図12-1はNorton Commanderというファイルシステム閲覧アプリケーションを示しています。こうしたアプリケーションは遡及的に<i class="calibre5">TUI</i>（<i class="calibre5">text-based user interface</i>）と呼ばれます。</p>
<figure class="img"><img class="img1" id="calibre_link-739" src="images/000010.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 12-1：テキストベースのNorton Commander（上側）と、現代的なGUIアプリケーション（下側）</span></p></figcaption>
</figure>
<p class="tx">テキストベースのユーザーインターフェイスはシンプルだという長所があります。この節では、ユーザーインターフェイスをどう設計するかを考えます。</p>
<section type="division" aria-labelledby="sec13">
<h4 class="h1"><span id="calibre_link-1739"></span><span id="calibre_link-290"></span><span class="sans_futura_std_heavy_oblique_bi_">短いコマンド名</span></h4>
<p class="tni">テキストベースのプログラムは、デスクトップやスタートメニューのアイコンをクリックするのではなく、コマンドラインから実行されることが多いです。こうしたコマンドの中には理解しにくいものもあります。私は、Linuxの学習を始めたときに、よく知っているWindowsの<span class="thesansmonocd_w5regular_">copy</span>コマンドがLinuxでは<span class="thesansmonocd_w5regular_">cp</span>であることを知って驚きました。<i class="calibre5">cp</i>よりも<i class="calibre5">copy</i>のほうがずっとわかりやすいです。簡潔で暗号のような名前で2文字の入力を節約する価値があるのかと疑問に思いました。</p>
<p class="tx">コマンドラインの経験を積むと、短いコマンドに価値があるとわかりました。ソースコードを書くよりも読むほうが多いですから、変数や関数の名前に長い名前をつけるのは役立ちます。しかし、コマンドラインでコマンドを読むよりも打ち込むことのほうが多いですから、反対に短いコマンド名のほうが使いやすく、腕への負担が減ります。</p>
<p class="tx">一日に何十回も打ち込むようなコマンドのプログラムを作成するなら、短い名前にすることを検討してください。<span class="thesansmonocd_w5regular_">which</span>ないし<span class="thesansmonocd_w5regular_">where</span>コマンドを実行すれば、別のプログラムで使われている名前かどうか確認できます。インターネットでコマンドの名前を調べることもできます。短い名前にすると使いやすいです。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h4 class="h1"><span id="calibre_link-1740"></span><span id="calibre_link-291"></span><span class="sans_futura_std_heavy_oblique_bi_">コマンドライン引数</span></h4>
<p class="tni">コマンドラインからプログラムを実行するには、その名前を入力します。<i class="calibre5">.py</i>のPythonのソースコードファイルを実行する場合は、<span class="thesansmonocd_w5regular_">python yourScript.py</span>のように<span class="thesansmonocd_w5regular_">python</span>（Windows）ないし<span class="thesansmonocd_w5regular_">python3</span>（macOSとLinux）プログラムのあとに<i class="calibre5">.py</i>のファイル名をつけます。</p>
<p class="tx">コマンドのあとにつけるテキストを<i class="calibre5">コマンドライン引数</i>と呼びます。コマンドライン引数は、関数呼び出しに引数が渡されるのと同じ要領で、コマンドに渡されます。例えば、<span class="thesansmonocd_w5regular_">ls</span>コマンドを単独で実行するとCWD内のファイルを一覧表示します。<span class="thesansmonocd_w5regular_">exampleFolder</span>というコマンドライン引数をつけて<span class="thesansmonocd_w5regular_">ls exampleFolder</span>を実行すると、<span class="thesansmonocd_w5regular_">ls</span>は<i class="calibre5">exampleFolder</i>フォルダ内のファイルを一覧表示します。コマンドライン引数を利用するとコマンドの動作を設定できます。</p>
<p class="tx">Pythonスクリプトでは、リスト<span class="thesansmonocd_w5regular_">sys.argv</span>にPythonインタープリタが受け取ったコマンドライン引数が入っています。例えば、<span class="thesansmonocd_w5regular_">python3 yourScript.py hello world</span>と入力したら、<span class="thesansmonocd_w5regular_">python3</span>プログラムがコマンドライン引数を受け取り、Pythonスクリプトの変数<span class="thesansmonocd_w5regular_">sys.argv</span>に転送します。変数<span class="thesansmonocd_w5regular_">sys.argv</span>には<span class="thesansmonocd_w5regular_">['yourScript.py', 'hello', 'world']</span>が格納されます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">sys.argv</span>の最初の要素はPythonスクリプトのファイル名です。残りの引数はスペースで分割されます。コマンドライン引数にスペースを含めたければ、ダブルクォートで囲んでください。例えば、<span class="thesansmonocd_w5regular_">python3 yourScript.py "hello world"</span>だと<span class="thesansmonocd_w5regular_">sys.argv</span>に<span class="thesansmonocd_w5regular_">['yourScript.py', 'hello world']</span>が格納されます。</p>
<p class="tx">コマンドライン引数を使う利点は、プログラムを開始する前にさまざまな設定ができることです。設定メニューや多段階プログラムは不要です。このアプローチでは、コマンドライン引数が複雑で読みにくくなる可能性があるという欠点があります。Windowsのコマンドなら<span class="thesansmonocd_w5regular_">/?</span>を、macOSとLinuxのコマンドなら<span class="thesansmonocd_w5regular_">--help</span>を、コマンドのあとにつけると、何ページにもわたってコマンドライン引数を説明するドキュメントを見ることになるでしょう。</p>
<p class="tx">プログラムが受け入れるコマンドライン引数が単純であれば、<span class="thesansmonocd_w5regular_">sys.argv</span>のリストを直接読み取るのが一番簡単です。しかし、コマンドライン引数が増えてきたら、その組み合わせを管理するのが重荷になり始めます。<span class="thesansmonocd_w5regular_">python yourScript.py spam eggs</span>と<span class="thesansmonocd_w5regular_">python yourScript.py eggs spam</span>は同じであるのか、<span class="thesansmonocd_w5regular_">cheese</span>と<span class="thesansmonocd_w5regular_">bacon</span>を選べるのであれば、両方を指定した場合にはどうなるのか、などを考えなければなりません。こうした複雑性に対処するには、限界事例を処理するたくさんのコードを書かなければなりません。そうなると、Python組み込みの<span class="thesansmonocd_w5regular_">argparse</span>モジュールを使って処理したほうがよいでしょう。<span class="thesansmonocd_w5regular_">argparse</span>モジュールは本書の範囲外ですが、<i class="calibre5"><a href="https://docs.python.org/3/library/argparse.html" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/argparse<wbr></wbr>.html</a></i>で説明を読めます。</p>
</section>
<section type="division" aria-labelledby="sec15">
<h4 class="h1"><span id="calibre_link-1741"></span><span id="calibre_link-292"></span><span class="sans_futura_std_heavy_oblique_bi_">クリップボードの入出力</span></h4>
<p class="tni">テキストを受け取るのに<span class="thesansmonocd_w5regular_">input()</span>を使わなければならないという決まりはありません。クリップボードを通じてPythonのプログラムとテキストのやり取りをすることもできます。<span class="thesansmonocd_w5regular_">pyperclip</span>モジュールはクロスプラットフォームであり、（OSを問わず）<span class="thesansmonocd_w5regular_">copy()</span>関数でクリップボードにテキストを貼り付け、<span class="thesansmonocd_w5regular_">paste()</span>関数でクリップボードのテキストを文字列として取得します。Pyperclipはターミナルからpipで<span class="thesansmonocd_w5regular_">python –m pip install pyperclip</span>を実行してインストールするサードパーティーのパッケージです。Linuxでは、<span class="thesansmonocd_w5regular_">sudo apt install xclip</span>も実行する必要があります。詳細は<span>付録A</span>をご参照ください。</p>
<p class="tx">クリップボードで入出力を行うプログラムは、以下の基本設計になります。</p>
<p class="listnumberf">  1. <span class="thesansmonocd_w5regular_">pyperclip</span>モジュールをインポートする</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">pyperclip.paste()</span>でクリップボードからテキストを取得する</p>
<p class="listnumber">  3. そのテキストを使って処理を行う</p>
<p class="listnumberl">  4. <span class="thesansmonocd_w5regular_">pyperclip.copy()</span>で処理済みのテキストをクリップボードに貼り付ける</p>
<p class="tx"><span>第8章</span>の「ウィキマークアップに箇条書き記号を追加する」プロジェクトがその一例です。このようにプログラムを設計して、<span>「Pythonプログラムのデプロイ」</span>の指示通りにデプロイすると、使いやすいです。入力テキストを反転させ、<small class="calibre4">CTRL</small>-Cでコピーし、プログラムを実行します。そうすると処理済みのテキストがクリップボードに保存されますから、必要に応じて貼り付けて使えます。</p>
<p class="tx">本章の最後で、クリップボードを活用する<span class="thesansmonocd_w5regular_">ccwd</span>とクリップボードレコーダーの2つのプロジェクトに取り組みます。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h4 class="h1"><span id="calibre_link-1742"></span><span id="calibre_link-293"></span><span class="sans_futura_std_heavy_oblique_bi_">Bextでテキストに色をつける</span></h4>
<p class="tni">Jonathan HartleyのColoramaパッケージをもとに作られたサードパーティーのBextパッケージを利用すると、テキストに色をつけて出力できます。<span>付録A</span>の指示に従ってpipでBextをインストールしてください。Bextはターミナルウィンドウから実行するプログラムでのみ機能し、Muその他のエディタから実行するプログラムでは機能しません。<span class="thesansmonocd_w5regular_">fg()</span>関数と<span class="thesansmonocd_w5regular_">bg()</span>関数を<span class="thesansmonocd_w5regular_">'black'</span>、<span class="thesansmonocd_w5regular_">'red'</span>、<span class="thesansmonocd_w5regular_">'green'</span>、<span class="thesansmonocd_w5regular_">'yellow'</span>、<span class="thesansmonocd_w5regular_">'blue'</span>、<span class="thesansmonocd_w5regular_">'magenta'</span>、<span class="thesansmonocd_w5regular_">'purple'</span>、<span class="thesansmonocd_w5regular_">'cyan'</span>、<span class="thesansmonocd_w5regular_">'white'</span>のような引数で呼び出して前面のテキスト色と背景色を変更すれば、<span class="thesansmonocd_w5regular_">print()</span>で色のついたテキストを出力できます。<span class="thesansmonocd_w5regular_">'reset'</span>を渡すとターミナルウィンドウのデフォルトの色に戻ります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import bext</b>
&gt;&gt;&gt; <b class="calibre10">bext.fg('red')</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-929" aria-label="271"></span>&gt;&gt;&gt; <b class="calibre10">print('This text is red.')</b>
This text is red.
&gt;&gt;&gt; <b class="calibre10">bext.bg('blue')</b>
&gt;&gt;&gt; <b class="calibre10">print('Red text on blue background is an ugly color scheme.')</b>
Red text on blue background is an ugly color scheme.
&gt;&gt;&gt; <b class="calibre10">bext.fg('reset')</b>
&gt;&gt;&gt; <b class="calibre10">bext.bg('reset')</b>
&gt;&gt;&gt; <b class="calibre10">print('The text is normal again. Ah, much better.')</b>
The text is normal again. Ah, much better.
</code></pre>
<p class="tx">ユーザーがターミナルウィンドウをライトモードに設定しているかダークモードに設定しているかはわかりませんので、ターミナルのデフォルトの見た目が白地に黒色のテキストなのか黒地に白色のテキストなのかはわかりません。また、あまりにたくさんの色を使わないほうがよいでしょう。色を使いすぎると悪趣味で読みづらくなります。</p>
<p class="tx">Bextには以下のようなちょっとしたTUI機能もあります。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">bext.clear()</span> 画面をクリアします。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">bext.width()</span><b class="calibre10">と</b><span class="sans_thesansmonocd_w7bold_b_">bext.height()</span> ターミナルウィンドウの幅と高さをそれぞれ返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">bext.hide()</span><b class="calibre10">と</b><span class="sans_thesansmonocd_w7bold_b_">bext.show()</span> カーソルの非表示／表示を切り替えます。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">bext.title(text)</span> ターミナルウィンドウのタイトルバーに表示されるテキストを変更します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">bext.goto(x, y)</span> カーソルを座標(x, y)に移動させます。左上が(0, 0)です。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">bext.get_key()</span> ユーザーのキー入力を待ち受け、キーが押されるとそのキーを表す文字列を返します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">bext.get_key()</span>関数は<span class="thesansmonocd_w5regular_">input()</span>の1キーバージョンだと考えてください。返り値は<span class="thesansmonocd_w5regular_">'a'</span>、<span class="thesansmonocd_w5regular_">'z'</span>、<span class="thesansmonocd_w5regular_">'5'</span>といったものもあれば、<span class="thesansmonocd_w5regular_">'left'</span>、<span class="thesansmonocd_w5regular_">'f1'</span>、<span class="thesansmonocd_w5regular_">'esc'</span>といったものもあります。<small class="calibre4">TAB</small>キーは<span class="thesansmonocd_w5regular_">'\t'</span>、<small class="calibre4">ENTER</small>キーは<span class="thesansmonocd_w5regular_">'\n'</span>を返します。対話型シェルで<span class="thesansmonocd_w5regular_">bext.get_key()</span>を呼び出すとキーの返り値を試せます。</p>
<p class="tx"><i class="calibre5"><a href="https://inventwithpython.com/projects/fishtank.py" class="calibre1">https://<wbr></wbr>inventwithpython<wbr></wbr>.com<wbr></wbr>/projects<wbr></wbr>/fishtank<wbr></wbr>.py</a></i>のアスキーアート水槽プログラムのコードを実行すると、Bextで何ができるかをつかめます。このプログラムでは最初に<span class="thesansmonocd_w5regular_">bext.clear()</span>でターミナルウィンドウのテキストをすべてクリアしています。次に、<span class="thesansmonocd_w5regular_">bext.goto()</span>を呼び出してカーソルを移動させ、<span class="thesansmonocd_w5regular_">bext.fg()</span>でテキストの色を変更し、<span class="thesansmonocd_w5regular_">&gt;&lt;)))*&gt;</span>のようなテキストで魚を表示しています。このプログラムは筆者の別の本の<i class="calibre5">The Big Book of Small Python Projects</i> (No Starch Press, 2021)で取り上げています。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h4 class="h1"><span id="calibre_link-1743"></span><span id="calibre_link-294"></span><span class="sans_futura_std_heavy_oblique_bi_">ターミナルのクリア</span></h4>
<p class="tni">プログラムを実行する前にターミナルのテキストを消したいときに、<span class="thesansmonocd_w5regular_">bext.clear()</span>関数は便利です。パラパラ漫画のアニメーションにも使えます。<span class="thesansmonocd_w5regular_">clear()</span>を呼び出してターミナルをクリアして、<span class="thesansmonocd_w5regular_">print()</span>呼び出しでテキストを表示し、<span class="thesansmonocd_w5regular_">time.sleep()</span>で停止して…を繰り返します。以下の自作の<span class="thesansmonocd_w5regular_">clear()</span>関数は、画面をクリアするPythonの<i class="calibre5">ワンライナー</i>（1行のコード）です。</p>
<pre class="pre"><code class="calibre9">import os
def clear():
    os.system('cls' if os.name == 'nt' else 'clear')
</code></pre>
<p class="tx">このコードを実行すると、Bext パッケージをインストールしなくてもターミナルをクリアできます。Muその他のコードエディタからの実行では動作せず、ターミナルからスクリプトを実行する必要があります。<span class="thesansmonocd_w5regular_">os.system()</span>呼び出しは、Windowsなら<span class="thesansmonocd_w5regular_">cls</span>プログラムを、macOSとLinuxなら<span class="thesansmonocd_w5regular_">clear</span>プログラムを実行します。この奇妙な構文はPythonの<i class="calibre5">条件式</i>（他の言語では<i class="calibre5">三項演算子</i>と呼ばれることもあります）の一例です。<span class="sans_thesansmonocd_w5regular_italic_">value1</span> <span class="thesansmonocd_w5regular_">if</span> <span class="sans_thesansmonocd_w5regular_italic_">condition</span> <span class="thesansmonocd_w5regular_">else</span> <span class="sans_thesansmonocd_w5regular_italic_">value2</span>という構文は、<span class="sans_thesansmonocd_w5regular_italic_">condition</span> が<span class="thesansmonocd_w5regular_">True</span>なら<span class="sans_thesansmonocd_w5regular_italic_">value1</span>と評価され、<span class="sans_thesansmonocd_w5regular_italic_">condition</span>が<span class="thesansmonocd_w5regular_">False</span>なら<span class="sans_thesansmonocd_w5regular_italic_">value2</span>と評価されます。この例では、<span class="thesansmonocd_w5regular_">os.name</span> <span class="thesansmonocd_w5regular_">==</span> <span class="thesansmonocd_w5regular_">'nt'</span>が<span class="thesansmonocd_w5regular_">True</span>なら<span class="thesansmonocd_w5regular_">'cls'</span>と評価され、<span class="thesansmonocd_w5regular_">os.name</span> <span class="thesansmonocd_w5regular_">==</span> <span class="thesansmonocd_w5regular_">'nt'</span>が<span class="thesansmonocd_w5regular_">False</span>なら<span class="thesansmonocd_w5regular_">'clear'</span>と評価されます。条件式（とワンライナー一般）は、読みづらく避けたほうがいいですが、これくらい単純な例なら使ってもよいでしょう。</p>
</section>
<section type="division" aria-labelledby="sec18">
<h4 class="h1"><span id="calibre_link-1744"></span><span id="calibre_link-295"></span><span class="sans_futura_std_heavy_oblique_bi_">音とテキストによる通知</span></h4>
<p class="tni">ターミナルプログラムは、今日のコンピュータで利用できるオーディオ機能よりも前から存在していました。今日では、テキストベースのプログラムが音を出してはいけない理由はありません。とはいえ、音を出すのは最小限にとどめたほうがよいでしょう。ユーザーが別のウィンドウを見ていても、作業が完了したり問題が発生したときに音を出すと通知できます。しかし、色のついたテキストと同様に、音を使いすぎてうっとうしく感じることがあります。ユーザーは音声を再生しているかもしれませんし、オンラインミーティングに参加しているかもしれず、音を出すとその邪魔をしてしまいます。そもそも、ユーザーのコンピュータはミュートになっていて音を出して通知をしようとしても聞こえないかもしれません。</p>
<p class="tx">単純なオーディオファイルを再生するには、playsound3というサードパーティーのパッケージを利用できます。これをインストールすれば<span class="thesansmonocd_w5regular_">playsound3</span>モジュールの<span class="thesansmonocd_w5regular_">playsound()</span>関数を呼び出してMP3またはWAVのオーディオファイルのパスを渡せばそのオーディオファイルを再生できます。<i class="calibre5"><a href="https://autbor.com/hello.mp3" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/hello<wbr></wbr>.mp3</a></i>から<i class="calibre5">hello.mp3 file</i>ファイルをダウンロードするか自分でファイルを用意して、対話型シェルで以下のコードを入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import playsound3</b>
&gt;&gt;&gt; <b class="calibre10">playsound3.playsound('hello.mp3')</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">playsound()</span>関数はオーディオファイルの再生が終わるまで値を返しません。つまり、この関数はオーディオが終わるまでプログラム実行を<i class="calibre5">ブロック</i>します。長いオーディオファイルを再生するとプログラムが停止してしまうことに注意してください。（ファイル名にイコール記号などが含まれるなどで）<span class="thesansmonocd_w5regular_">playsound()</span>が例外を送出する場合には、文字列ではなく<span class="thesansmonocd_w5regular_">Path</span>オブジェクトを渡してみてください。</p>
<p class="tx">プログラムが出力するテキストにも制限を設けたほうがよいかもしれません。Unix哲学のコマンド設計では、あるコマンドのテキスト出力をパイプでつないで別のコマンドに渡します。コマンドが重要な情報だけを出力すれば、それがやりやすくなります。重要ではない出力がある場合はフィルターにかけなければなりません。多くのコマンドは出力を最小限にとどめているか、そもそも出力をせずに終了コード（exit code）でコマンドの成功／不成功を伝えます（終了コードについては<span>第19章</span>で説明します）。出力をパイプで別のコマンドにつなぐつもりはなく、人間のユーザーが見るためにたくさんの情報がほしければ、<span class="thesansmonocd_w5regular_">-v</span>ないし<span class="thesansmonocd_w5regular_">--verbose</span>コマンドライン引数で<i class="calibre5">冗長モード</i>にできるコマンドが多いです。逆のアプローチを採用しているコマンドもあります。つまり、デフォルトではたくさんの出力をして、<span class="thesansmonocd_w5regular_">-q</span>ないし<span class="thesansmonocd_w5regular_">--quiet</span>コマンドライン引数を指定すると<i class="calibre5">静寂モード</i>で出力をしないコマンドです。（音による通知でも同じような考え方ができます。）無音モードをデフォルトにして、<span class="thesansmonocd_w5regular_">--verbose</span>ないし<span class="thesansmonocd_w5regular_">--beep</span>で音を出すようにするのがよいでしょう。</p>
<p class="tx">プログラムをそこまで洗練させる必要がなければ、この節の内容は忘れてください。しかし、自分が書いたプログラムを他の人と共有し始めると、自分が思ってもみなかった使い方をするユーザーがいるので、こうしたオプションを提供すると使いやすいプログラムになります。</p>
</section>
</section>
<section type="division" aria-labelledby="sec19">
<h3 class="h"><span id="calibre_link-1745"></span><span id="calibre_link-296"></span><span class="sans_futura_std_bold_b_">短いプログラム：吹雪</span></h3>
<p class="tni">テキストベースの吹雪アニメーションを作りましょう。半分、下半分、全体のブロックテキストを使います。これらのブロックテキストは、<span class="thesansmonocd_w5regular_">chr(9600)</span>、<span class="thesansmonocd_w5regular_">chr(9604)</span>、<span class="thesansmonocd_w5regular_">chr(9608)</span>で返されます。<span class="thesansmonocd_w5regular_">TOP</span>、<span class="thesansmonocd_w5regular_">BOTTOM</span>、<span class="thesansmonocd_w5regular_">FULL</span>という定数に格納し、コードを読みやすくします。</p>
<p class="tx">以下のコードを<i class="calibre5">snowstorm.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import os, random, time, sys

TOP    = chr(9600)  # Character 9600は'<span class="sans_courier_std_medium_">▀</span>'
BOTTOM = chr(9604)  # Character 9604は'<span class="sans_courier_std_medium_">▄</span>'
FULL   = chr(9608)  # Character 9608は'<span class="sans_courier_std_medium_">█</span>'

# コマンドライン引数で吹雪の密度を指定
DENSITY = 4  # デフォルトの吹雪の密度は4%
if len(sys.argv) &gt; 1:
    DENSITY = int(sys.argv[1])

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

while True:
    clear()  # ターミナルウィンドウのクリア

    # 各行と各列をループ
    for y in range(20):
        for x in range(40):
            if random.randint(0, 99) &lt; DENSITY:
                # 雪の表示
                print(random.choice([TOP, BOTTOM]), end='')
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1086" aria-label="274"></span>            else:
                # スペースの表示
                print(' ', end='')
        print()  # 改行の出力

    # 雪で覆われた地面を表示
    print(FULL * 40 + '\n' + FULL * 40)
    print('(Ctrl-C to stop.)')

    time.sleep(0.2)  # 少し停止
</code></pre>
<p class="tx">まず、<span class="thesansmonocd_w5regular_">os</span>、<span class="thesansmonocd_w5regular_">random</span>、<span class="thesansmonocd_w5regular_">sys</span>、<span class="thesansmonocd_w5regular_">time</span>のモジュールをインポートします。これらのモジュールはPythonの標準ライブラリに含まれていますから、サードパーティーパッケージをインストールする必要はありません。次に、定数<span class="thesansmonocd_w5regular_">TOP</span>、<span class="thesansmonocd_w5regular_">BOTTOM</span>、<span class="thesansmonocd_w5regular_">FULL</span>に<span class="thesansmonocd_w5regular_">chr()</span>の返り値を設定します。9600、9604、9608という数字よりも定数の名前のほうが理解しやすいです。</p>
<p class="tx">ユーザーはコマンドライン引数で吹雪の密度を指定できます。コマンドライン引数が指定されなければ、<span class="thesansmonocd_w5regular_">sys.argv</span>は<span class="thesansmonocd_w5regular_">['snowstorm.py']</span>になりますので、<span class="thesansmonocd_w5regular_">DENSITY</span>は<span class="thesansmonocd_w5regular_">4</span>のままです。ユーザーが例えば<span class="thesansmonocd_w5regular_">python snowstorm.py 20</span>のようにプログラムを実行すると、<span class="thesansmonocd_w5regular_">sys.argv</span>は<span class="thesansmonocd_w5regular_">['snowstorm.py', '20']</span>になり、<span class="thesansmonocd_w5regular_">DENSITY</span>を<span class="thesansmonocd_w5regular_">int(sys.argv[1])</span>、すなわち<span class="thesansmonocd_w5regular_">20</span>に更新します。ユーザーはソースコードを変更せずに吹雪プログラムの動作を調整できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">while</span>無限ループ内では、まず<span class="thesansmonocd_w5regular_">cls</span>/<span class="thesansmonocd_w5regular_">clear</span>ワンライナーで画面をクリアします。次に入れ子の<span class="thesansmonocd_w5regular_">for</span>ループでターミナルの40×20のスペースの行と列を反復処理します。（この数字を増やしたり減らしたりすると吹雪のサイズを変更できます。）各行及び各列について一つの文字を出力します。雪を表す<span class="thesansmonocd_w5regular_">TOP</span>または<span class="thesansmonocd_w5regular_">BOTTOM</span>か、何もないスペースのどちらかをランダムに選びます。（4パーセントだけ雪を表す文字が選ばれます。）ここでの<span class="thesansmonocd_w5regular_">print()</span>呼び出しでは<span class="thesansmonocd_w5regular_">end=''</span>キーワード引数を指定しているので、<span class="thesansmonocd_w5regular_">print()</span>は自動的に改行文字を出力しません。行が終わったあとに<span class="thesansmonocd_w5regular_">print()</span>を引数なしで呼び出して改行を出力します。</p>
<p class="tx">入れ子の<span class="thesansmonocd_w5regular_">for</span>ループのあとで、地面を表す2行の<span class="thesansmonocd_w5regular_">FULL</span>と、<small class="calibre4">CTRL</small>-Cを押せばプログラムが停止する案内を出力します。このコードは吹雪アニメーションの1フレームを出力してから<span class="thesansmonocd_w5regular_">time.sleep(0.2)</span>で少し静止し、ターミナルをクリアして…という実行を繰り返します。</p>
<p class="tx">実用的ではありませんが、ターミナルによるスノーグローブのようで楽しいからこのプログラムを紹介しました。このテクニックを活用した役に立つアプリケーションとして、<i class="calibre5">ダッシュボード</i>アプリを作成できます。ターミナルウィンドウで実行して開いたままにしておき、ひと目で情報がわかるようにするプログラムです。このプログラムは重要な情報を表示し、毎秒、毎分、毎時など適時情報を更新します。</p>
</section>
<section type="division" aria-labelledby="sec20">
<h3 class="h"><span id="calibre_link-1746"></span><span id="calibre_link-297"></span><span class="sans_futura_std_bold_b_">PyMsgBoxによるポップアップメッセージボックス</span></h3>
<p class="tni">プログラムで完全なGUIをデザインするには、Tkinter、wxPython、PyQtなどのライブラリを十分に学習する必要がありますが、PyMsgBoxパッケージで簡単なGUIメッセージボックスをプログラムで作成できます。ターミナルから<span class="thesansmonocd_w5regular_">pip install pymsgbox</span>を実行してインストールできるサードパーティーのパッケージです。PyMsgBoxではTkinterを使用したダイアログを作成します。WindowsとmacOSではTkinterが付属していますが、Ubuntu Linuxではターミナルで<span class="thesansmonocd_w5regular_">sudo apt install python3-tk</span>を実行してTkinterをインストールしなければなりません。<span>付録A</span>で詳しく説明しています。</p>
<p class="tx">PyMsgBoxにはJavaScriptのメッセージボックス関数と対応する関数があります。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">pymsgbox.alert</span><span class="sans_thesansmonocd_w7bold_italic_bi_">(text)</span> テキストメッセージを表示し、ユーザーがOKをクリックしたら文字列<span class="thesansmonocd_w5regular_">'OK'</span>を返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">pymsgbox.confirm</span><span class="sans_thesansmonocd_w7bold_italic_bi_">(text)</span> テキストメッセージを表示し、ユーザーがOKまたはCancelをクリックしたら文字列<span class="thesansmonocd_w5regular_">'OK'</span>または<span class="thesansmonocd_w5regular_">'Cancel'</span>を返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">pymsgbox.prompt</span><span class="sans_thesansmonocd_w7bold_italic_bi_">(text)</span> テキストフィールドがあるメッセージを表示し、ユーザーが入力したテキスト文字列または<span class="thesansmonocd_w5regular_">None</span>（キャンセルをクリックした場合）を返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">pymsgbox.password</span><span class="sans_thesansmonocd_w7bold_italic_bi_">(text)</span> <span class="thesansmonocd_w5regular_">pymsgbox.prompt()</span>と同じですが、ユーザーの入力がアスタリスクでマスクされます。</p>
<p class="tx">これらの関数はユーザーがOK、Cancel、X（閉じる）をクリックするまで値を返しません。たまに通知をしたいだけなら、PyMsgBoxのダイアログを<span class="thesansmonocd_w5regular_">print()</span>や<span class="thesansmonocd_w5regular_">input()</span>の代わりに利用できます。</p>
</section>
<section type="division" aria-labelledby="sec21">
<h3 class="h"><span id="calibre_link-1747"></span><span id="calibre_link-298"></span><span class="sans_futura_std_bold_b_">Pythonプログラムのデプロイ</span></h3>
<p class="tni">Pythonプログラムが完成したら、毎回Muを実行して<i class="calibre5">.py</i>ファイルを読み込み実行ボタンを押すのは面倒に感じます。この節では、自分が書いたPythonプログラムをデプロイして、できるだけ少ない手数で実行できるようにデプロイする方法を説明します。</p>
<p class="tx"><span>「PATH環境変数」</span>の手順に従って<i class="calibre5">Scripts</i>フォルダを<span class="thesansmonocd_w5regular_">PATH</span>環境変数に追加してください。私のユーザー名は<i class="calibre5">al</i>ですので、そのフォルダのパスはWindowsなら<i class="calibre5">C:\Users\al\Scripts</i>、macOSなら<i class="calibre5">/Users/al/Scripts</i>、Linuxなら<i class="calibre5">/home/al/Scripts</i>になります。また、次に説明するように、Pythonの仮想環境を設定する必要があります。</p>
<section type="division" aria-labelledby="sec22">
<h4 class="h1"><span id="calibre_link-1748"></span><span id="calibre_link-299"></span><span class="sans_futura_std_heavy_oblique_bi_">Windows</span></h4>
<p class="tni">Windowsでは、WindowsキーとRキーを同時に押すと（あるいはスタートメニューボタンを右クリックして実行を選ぶと）実行ダイアログが立ち上がります。小さなウィンドウが開き、一つのコマンドを実行できるので、一回限りのターミナルのように使えます。ここからPythonスクリプトを実行するには、以下の手順で進めます。</p>
<p class="listnumberf">  1. <i class="calibre5">Scripts</i>フォルダに<i class="calibre5">yourScript.py</i>Pythonスクリプトを置く。</p>
<p class="listnumberl">  2. <i class="calibre5">Scripts</i>フォルダにPythonスクリプトを実行するための<i class="calibre5">yourScript.bat</i>バッチファイルを作成する。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-847" aria-label="276"></span><i class="calibre5">バッチファイル</i>を実行すると、そのファイルに書かれたコマンドが実行されます。ファイル拡張子は<i class="calibre5">.bat</i>で、LinuxのシェルスクリプトやmacOSの<i class="calibre5">.command</i>スクリプトに似ています。<span class="thesansmonocd_w5regular_">PATH</span>フォルダの中に<i class="calibre5">yourScript.bat</i>という名前のバッチファイルを置いたら、実行ダイアログに<span class="thesansmonocd_w5regular_">yourScript</span>と入力して実行できます。Windowsでは<i class="calibre5">.bat</i>ファイルや<i class="calibre5">.exe</i>ファイルを実行するのにファイル拡張子を入力する必要はありません。</p>
<p class="tx">バッチファイルの中身は、<i class="calibre5">.py</i>ファイルと同じように、プレーンテキストですので、Muやメモ帳などのテキストエディタで作成できます。バッチファイルでは1行に1つのコマンドを書きます。<i class="calibre5">C:\Users\al\Scripts</i>フォルダ内の<i class="calibre5">yourScript.py</i>ファイルを実行するには、以下の内容の<i class="calibre5">yourScript.bat</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">@call %HOMEDRIVE%%HOMEPATH%\Scripts\.venv\Scripts\activate.bat
@python %HOMEDRIVE%%HOMEPATH%\Scripts\yourScript.py %*
@pause
@deactivate
</code></pre>
<p class="tx">バッチファイルの名前は何でも構いませんが、Pythonスクリプトと同じ名前にしたほうが覚えやすいです。このバッチファイルは3つのコマンドを実行します。1つ目のコマンドは、<i class="calibre5">Scripts</i>フォルダに作成した仮想環境を有効化します。冒頭の<span class="thesansmonocd_w5regular_">@</span>記号はこのコマンド自体がターミナルウィンドウに表示されないようにするためのものです。環境変数<span class="thesansmonocd_w5regular_">%HOMEDRIVE%</span>は<span class="thesansmonocd_w5regular_">'C:'</span>で、<span class="thesansmonocd_w5regular_">%HOMEPATH%</span>は<span class="thesansmonocd_w5regular_">'\Users\al'</span>のようなホームフォルダのパスです。（Windowsではチルダ（<span class="thesansmonocd_w5regular_">~</span>）がホームフォルダを表しません。）これらを合わせると、ユーザー名が何であっても、仮想環境を有効化するスクリプトの場所を指定できます。（これらのファイルを同僚に共有してその人のコンピュータで実行するときに便利です。）<span class="thesansmonocd_w5regular_">call</span>は必要です。（<i class="calibre5">yourScript.bat</i>のような）バッチファイルが別の（<i class="calibre5">activate.bat</i>のような）バッチファイルを実行するときに<span class="thesansmonocd_w5regular_">call</span>がなければ、最初のバッチファイルの残りのコマンドが実行されません。</p>
<p class="tx">2つ目のコマンドは、バッチファイルが<i class="calibre5">python.exe</i>を実行し、<i class="calibre5">yourScript.py</i>を実行します。<span class="thesansmonocd_w5regular_">%*</span>はバッチファイルにコマンドライン引数をPythonプログラムへと転送します。あとでPythonプログラムにコマンドライン引数を追加する場合に備えて、必ず<span class="thesansmonocd_w5regular_">%*</span>をつけるのはいい考えです。</p>
<p class="tx">3つ目のコマンドは、<span class="thesansmonocd_w5regular_">pause</span>コマンドを実行し、<span class="thesansmonocd_w5regular_">Press any key to continue</span>を表示して、ユーザーが何らかのキーを押すのを待ちます。こうすることで、Pythonプログラムが終了するとターミナルウィンドウがすぐに閉じてしまって出力が見られなくなる事態を防ぎます。プログラムからの出力がなければ、この行を書かなくても大丈夫です。最後に、<span class="thesansmonocd_w5regular_">@deactivate</span>で仮想環境を無効化します。ターミナルからバッチファイルを実行したときに、Pythonプログラムが終了したあとでターミナルを開いたまま使う場合を考えてのことです。</p>
<p class="tx">バッチファイルを設定すると、WindowsキーとRキーを押して実行ダイアログを表示し、<span class="thesansmonocd_w5regular_">yourScript</span>（とコマンドライン引数）と入力すれば<i class="calibre5">yourScript.bat</i>スクリプトを実行することによりPythonスクリプトを実行できます。あるいは、ターミナルウィンドウを開いているなら、どの場所からでもターミナルで<span class="thesansmonocd_w5regular_">yourScript</span>と入力することでもPythonスクリプトを実行できます。これはMuのようなエディタからコードを実行するよりも断然速いです。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1013" aria-label="277"></span>別のPythonスクリプトを作成したら、このバッチファイルを再利用できます。新しい名前でファイルをコピーし、ファイル名の<i class="calibre5">yourScript.py</i>を新しいPythonスクリプトの名前に変更します。あとはすべて同じです。</p>
</section>
<section type="division" aria-labelledby="sec23">
<h4 class="h1"><span id="calibre_link-1749"></span><span id="calibre_link-300"></span><span class="sans_futura_std_heavy_oblique_bi_">macOS</span></h4>
<p class="tni">macOSで<small class="calibre4">COMMAND</small>キーとスペースキーを同時に押すと、Spotlightが立ち上がり、実行するプログラム名を入力できます。Spotlightに自分が書いたPythonスクリプトを追加するには、以下の手順で進めます。</p>
<p class="listnumberf">  1. <i class="calibre5">Scripts</i>フォルダに<i class="calibre5">yourScript.py</i>Pythonスクリプトを置く。</p>
<p class="listnumber">  2. そのPythonスクリプトを実行するための<i class="calibre5">yourScript.command</i>という名前のテキストファイルを作成する。</p>
<p class="listnumberl">  3. <span class="thesansmonocd_w5regular_">chmod u+x yourScript.command</span>を実行して<i class="calibre5">yourScript.command</i>ファイルに実行パーミッションを追加する。</p>
<p class="tx"><i class="calibre5">/Users/al/Scripts</i>のような<i class="calibre5">Scripts</i>フォルダに<i class="calibre5">.py</i>Pythonスクリプトを置いてから、以下の内容の<i class="calibre5">yourScript.command</i>という名前のテキストファイルを<i class="calibre5">Scripts</i>フォルダに作成します。</p>
<pre class="pre"><code class="calibre9">source ~/Scripts/.venv/bin/activate
python3 ~/Scripts/yourScript.py
deactivate
</code></pre>
<p class="tx"><i class="calibre5">~</i>は<i class="calibre5">/Users/al</i>のようなホームフォルダを表します。最初の行は仮想環境を有効化し、2行目は仮想環境のPythonを使ってPythonスクリプトを実行します。</p>
<p class="tx">最後に、ターミナルで<span class="thesansmonocd_w5regular_">cd</span>により<i class="calibre5">~/Scripts</i>へ移動し、<span class="thesansmonocd_w5regular_">chmod u+x yourScript.command</span>コマンドを実行してください。これにより、Spotlightからスクリプトを実行するのに必要な実行パーミッションが追加されます。<span class="dedication_italic">⌘</span>とスペースキーを押して<i class="calibre5">yourScript.command</i>と入力すれば素早くPythonスクリプトを実行できます。（Spotlightは数文字入力すると完全な名前を自動補完してくれるはずです。）ターミナルから<span class="thesansmonocd_w5regular_">yourScript.command</span>と入力することでもPythonスクリプトを実行できます。</p>
<p class="tx">Spotlightから<i class="calibre5">yourScript.py</i>ファイルを実行するには<i class="calibre5">yourScript.command</i>ファイルが必要です。Spotlightは<i class="calibre5">.py</i>ファイル拡張子を見て、直接実行するのではなく、Muその他のコードエディタで開くのだと想定してしまいます。</p>
<p class="tx">macOSのテキストエディットで<i class="calibre5">yourScript.command</i>ファイルを作成するときには、<small class="calibre4">SHIFT</small>-<span class="dedication_italic">⌘</span>-Tを押して（あるいはフォーマットメニューから標準テキストをクリックして）プレーンテキストファイルで作成してください。テキストエディットは<span class="thesansmonocd_w5regular_">python3</span>を<span class="thesansmonocd_w5regular_">Python3</span>へと自動的に大文字にするので（そうなるとSpotlightから実行しようとしたときにエラーが発生します）、その点にも気をつけてください。</p>
<p class="tx">残念ながら、Spotlightではユーザーがコマンドライン引数をPythonスクリプトに渡す手段がありません。コマンドライン引数は<i class="calibre5">.command</i>ファイルに予め書いておく必要があります。</p>
</section>
<section type="division" aria-labelledby="sec24">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1014" aria-label="278"></span>
<h4 class="h1"><span id="calibre_link-1750"></span><span id="calibre_link-301"></span><span class="sans_futura_std_heavy_oblique_bi_">Ubuntu Linux</span></h4>
<p class="tni">Windowsキーを押せばUbuntu LinuxのDashが立ち上がり、プログラム名を入力すれば実行できます。自分が書いたPythonスクリプトをDashに追加するには、以下の手順で進めます。

</p>
<p class="listnumberf">  1. <i class="calibre5">Scripts</i>フォルダに<i class="calibre5">yourScript.py</i>Pythonスクリプトを置く。</p>
<p class="listnumber">  2. 仮想環境を有効化してPythonスクリプトを実行する<i class="calibre5">yourScript</i>という名前のシェルスクリプトを作成する。</p>
<p class="listnumber">  3. <span class="thesansmonocd_w5regular_">chmod u+x yourScript</span>を実行して、そのシェルスクリプトに実行パーミッションを追加する。</p>
<p class="listnumberl">  4. <i class="calibre5">~/.local/share/applications</i>フォルダに<i class="calibre5">yourScript.desktop</i>ファイルを作成し、Dashからそのシェルスクリプトを実行できるようにする。</p>
<p class="tx"><i class="calibre5">/home/al/Scripts</i>のような<i class="calibre5">Scripts</i>フォルダに<i class="calibre5">.pyの</i>Pythonスクリプトを置いてから、<i class="calibre5">Scripts</i>フォルダに以下の内容の<i class="calibre5">yourScript</i>という名前のテキストファイル（拡張子なし）を作成します。</p>
<pre class="pre"><code class="calibre9">#!/usr/bin/env bash
source ~/Scripts/.venv/bin/activate
python3 ~/Scripts/yourScript.py
read -p "Press any key to continue..." -n1 –s
deactivate
</code></pre>
<p class="tx"><i class="calibre5">~</i>は<i class="calibre5">/home/al</i>のようなホームフォルダを表します。1行目はこのファイルがシェルスクリプトであることを示します。このファイルをファイル拡張子<i class="calibre5">.sh</i>にする必要はありません。</p>
<p class="tx">2行目は仮想環境を有効化し、3行目は仮想環境のPythonを使ってPythonスクリプトを実行します。<span class="thesansmonocd_w5regular_">read</span>コマンドでターミナルに<span class="thesansmonocd_w5regular_">Press any key to continue</span>と表示し、ユーザーが何らかのキーを押すのを待ちます。こうすることで、Pythonプログラムが終了するとターミナルウィンドウがすぐに閉じてしまって出力が見られなくなる事態を防ぎます。プログラムからの出力がなければ、この行を書かなくても大丈夫です。</p>
<p class="tx">このシェルスクリプトを作成してから、<span class="thesansmonocd_w5regular_">cd</span>で<i class="calibre5">~/Scripts</i>に移動し、<span class="thesansmonocd_w5regular_">chmod u+x yourScript</span>コマンドを実行します。これにより実行パーミッションが追加されます。ターミナルから<span class="thesansmonocd_w5regular_">yourScript</span>と入力すればPythonスクリプトを実行できるようになります。DashからPythonスクリプトを実行するには、<i class="calibre5">yourScript.desktop</i>ファイルを作成する必要があります。</p>
<p class="tx">Muやgeditなどのテキストエディタで以下の内容の<i class="calibre5">yourScript.desktop</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">[Desktop Entry]
Name=yourScript
Exec=gnome-terminal -- /home/al/Scripts/yourScript
Type=Application
</code></pre>
<p class="tx">このファイルを<i class="calibre5">/home/al/.local/share/applications</i>フォルダに（<i class="calibre5">al</i>の部分は自身のユーザー名に置き換えてください）<i class="calibre5">yourScript.desktop</i>という名前で保存します。（このファイルではホームフォルダを表す<span class="thesansmonocd_w5regular_">~</span>を使えないので、<span class="thesansmonocd_w5regular_">Exec</span>フィールドには<span class="thesansmonocd_w5regular_">/home/al</span>と書かなければなりません。）テキストエディタで<i class="calibre5">.local</i>フォルダが表示されなければ（ドットで始まるフォルダは隠しフォルダなので）、ファイル保存ダイアログで<small class="calibre4">CTRL</small>-Hを押して隠しファイルを表示してください。</p>
<p class="tx">Windowsキーを押してDashを立ち上げ、<i class="calibre5">yourScript</i>と入力してPythonスクリプトを素早く実行できるようになりました。Dashは完全な名前を自動補完してくれるはずです。<i class="calibre5">yourScript.desktop</i>の<span class="thesansmonocd_w5regular_">Name</span>フィールド中の<i class="calibre5">yourScript</i>というテキストがDashで表示されます。好きな名前にすることができますが、<i class="calibre5">yourScript.py</i>と同じ名前にしておくとわかりやすいでしょう。</p>
<p class="tx">次はこの章で学んだ原則を活用し、2つのプログラムを作成して使いやすくデプロイしてみましょう。</p>
</section>
</section>
<section type="division" aria-labelledby="sec25">
<h3 class="h"><span id="calibre_link-1751"></span><span id="calibre_link-302"></span><span class="sans_futura_std_bold_b_">短いプログラム：現在の作業ディレクトリをコピーする</span></h3>
<p class="tni">macOSとLinuxで<span class="thesansmonocd_w5regular_">pwd</span>コマンドを実行すると現在の作業ディレクトリが表示されますが、それをクリップボードにコピーして別の場所に貼り付けられれば便利なことがあります。例えば、私はWindowsでしょっちゅう現在の作業ディレクトリをターミナルからコピーして、ファイル保存ダイアログで貼り付けています。マウスでWindowsのプロンプトから現在の作業ディレクトリを選択してコピーすることもできますが（macOSとLinuxでは<span class="thesansmonocd_w5regular_">pwd</span>コマンドを実行して現在の作業ディレクトリを表示してそれをコピーすることもできますが）、この数ステップを1ステップにできるはずです。</p>
<p class="tx">私は<i class="calibre5">ccwd</i>（<i class="calibre5">copy current working directory</i>）という名前のプログラムを書こうと考えました。まず、Windowsで<span class="thesansmonocd_w5regular_">where ccwd</span>と入力し、macOSとLinuxで<span class="thesansmonocd_w5regular_">which ccwd</span>と入力して、さらに少しインターネットで調べて、<i class="calibre5">ccwd</i>という名前のコマンドが存在しないことを確認しました。<i class="calibre5">ccwd</i>は短くかつユニークな名前です。</p>
<p class="tx">ターミナルの現在の作業ディレクトリが<i class="calibre5">C:\Users\al\Scripts</i>であるときに<i class="calibre5">C:\Users\al</i>をクリップボードにコピーしたい、という場合に対応できる追加機能を作成したいです。<span class="thesansmonocd_w5regular_">cd ..</span>コマンドを実行してから<span class="thesansmonocd_w5regular_">ccwd</span>を実行し、<span class="thesansmonocd_w5regular_">cd Scripts</span>で<i class="calibre5">C:\Users\al\Scripts</i>に戻ることもできます。しかし<span class="thesansmonocd_w5regular_">ccwd</span>にコマンドライン引数として相対パスを渡せたほうが便利です。例えば、現在の作業ディレクトリが<i class="calibre5">C:\Users\al\Scripts</i>であるときに、<span class="thesansmonocd_w5regular_">ccwd ..</span>で<i class="calibre5">C:\Users\al</i>をクリップボードにコピーできるということです。このコマンドライン引数は必須ではありませんが（コマンドライン引数がなければデフォルトとして現在の作業ディレクトリをクリップボードにコピーします）、ユーザーが望めばこの機能を使えます。こうした小さい改良は些細なことのように思えるかもしれませんが、小さな改良が大きな効果をもたらします。だからECサイトでは「1クリックで購入」機能があります。</p>
<p class="tx">Pyperclipパッケージを利用してクリップボードを操作するので、<i class="calibre5">Scripts</i>フォルダの仮想環境にこのパッケージをインストールします。Muで新しいファイルを作成して以下のコードを入力してください。</p>
<pre class="pre"><code class="calibre9">import pyperclip, os, sys
if len(sys.argv) &gt; 1:
    os.chdir(sys.argv[1])
pyperclip.copy(os.getcwd())
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1015" aria-label="280"></span>このプログラムを<i class="calibre5">ccwd.py</i>という名前で、ホームフォルダ以下の<i class="calibre5">Scripts</i>フォルダの中に保存してください。</p>
<p class="tx">1行目ではこのプログラムに必要なモジュールをインポートしています。2行目ではこのプログラムにコマンドライン引数が渡されたかどうかをチェックしています。<span class="thesansmonocd_w5regular_">sys.argv</span>はスクリプト名の<span class="thesansmonocd_w5regular_">'ccwd.py'</span>という少なくとも一つの文字列を含んでいることを思い出してください。1つよりも多い（2つ以上の）文字列が含まれていれば、ユーザーがコマンドライン引数をプログラムに渡したのだとわかります。その場合は、3行目でプログラムの現在の作業ディレクトリを変更します。プログラムごとに現在の作業ディレクトリが設定されていますから、この設定を<span class="thesansmonocd_w5regular_">os.chdir()</span>で変更したとしても、このプログラムを実行したターミナルの現在の作業ディレクトリは変更されません。最後に、4行目で、現在の作業ディレクトリをクリップボードにコピーします。</p>
<p class="tx">プログラムを書き終えても、ターミナルから起動するのに<span class="thesansmonocd_w5regular_">python C:\Users\al\Scripts\ccwd.py</span>のようにフルパスを入力しなければなりません。これでは入力量が多く、スクリプトで素早く簡単に現在の作業ディレクトリをクリップボードにコピーしたいという目的を達成できません。この点を改善するために、このプログラムをデプロイする方法をOSごとに示します。</p>
<section type="division" aria-labelledby="sec26">
<h4 class="h1"><span id="calibre_link-1752"></span><span id="calibre_link-303"></span><span class="sans_futura_std_heavy_oblique_bi_">Windows</span></h4>
<p class="tni">Pythonファイルを<i class="calibre5">C:\Users\al\Scripts\ccwd.py</i>（<i class="calibre5">al</i>を自分のユーザー名に変更してください）に保存してください。同じ<i class="calibre5">Scripts</i>フォルダに以下の内容の<i class="calibre5">ccwd.bat</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">@call %HOMEDRIVE%%HOMEPATH%\Scripts\.venv\Scripts\activate.bat
@python %HOMEDRIVE%%HOMEPATH%\Scripts\ccwd.py %*
@deactivate
</code></pre>
<p class="tx">このバッチファイルには<span class="thesansmonocd_w5regular_">@pause</span>行はありません。<span class="thesansmonocd_w5regular_">print()</span>出力がないからです。これでどのフォルダにいてもこのプログラムをターミナルから<b class="calibre10">ccwd</b>で実行できるようになりました。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">ccwd</b>
C:\Users\al&gt;
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">'C:\Users\al'</span>がクリップボードにコピーされています。</p>
</section>
<section type="division" aria-labelledby="sec27">
<h4 class="h1"><span id="calibre_link-1753"></span><span id="calibre_link-304"></span><span class="sans_futura_std_heavy_oblique_bi_">macOS</span></h4>
<p class="tni">Pythonファイルを<i class="calibre5">/Users/al/Scripts/ccwd.py</i>（<i class="calibre5">al</i>を自分のユーザー名に変更してください）に保存してください。同じ<i class="calibre5">Scripts</i>フォルダに以下の内容の <i class="calibre5">ccwd.command</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">source ~/Scripts/.venv/bin/activate
python3 ~/Scripts/ccwd.py
deactivate
</code></pre>
<p class="tx">ターミナルから<span class="sans_thesansmonocd_w7bold_b_">cd</span>で<i class="calibre5">Scripts</i>フォルダに移動し、<span class="sans_thesansmonocd_w7bold_b_">chmod u+x ccwd.command</span>を実行します。</p>
<pre class="pre"><code class="calibre9">al@Als-MacBook-Pro ~ % <b class="calibre10">cd ~/Scripts</b>
al@Als-MacBook-Pro Scripts % <b class="calibre10">chmod u+x ccwd.command</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1016" aria-label="281"></span>これでどのフォルダにいてもこのプログラムをターミナルから<span class="sans_thesansmonocd_w7bold_b_">ccwd.command</span>で実行できるようになりました。</p>
<pre class="pre"><code class="calibre9">al@Als-MacBook-Pro ~ % <b class="calibre10">ccwd.command</b>
al@Als-MacBook-Pro ~ %
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">'/Users/al'</span>がクリップボードにコピーされています。</p>
</section>
<section type="division" aria-labelledby="sec28">
<h4 class="h1"><span id="calibre_link-1754"></span><span id="calibre_link-305"></span><span class="sans_futura_std_heavy_oblique_bi_">Ubuntu Linux</span></h4>
<p class="tni">Pythonファイルを<i class="calibre5">/home/al/Scripts/ccwd.py</i>（<i class="calibre5">al</i>を自分のユーザー名に変更してください）に保存してください。同じ<i class="calibre5">Scripts</i>フォルダに以下の内容の <i class="calibre5">ccwd</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">#!/usr/bin/env bash
source ~/Scripts/.venv/bin/activate
python3 ~/Scripts/ccwd.py
deactivate
</code></pre>
<p class="tx">この<i class="calibre5">ccwd</i>シェルスクリプトに<span class="thesansmonocd_w5regular_">read -p "Press any key to continue..." -n1 –s</span>の行は必要ありません。ターミナルからのみ実行して、Dashからは実行しないからです。ターミナルウィンドウはこのPythonスクリプトを実行後も消えません。</p>
<p class="tx">ターミナルから<span class="sans_thesansmonocd_w7bold_b_">cd</span>で<i class="calibre5">Scripts</i>フォルダに移動し、<span class="sans_thesansmonocd_w7bold_b_">chmod u+x ccwd</span>を実行します。</p>
<pre class="pre"><code class="calibre9">al@al-VirtualBox:~$ <b class="calibre10">cd ~/Scripts</b>
al@al-VirtualBox:~/Scripts$ <b class="calibre10">chmod u+x ccwd</b>
</code></pre>
<p class="tx">これでどのフォルダにいてもこのプログラムをターミナルから<span class="sans_thesansmonocd_w7bold_b_">ccwd</span>で実行できるようになりました。</p>
<pre class="pre"><code class="calibre9">al@al-VirtualBox:~$ <b class="calibre10">ccwd</b>
al@al-VirtualBox:~$
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">'/home/al'</span>がクリップボードにコピーされています。</p>
</section>
</section>
<section type="division" aria-labelledby="sec29">
<h3 class="h"><span id="calibre_link-1755"></span><span id="calibre_link-306"></span><span class="sans_futura_std_bold_b_">短いプログラム：クリップボードレコーダー</span></h3>
<p class="tni">あるウェブページ中のリンクURLをコピーしてスプレッドシートに貼り付ける作業をしているとしましょう。（<span>第13章</span>ではページのHTMLソースからすべてのリンクをスクレイピングする方法を説明しますが、ここではそのうちのいくつかのページだけが必要で、人間が一つずつ判断するという状況を想定します。）以下のステップでこの作業を行うでしょう。</p>
<p class="listnumberf">  1. ウェブブラウザでリンクを右クリックする。</p>
<p class="listnumber">  2. コンテキストメニューから「リンクのコピー」または「リンクアドレスのコピー」を選ぶ。</p>
<p class="listnumber">  3. スプレッドシートに切り替える。</p>
<p class="listnumber">  4. <small class="calibre4">CTRL</small>-Vを押してリンクを貼り付ける。</p>
<p class="listnumberl">  5. ウェブブラウザに切り替える。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1025" aria-label="282"></span>特にページに数十や数百のリンクがあれば、これは退屈な作業です。この作業を素早く行えるように、ちょっとしたクリップボードレコーダープログラムを作成しましょう。そのプログラムを自分が使っているコンピュータにデプロイし、必要なときに簡単に実行できるようにします。このプログラムは、新しいテキストがコピーされたかどうかクリップボードを監視して、コピーされたらその新しいテキストをターミナル画面に表示します。このようにして、5ステップの手順を2ステップに短縮できます。</p>
<p class="listnumberf">  1. ウェブブラウザでリンクを右クリックする。</p>
<p class="listnumberl">  2. コンテキストメニューから「リンクのコピー」または「リンクアドレスのコピー」を選ぶ。</p>
<p class="tx">それから、クリップボードレコーダーがターミナルウィンドウに出力したテキストをすべてコピーし、スプレッドシートに一度で貼り付けます。次のコードを<i class="calibre5">cliprec.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import pyperclip, time

print('Recording clipboard... (Ctrl-C to stop)')
previous_content = ''
try:
    while True:
        content = pyperclip.paste()  # クリップボードの内容を取得

        if content != previous_content:
            # 前の内容と異なれば出力
            print(content)
            previous_content = content

        time.sleep(0.01)  # CPUを専有してしまわないように停止
except KeyboardInterrupt:
    pass
</code></pre>
<p class="tx">冒頭からプログラムの各部を見ていきましょう。</p>
<pre class="pre"><code class="calibre9">import pyperclip, time

print('Recording clipboard... (Ctrl-C to stop)')
previous_content = ''
</code></pre>
<p class="tx">このプログラムは、クリップボードからテキストをコピーアンドペーストしますので、<span class="thesansmonocd_w5regular_">pyperclip</span>モジュールをインポートする必要があります。<span class="thesansmonocd_w5regular_">sleep()</span>関数を使うために<span class="thesansmonocd_w5regular_">time</span>モジュールもインポートします。プログラムが実行中であり、<small class="calibre4">CTRL</small>-Cで停止させられる旨のメッセージを表示します。変数<span class="thesansmonocd_w5regular_">previous_content</span>を追跡してクリップボードの内容の変化を検知します。最初は空文字列に設定します。</p>
<pre class="pre"><code class="calibre9">try:
    while True:
        content = pyperclip.paste()  # クリップボードの内容を取得
</code></pre>
<p class="tx">ブログラムの大部分は、<span class="thesansmonocd_w5regular_">try</span>ブロック内の<span class="thesansmonocd_w5regular_">while</span>無限ループです。ユーザーが<small class="calibre4">CTRL</small>-Cを押すと、<span class="thesansmonocd_w5regular_">KeyboardInterrupt</span>例外が送出され、プログラム実行はソースコードの下のほうの<span class="thesansmonocd_w5regular_">except</span>ブロックに移動します。</p>
<p class="tx">このループではクリップボードの内容を常時監視し、新しいテキストがコピーされるたびに記録します。ループ内ではまず<span class="thesansmonocd_w5regular_">pyperclip.paste()</span>を呼び出してクリップボードのテキストを取得します。</p>
<pre class="pre"><code class="calibre9">        if content != previous_content:
            # 前の内容と異なれば出力
            print(content)
            previous_content = content
</code></pre>
<p class="tx">クリップボードの現在の内容が前の内容と異なっていたら、現在の内容を出力し、<span class="thesansmonocd_w5regular_">previous_content</span>を<span class="thesansmonocd_w5regular_">content</span>に更新します。ループを反復して、次にユーザーが新しいテキストをクリップボードにコピーするのに備えます。</p>
<pre class="pre"><code class="calibre9">        time.sleep(0.01)  # CPUを専有してしまわないように停止</code></pre>
<p class="tx">クリップボードの内容が前の内容と同じなら、プログラムは何もしません。しかし、このプログラムはこのループを1秒で何万回もループしていまい、ユーザーがそんなに速くクリップボードを更新することはありそうにありません。（そんなに速くクリップボードを更新したらキーボードの<small class="calibre4">CTRL</small> キーとCキーがすり減ってしまいます。）無意味にループを高速で反復してこのプログラムがCPUを専有してしまわないように、ループがクリップボードの更新をチェックさせるのに0.01秒遅延させます。これなら1秒に100回の実行です。</p>
<pre class="pre"><code class="calibre9">except KeyboardInterrupt:
    pass
</code></pre>
<p class="tx">プログラムの最後の部分は<span class="thesansmonocd_w5regular_">except</span>節で、<span class="thesansmonocd_w5regular_">pass</span>文にしています。この文は何も行いませんが、Pythonでは<span class="thesansmonocd_w5regular_">except</span>文に続くブロックには1行以上が必要です。<span class="thesansmonocd_w5regular_">pass</span>文が存在するのはそのためです。ユーザーが<small class="calibre4">CTRL</small>-Cを押すと、プログラム実行はこの<span class="thesansmonocd_w5regular_">except</span>節に移動し、プログラムの最後まで進んで終了します。</p>
<p class="tx">このプログラムを実行すると、複数のアプリを行ったり来たりせずに複数の内容をコピーできます。これくらい小さいプログラムでも作業フローを随分簡単にできます。毎日行うような作業なら特に効果的です。このプログラムをデプロイする手順をOSごとに説明します。</p>
<section type="division" aria-labelledby="sec30">
<h4 class="h1"><span id="calibre_link-1756"></span><span id="calibre_link-307"></span><span class="sans_futura_std_heavy_oblique_bi_">Windows</span></h4>
<p class="tni">Pythonファイルを<i class="calibre5">C:\Users\al\Scripts\cliprec.py</i>（<i class="calibre5">al</i>を自分のユーザー名に変更してください）に保存してください。同じ<i class="calibre5">Scripts</i>フォルダに以下の内容の<i class="calibre5">cliprec.bat</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">@call %HOMEDRIVE%%HOMEPATH%\Scripts\.venv\Scripts\activate.bat
@python %HOMEDRIVE%%HOMEPATH%\Scripts\cliprec.py %*
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1024" aria-label="284"></span>@pause
@deactivate
</code></pre>
<p class="tx">これで、ターミナルから、あるいはWindowsキーとRキーを同時に押すと表示される実行ダイアログから、<span class="thesansmonocd_w5regular_">cliprec</span>と入力してこのプログラムを実行できるようになりました。</p>
</section>
<section type="division" aria-labelledby="sec31">
<h4 class="h1"><span id="calibre_link-1757"></span><span id="calibre_link-308"></span><span class="sans_futura_std_heavy_oblique_bi_">macOS</span></h4>
<p class="tni">Pythonファイルを<i class="calibre5">/Users/al/Scripts/cliprec.py</i>（<i class="calibre5">al</i>を自分のユーザー名に変更してください）に保存してください。同じ<i class="calibre5">Scripts</i>フォルダに以下の内容の <i class="calibre5">cliprec.command</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">source ~/Scripts/.venv/bin/activate
python3 ~/Scripts/cliprec.py
deactivate
</code></pre>
<p class="tx">ターミナルから<span class="sans_thesansmonocd_w7bold_b_">cd</span>で<i class="calibre5">Scripts</i>フォルダに移動し、<span class="sans_thesansmonocd_w7bold_b_">chmod u+x cliprec.command</span>を実行します。</p>
<pre class="pre"><code class="calibre9">al@Als-MacBook-Pro ~ % <b class="calibre10">cd ~/Scripts</b>
al@Als-MacBook-Pro Scripts % <b class="calibre10">chmod u+x cliprec.command</b>
</code></pre>
<p class="tx">これで<span class="dedication_italic">⌘</span>-スペースを押してSpotlightを立ち上げ、<span class="thesansmonocd_w5regular_">cliprec.command</span>と入力してこのプログラムを実行できるようになりました。</p>
</section>
<section type="division" aria-labelledby="sec32">
<h4 class="h1"><span id="calibre_link-1758"></span><span id="calibre_link-309"></span><span class="sans_futura_std_heavy_oblique_bi_">Ubuntu Linux</span></h4>
<p class="tni">Pythonファイルを<i class="calibre5">/home/al/Scripts/cliprec.py</i>（<i class="calibre5">al</i>を自分のユーザー名に変更してください）に保存してください。同じ<i class="calibre5">Scripts</i>フォルダに以下の内容の  <i class="calibre5">cliprec</i>ファイルを作成します。</p>
<pre class="pre"><code class="calibre9">#!/usr/bin/env bash
source ~/Scripts/.venv/bin/activate
python3 ~/Scripts/cliprec.py
read -p "Press any key to continue..." -n1 –s
deactivate
</code></pre>
<p class="tx">ターミナルから<span class="sans_thesansmonocd_w7bold_b_">cd</span>で<i class="calibre5">Scripts</i>フォルダに移動し、<span class="sans_thesansmonocd_w7bold_b_">chmod u+x cliprec</span>を実行します。</p>
<pre class="pre"><code class="calibre9">al@al-VirtualBox:~$ <b class="calibre10">cd ~/Scripts</b>
al@al-VirtualBox:~/Scripts$ <b class="calibre10">chmod u+x cliprec</b>
</code></pre>
<p class="tx">最後に、以下の内容の<i class="calibre5">~/.local/share/applications/cliprec.desktop</i>ファイルを作成して保存します。</p>
<pre class="pre"><code class="calibre9">[Desktop Entry]
Name=Clipboard Recorder
Exec=gnome-terminal -- /home/al/cliprec
Type=Application
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-737" aria-label="285"></span>これで、Windowsキーを押してDashを立ち上げて、<span class="thesansmonocd_w5regular_">Clipboard Recorder</span>と入力するか最初の数文字を入力して自動補完で選ぶかすれば、このプログラムを実行できるようになりました。</p>
</section>
</section>
<section type="division" aria-labelledby="sec33">
<h3 class="h"><span id="calibre_link-1759"></span><span id="calibre_link-310"></span><span class="sans_futura_std_bold_b_">PyInstallerでPythonプログラムをコンパイルする</span></h3>
<p class="tni">Pythonはインタープリタ型の言語であるとしばしば言われますが、プログラミング言語自体はインタープリタ型でもコンパイル型でもありません。どの言語でもインタープリタまたはコンパイラを作ることができます。Pythonで書かれたプログラムはたいていインタープリタによって<i class="calibre5">実行</i>されます。それでも、PyInstallerパッケージで、Pythonのコードから、コマンドラインから実行できる実行ファイルを作成することもできます。</p>
<p class="tx">PyInstallerはPythonプログラムをマシンコード（機械語）そのものにコンパイルするわけではありません。Pythonインタープリタとコードのコピーを含む実行ファイルを作成します。そのため、プログラムのサイズは大きくなってしまいがちです。単純な“Hello, world”プログラムでもPyInstallerでコンパイルすると約8MBのサイズになります。アセンブリ言語で書いたときよりも千倍ほど大きいサイズです。しかしながら、Pythonプログラムをコンパイルすると、Pythonをインストールしていない人と共有できるという利点があります。一つの実行ファイルを共有するだけです。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">pip install pyinstaller</span>を実行するとPyInstallerをインストールできます。実行したいOSでPyInstallerを実行する必要があります。つまり、WindowsでPyInstallerを実行したらWindowsの実行ファイルが作成され、macOSやLinuxでは実行できません。macOSやLinuxで実行した場合も、同様にそのOSでの実行ファイルが作成されます。</p>
<p class="tx">ターミナルから次のコマンドを実行して（macOSとLinuxでは<span class="thesansmonocd_w5regular_">python</span>を<span class="thesansmonocd_w5regular_">python3</span>にしてください）、<i class="calibre5">yourScript.py</i>という名前のPythonスクリプトをコンパイルしてください。</p>
<pre class="pre"><code class="calibre9">C:\Users\al&gt;<b class="calibre10">python -m PyInstaller --onefile yourScript.py</b>
378 INFO: PyInstaller: <var class="calibre20">X</var>.<var class="calibre20">X</var>.<var class="calibre20">X</var>
378 INFO: Python: 3.<var class="calibre20">XX</var>.<var class="calibre20">XX</var>
392 INFO: Platform: Windows-<var class="calibre20">XX</var>-<var class="calibre20">XX</var>.<var class="calibre20">X</var>.<var class="calibre20">XXXX</var>
393 INFO: wrote C:\Users\al\Desktop\hello-test\hello.spec
399 INFO: UPX is not available.
<var class="calibre20">--snip--</var>
11940 INFO: Appending PKG archive to EXE
11950 INFO: Fixing EXE headers
13622 INFO: Building EXE from EXE-00.toc completed successfully.
</code></pre>
<p class="tx"><i class="calibre5">PyInstaller</i>は<i class="calibre5">P</i>と<i class="calibre5">I</i>が大文字です。大文字と小文字を間違えると“No module named pyinstaller”エラーメッセージが表示されます。また、<span class="thesansmonocd_w5regular_">--onefile</span>引数はダッシュが2つです。</p>
<p class="tx">PyInstallerを実行すると、<i class="calibre5">build</i>フォルダ（削除しても構いません）と<i class="calibre5">dist</i>フォルダが作成されます。<i class="calibre5">dist</i>フォルダの中に実行プログラムが入っています。そのための仮想環境を作成する必要はありません。このプログラムを他のコンピュータにコピーしたりメールに添付したりできます。もっとも、セキュリティ上の理由から、多くのメールプロバイダでは実行プログラムを含むメールはブロックされる可能性があります。</p>
<p class="tx">基本的なPythonプログラムであればこの方法で実行ファイルを作成できます。詳細は<i class="calibre5"><a href="https://pyinstaller.org" class="calibre1">https://<wbr></wbr>pyinstaller<wbr></wbr>.org</a></i>のオンラインドキュメントで説明されています。</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec34">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1760" aria-label="286"></span>
<h3 class="h"><span id="calibre_link-1761"></span><span id="calibre_link-311"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">本章では、プログラムを素早く便利に実行できるように、コードエディタの世界から抜け出して、プログラムをデプロイする方法を説明しました。現代的なグラフィックスを備えないテキストベースユーザーインターフェイスを持つプログラムを設計する方法も説明しました。GUIはユーザーにとって使いやすいですが、TUIはコードがシンプルです。自分の作業を自動化する場合、プロが作ったアプリケーションのような見た目にする必要はなく、そこに労力をかける価値はありません。動作すればよいのです。</p>
<p class="tx">とはいえ、プログラムを使いやすくする設計がいくつか考えられます。馴染みのない人が多いでしょうが、コマンドラインターミナルを使うと便利なことが多いです。<span class="thesansmonocd_w5regular_">cd</span>や<span class="thesansmonocd_w5regular_">dir</span>/<span class="thesansmonocd_w5regular_">ls</span>でのファイルシステムの移動と確認、<span class="thesansmonocd_w5regular_">PATH</span>環境変数、コマンドライン引数など、コマンドラインの概念に馴染むにはしばらく時間がかかります。しかし、ターミナルからだとコマンドを素早く発行してプログラムを実行できます。特にプログラムを書き終えてデプロイしたら素早くプログラムを実行できます。</p>
<p class="tx">本章ではサードパーティーパッケージをいくつか取り上げました。Bextパッケージを使うと、テキストに色をつけたり、カーソルの位置を指定したり、画面をクリアしたりできます。PyMsgBoxパッケージを使うと、ターミナルウィンドウではない、アラートや基本的な入力のためのGUIボックスを作れます。同じパッケージで互換性のない複数のバージョンを使わなければならない日がいつか来るので、別々の仮想環境でスクリプトを実行するのが望ましいです。Pythonに付属している<span class="thesansmonocd_w5regular_">venv</span>モジュールで仮想環境を作成できます。仮想環境はターミナルから有効化し、パッケージをインストールする場所を分けられるので、既存のプログラムを壊してしまう心配から解放されます。</p>
<p class="tx">最後に、自分が書いた<i class="calibre5">.py</i>ファイルを、PyInstallerパッケージで実行プログラムにコンパイルする方法を説明しました。数メガバイトのサイズになりますが、Python（とプログラムで利用しているサードパーティーパッケージ）を持っていない人ともプログラムを共有できます。</p>
<p class="tx">本章ではプログラミング言語の概念を説明したわけではなく、プログラムを日常的に使いやすくて便利にする方法を説明しました。本書のここまでの部分で、基本的なプログラムを作成するのに十分なPythonの構文を学びました（まだまだ学ぶことはありますが）。次章から、サードパーティーのパッケージを使って、プログラムができることを拡張していきます。</p>
</section>
<section type="division" aria-labelledby="sec35">
<h3 class="h"><span id="calibre_link-1762"></span><span id="calibre_link-312"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. フォルダの中身を一覧表示するコマンドは、Windowsでは何ですか？　macOSとLinuxでは何ですか？</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">PATH</span>環境変数には何が入っていますか？</p>
<p class="listnumber">  3. 変数<span class="thesansmonocd_w5regular_">__file__</span>には何が格納されていますか？</p>
<p class="listnumber">  4. ターミナルウィンドウのテキストを消すコマンドは、Windowsでは何ですか？　macOSとLinuxでは何ですか？</p>
<p class="listnumber">  5. 新しい仮想環境をどうやって作成しますか？</p>
<p class="listnumber">  6. プログラムをコンパイルする際にPyInstallerに渡すコマンドライン引数は何ですか？</p>
</section>
<section type="division" aria-labelledby="sec36">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1763" aria-label="287"></span>
<h3 class="h"><span id="calibre_link-1764"></span><span id="calibre_link-313"></span><span class="sans_futura_std_bold_b_">練習プログラム：自分が書いたプログラムのデプロイ</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">PATH</span>フォルダ内にシェルスクリプトを作成して、あるいはPyInstallerでコンパイルして、既存のプログラムを実行しやすくしてください。以下のプロジェクトが対象になります。</p>
<ul class="ul">
<li class="bl"><span>第11章</span>の「フォルダをZIPファイルにバックアップする」</li>
<li class="bl"><span>第9章</span>の「長い文書から連絡先情報を抽出する」</li>
<li class="bl"><span>第8章</span>の「ウィキマークアップに箇条書き記号を追加する」</li>
<li class="bl"><span>第7章</span>の「対話的なチェス盤シミュレーター」</li>
<li class="bl">簡単に起動できるようにしたいその他のプログラム</li>
</ul>
</section>
</section>
</div>


</div>



</body></html>