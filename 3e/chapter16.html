<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-430">
<section type="chapter" role="doc-chapter" aria-labelledby="ch16">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1088" aria-label="383"></span>
<hgroup>
<h2 class="title" id="calibre_link-1890">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">16</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">SQLiteデータベース</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">読者のみなさんはExcelやGoogleスプレッドシートに情報をまとめることに慣れていると思いますが、多くのソフトウェアではデータを<i class="calibre18">データベース</i>と呼ばれるアプリケーションに保存しています。データベースを利用するとほしいデータを取得しやすくなります。ネコの情報をスプレッドシートやテキストファイルに保存していたとすると、Zophieという名前のネコの毛色を調べたいときに、<small class="calibre19">CTRL</small>-Fを押して「Zophie」と入力すると思います。しかし、体重が3キログラムから5キログラムの間で2023年10月以前に生まれたすべてのネコの毛色を知りたいとしたらどうでしょうか。<span class="chapterintro_xref">第9章</span>で説明した正規表現を使っても難しいコードになるでしょう。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1090" aria-label="384"></span>データベースでは、<i class="calibre5">SQL（Structured Query Language）</i>というミニ言語で、こうした複雑なクエリを実行できます。<i class="calibre5">SQL</i>という用語はデータベースを操作する言語とその言語を受け入れるデータベースの両方を指します。「エスキューエル」と発音されることが多いですが、「シークェル」と発音されることもあります。本章ではSQLとデータベースの概念を<i class="calibre5">SQLite</i>（「シークェライト」、「エスキューライト」、「エスキューエルライト」と発音されます）を使って説明します。SQLiteはPythonに同梱されている軽量データベースです。</p>
<p class="tx">SQLiteは最も広く展開されているデータベースソフトウェアです。どのOSでも動きますし、別のアプリケーションに埋め込めるほど小さいです。他方で、SQLiteはシンプルであるため、他のデータベースとは顕著に異なります。PostgreSQL、MySQL、Microsoft SQL Server、Oracleなどの大規模なデータベースソフトウェアは、ネットワークを介してアクセスされる専用のハードウェアのサーバーで実行されることが想定されていますが、SQLiteはデータベース全体をコンピュータ上の一つのファイルに保存します。</p>
<p class="tx">SQLデータベースに慣れている人でも、SQLiteはクセがありますから、本章の説明を読んでください。SQLiteのオンラインドキュメントは<i class="calibre5"><a href="https://sqlite.org/docs.html" class="calibre1">https://<wbr></wbr>sqlite<wbr></wbr>.org<wbr></wbr>/docs<wbr></wbr>.html</a></i>にありますし、Pythonの<span class="thesansmonocd_w5regular_">sqlite3</span>モジュールのドキュメントは<i class="calibre5"><a href="https://docs.python.org/3/library/sqlite3.html" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/sqlite3<wbr></wbr>.html</a></i>にあります。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1891"><span id="calibre_link-431"></span><span class="sans_futura_std_bold_b_">スプレッドシートとデータベース</span></h3>
<p class="tni">スプレッドシートとデータベースの異同を検討しましょう。スプレッドシートでは、各行がそれぞれのレコードであり、各列がそれぞれのレコードのフィールドに保存されたデータの種類を表します。例えば、図16-1は私のネコのスプレッドシートです。列は名前、生年月日、毛色、体重（キログラム）です。</p>
<figure class="img"><img class="img2" id="calibre_link-777" src="images/000033.jpg" alt="An Excel spreadsheet containing the columns “Name”, “Birthdate”, “Fur”, and “Weight kg.” The rows are populated with information about cats." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 16-1：スプレッドシートはデータレコードを定められた列構造の行に保存する</span></p></figcaption>
</figure>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1087" aria-label="385"></span>この同じ情報をデータベースに保存できます。データベースに含まれる<i class="calibre5">テーブル</i>をスプレッドシートになぞらえることができます。テーブルにはそれぞれの<i class="calibre5">レコード</i>（<i class="calibre5">行</i>や<i class="calibre5">エントリー</i>と呼ばれることもあります）の特性に応じたカラム（列）があります。SQLiteのようなデータベースは<i class="calibre5">リレーショナルデータベース</i>と呼ばれます。<i class="calibre5">リレーション（関係）</i>というのは、データベースに含まれる複数のテーブル間の関係のことです（後述します）。</p>
<p class="tx">スプレッドシートもデータベースも、保存しているデータにラベルをつけます。スプレッドシートは、列にはアルファベット、行には数字のラベルを自動的につけます。さらに、先ほどの例のネコのスプレッドシートでは、最初の行が列を説明する名前になっています。2行目以下は一つの行が一匹のネコを表しています。SQLデータベースでは、各テーブルにたいていIDカラムがあります。IDカラムはレコードの<i class="calibre5">主キー</i>で、レコードを明確に特定できる一意の整数です。SQLiteでは、このカラムが<span class="thesansmonocd_w5regular_">rowid</span>と呼ばれ、自動的にテーブルに追加されます。</p>
<p class="tx">スプレッドシートの行を削除するとその下の行が繰り上がり、行番号が変わります。しかしデータベースのレコードの主キーIDは一意であって変更されません。この特性は多くの状況で役立ちます。ネコの名前が変わったり体重の増減があったりした場合にどうなるでしょうか。名前のアルファベット順に行を並べ替えたい場合はどうすればよいでしょうか。ネコには、データが変わっても一定である固有のID番号が必要です。SQLiteのテーブルの<span class="thesansmonocd_w5regular_">rowid</span>カラムに相当するようなID列をスプレッドシートに設けることも可能です。行が削除されたり移動されたりしても、このID値は同じままです。それを図16-2に示しました。Row IDが5から10の行を削除しました。</p>
<figure class="img"><img class="img1" id="calibre_link-778" src="images/000034.jpg" alt="Two versions of an Excel spreadsheet with the columns “Row ID”, “Name”, “Birthdate”, “Fur”, and “Weight kg”. The “Row ID” column contains sequential ID numbers. In the second version of the spreadsheet, the rows with the IDs 5 through 10 have been deleted, and the column jumps straight from the row with the ID value of 4 to the row with the ID value of 11." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 16-2：Row ID番号は、スプレッドシートの行番号とは異なり、IDが5から10のネコを削除した後でも（右側）、それぞれのレコードを一意に識別する（左側）</span></p></figcaption>
</figure>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1205" aria-label="386"></span>スプレッドシートは、データベースとは全く異なるやり方で使われることもあります。行ベースのデータを保存するのではなく、テンプレートとして使われることがあります。図16-3のようなスプレッドシートを目にしたことがあるでしょう。</p>
<figure class="img"><img class="img1" id="calibre_link-779" src="images/000035.jpg" alt="An Excel spreadsheet with the text “Time Slot Assignments for Site B Laboratory” in Row 1, the values “Time”, “Staff #1”, “Staff #2”, “Staff #3”, and “Staff #4” in row two, various time slots in the remaining column A cells, and various names in the remaining B through E cells. Column C also includes days of the week." />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 16-3：フォーマットされてサイズが固定されたスプレッドシートはデータベースではない</span></p></figcaption>
</figure>
<p class="tx">このようなスプレッドシートは、背景色、セル結合、フォントなどのフォーマットを多用しており、人間の目には見やすいです。行ベースのデータのスプレッドシートは無限に下へと新しいデータを追加できるのに対し、こうしたスプレッドシートはサイズが固定されていて空欄を埋めていく方式のデザインになっています。Pythonプログラムがデータを抽出することではなく、人間が印刷して眺めることが意図されています。</p>
<p class="tx">データベースは見た目のためのものではなく、生のデータを保存します。さらに重要なこととして、スプレッドシートはどのセルにどのようなデータでも入れられる柔軟性がありますが、データベースにはソフトウェアがデータを取得しやすくするための厳格な構造があります。上に示した例のようにデータがフォーマットされていたら、<span>第14章<span>のopenpyxlライブラリや<span>第15章</span>のEZSheetsライブラリを使って、ExcelやGoogleスプレッドシートのまま処理したほうがよいでしょう。</p>
</section>
<section type="division" aria-labelledby="sec2">
<h3 class="h" id="calibre_link-1892"><span id="calibre_link-432"></span><span class="sans_futura_std_bold_b_">SQLiteと他のSQLデータベース</span></h3>
<p class="tni">他のSQLデータベースに慣れている人は、SQLiteがそれとどう違うのか気になるところでしょう。端的に言うと、SQLiteは単純さと強力さのバランスを保っています。SQLで大量のデータを読み書きする完全なリレーショナルデータベースでありながら、Pythonプログラム内で実行され一つのファイルで操作が完結します。<span class="thesansmonocd_w5regular_">sys</span>、<span class="thesansmonocd_w5regular_">math</span>その他のPython標準ライブラリと同じように<span class="thesansmonocd_w5regular_">sqlite3</span>モジュールをインポートします。</p>
<p class="tx">SQLiteと他のデータベースソフトウェアとの主な違いを列挙します。</p>
<ul class="ul">
<li class="bl">SQLiteは一つのファイルにデータを保存するので、移動、コピー、バックアップなどが簡単</li>
<li class="bl">SQLiteは、組み込みデバイスや数十年前のノートパソコンなど、リソースが乏しいコンピュータでも実行できる</li>
<li class="bl">SQLiteはサーバーレスであるため、バックグラウンドのサーバーアプリケーションが不要であり、ネットワーク通信も不要</li>
<li class="bl">ユーザー目線では、SQLiteはPythonプログラムの一部であり、インストールと設定が不要</li>
<li class="bl">速度パフォーマンスの観点からは、SQLiteはメモリ内で動作してプログラムの終了前にファイルに書き出すことができる</li>
<li class="bl">他のSQLデータベースと同様に、カラムには数値型やテキスト型などのデータ型があるが、SQLiteはカラムのデータ型を厳密に強制はしない</li>
<li class="bl">パーミッション（権限）その他のユーザーロールの設定が不要であり、他のSQLデータベースにあるような<span class="thesansmonocd_w5regular_">GRANT</span>文や<span class="thesansmonocd_w5regular_">REVOKE</span>文は存在しない</li>
<li class="bl">SQLiteはパブリックドメインのソフトウェアであり、商用利用でもどのような利用でも制限なしにできる</li>
</ul>
<p class="tx">SQLiteの大きな弱点は、（ソーシャルメディアのウェブアプリで行われるような）数十万の同時書き込み操作を効率的に扱えないことです。その点を除けば、SQLiteは他のデータベースと同じくらい強力で、GBやTB単位のデータを確実に処理でき、同時読み取りを高速で簡単に行えます。</p>
<p class="tx">SQLiteは、他のデータベースよりも、テキストファイル（や<span>第18章</span>で取り上げるJSON、XML、CSVファイル）を<span class="thesansmonocd_w5regular_">open()</span>関数を使って操作することに近いです。大量のデータを保存して素早く検索する必要があるなら、SQLiteがJSONやスプレッドシートファイルよりも優れた方法になります。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h3 class="h" id="calibre_link-1893"><span id="calibre_link-433"></span><span class="sans_futura_std_bold_b_">データベースとテーブルの作成</span></h3>
<p class="tni">最初のデータベースとテーブルをSQLを使って作成してみましょう。SQLは、正規表現のように、Python内で使えるミニ言語です。正規表現と同様に、SQLクエリはPythonの文字列値として書けます。正規表現を使わずにそれと同等のテキストのパターンマッチングを行うPythonのコードを書けるのと同じように、SQLクエリを使わずにPythonの辞書やリストのデータを検索するPythonのコードを書くことは確かにできます。しかし正規表現やSQLデータベースクエリを書くと、最初は新しい技術の学習を求められますが、長期的にはそうした作業がずっとシンプルになります。新しいデータベースでテーブルを作成するクエリの書き方から始めましょう。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1048" aria-label="388"></span>ネコについての情報を保存する<i class="calibre5">example.db</i>という名前のファイルでサンプルのSQLiteデータベースを作成します。データベースを作成するには、まず<span class="thesansmonocd_w5regular_">sqlite3</span>モジュールをインポートします（<i class="calibre5">3</i>はSQLiteのメジャーバージョンの3で、Python3とは関係ありません）。SQLiteデータベースは一つのファイルで完結します。ファイル名は何でもいいですが、慣習的に<i class="calibre5">.db</i>というファイル拡張子にします。<i class="calibre5">.sqlite</i>という拡張子も一般的に用いられます。</p>
<p class="tx">データベースは複数のテーブルを持ち、各テーブルは一定の型のデータを保存します。例えば、あるテーブルにネコのレコードを保存し、別のテーブルに最初のテーブルのネコのワクチン接種レコードを保存します。テーブルはタプルのリストで、それぞれのタプルがテーブルの行だと考えることができます。<span class="thesansmonocd_w5regular_">cats</span>テーブルは本質的には<span class="thesansmonocd_w5regular_">[('Zophie', '2021-01-24', 'black', 5.6), ('Colin', '2016-12-24', 'siamese', 6.2), ...]</span>というタプルのリストと同じです。</p>
<p class="tx">データベースを作成して、ネコのデータを保存するテーブルを作成し、何匹かのネコのレコードを挿入して、データベースからそのデータを読み取り、データベース接続を閉じてみましょう。</p>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1894"><span id="calibre_link-434"></span><span class="sans_futura_std_heavy_oblique_bi_">データベースに接続する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">sqlite3.connect()</span>を呼び出してデータベースの<span class="thesansmonocd_w5regular_">Connection</span>オブジェクトを取得するのがSQLiteのコードを書く第一歩です。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('example.db', isolation_level=None)</b>
</code></pre>
<p class="tx">この関数の第一引数は、データベースファイルのファイル名の文字列か<span class="thesansmonocd_w5regular_">pathlib.Path</span>オブジェクトのいずれかです。指定されたファイルが存在しなければ、新しい空白のデータベースを作成します。例えば、<span class="thesansmonocd_w5regular_">sqlite3.connect('example.db', isolation_level=None)</span>は、現在の作業ディレクトリにある<i class="calibre5">example.db</i>という名前のファイルのデータベースに接続します。そのファイルが存在しなければ、空白のデータベースファイルを作成します。</p>
<p class="tx">存在はするけれどもSQLiteデータベースファイルではないファイルを指定した場合は、クエリを実行しようとしたときに<span class="thesansmonocd_w5regular_">sqlite3.DatabaseError: file is not a database</span>例外が送出されます。<span>第10章の「有効なパスかどうかをチェックする」</span>で、ファイルが存在するかどうかを判定するのに使える、Pathメソッドの<span class="thesansmonocd_w5regular_">exists()</span>と、<span class="thesansmonocd_w5regular_">os.path.exists()</span>関数を説明しています。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">isolation_level=None</span>キーワード引数を指定すると、データベースが自動コミットモードになります。<span class="thesansmonocd_w5regular_">execute()</span>メソッド呼び出し後に<span class="thesansmonocd_w5regular_">commit()</span>メソッドを呼び出さなくてもすむようになります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">sqlite3.connect()</span>関数は<span class="thesansmonocd_w5regular_">Connection</span>オブジェクトを返します。先の例ではそのオブジェクトを<span class="thesansmonocd_w5regular_">conn</span>という名前の変数に格納しました。それぞれの<span class="thesansmonocd_w5regular_">Connection</span>オブジェクトは一つのSQLiteデータベースファイルに接続します。もちろん、この<span class="thesansmonocd_w5regular_">Connection</span>オブジェクトを格納する変数名は何でもよいのですが、複数のデータベースに同時に接続する場合は、わかりやすい変数名にしたほうがよいです。とはいえ、同時に一つのデータベースにしか接続しない小さなプログラムでは、<span class="thesansmonocd_w5regular_">conn</span>という名前が書きやすくて十分にわかりやすいです。（<span class="thesansmonocd_w5regular_">con</span>はもっと短いですが、“<i class="calibre5">con</i>sole”、“<i class="calibre5">con</i>tent”、“<i class="calibre5">con</i>fusing name for a variable”などと誤解しやすいです。）</p>
<p class="tx">プログラムでデータベースの処理を終えたら、<span class="thesansmonocd_w5regular_">conn.close()</span>を呼び出して接続を閉じます。プログラムが終了したらデータベース接続は自動的に閉じられます。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1895"><span id="calibre_link-435"></span><span class="sans_futura_std_heavy_oblique_bi_">テーブルを作成する</span></h4>
<p class="tni">新しい空白のデータベースに接続したら、<span class="thesansmonocd_w5regular_">CREATE TABLE</span>というSQLクエリでテーブルを作成します。SQLクエリを実行するには、<span class="thesansmonocd_w5regular_">Connection</span>オブジェクトの<span class="thesansmonocd_w5regular_">execute()</span>メソッドを呼び出します。<span class="thesansmonocd_w5regular_">conn.execute()</span>メソッドにクエリの文字列を渡します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('example.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('CREATE TABLE IF NOT EXISTS cats (name TEXT NOT NULL,</b>
<b class="calibre10">birthdate TEXT, fur TEXT, weight_kg REAL) STRICT')</b>
&lt;sqlite3.Cursor object at 0x00000201B2399540&gt;
</code></pre>
<p class="tx">慣習的に、<span class="thesansmonocd_w5regular_">CREATE</span>や<span class="thesansmonocd_w5regular_">TABLE</span>のようなSQLのキーワードは、大文字で書きます。SQLiteは大文字で書くことを強制せず、<span class="thesansmonocd_w5regular_">'create table if not exists cats (name text not null, birthdate text, fur text, weight_kg real) strict'</span>というクエリでも正常に実行されます。テーブル名とカラム名も大文字と小文字を区別しませんが、<span class="thesansmonocd_w5regular_">weight_kg</span>のように小文字にして単語の間はアンダースコアでつなぐのが慣習です。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">IF NOT EXISTS</span>をつけずに<span class="thesansmonocd_w5regular_">CREATE TABLE</span>文を実行したら、すでにその名前のテーブルが存在する場合に<span class="thesansmonocd_w5regular_">sqlite3.OperationalError: table cats already exists</span>例外が送出されます。<span class="thesansmonocd_w5regular_">IF NOT EXISTS</span>をつけるとこの例外に悩まされずにすみますので、<span class="thesansmonocd_w5regular_">CREATE TABLE</span>クエリには常にこれをつけることになるでしょう。</p>
<p class="tx">先の例では、<span class="thesansmonocd_w5regular_">CREATE TABLE IF NOT EXISTS</span>のあとにテーブル名の<span class="thesansmonocd_w5regular_">cats</span>を続けました。テーブル名のあとは丸かっこ内に一連のカラム名とデータ型を書きました。</p>
</section>
<section type="division" aria-labelledby="sec6">
<h4 class="h1" id="calibre_link-1896"><span id="calibre_link-436"></span><span class="sans_futura_std_heavy_oblique_bi_">データ型の定義</span></h4>
<p class="tni">SQLiteには6つのデータ型があります。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">NULL </span> Pythonの<span class="thesansmonocd_w5regular_">None</span>に対応</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">INT</span> <b class="calibre10">または</b> <span class="sans_thesansmonocd_w7bold_b_">INTEGER</span> Pythonの<span class="thesansmonocd_w5regular_">int</span>型に対応</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">REAL </span>数学用語の<i class="calibre5">実数</i>を表し、Pythonの<span class="thesansmonocd_w5regular_">float</span>型に対応</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">TEXT </span>Pythonの<span class="thesansmonocd_w5regular_">str</span>型に対応</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">BLOB </span><i class="calibre5">Binary Large Object</i>の略で、Pythonの<span class="thesansmonocd_w5regular_">bytes</span>型に対応し、ファイル全体をデータベースに保存するときに使う</p>
<p class="tni">SQLiteは、Pythonのためだけに作られたものではないので、独自のデータ型があります。他のプログラミング言語からもSQLiteを使えます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1165" aria-label="390"></span>他のSQLデータベースソフトウェアとは異なり、SQLiteはカラムのデータ型について厳密ではありません。SQLiteは、デフォルトで、<span class="thesansmonocd_w5regular_">INTEGER</span>型のカラムに文字列<span class="thesansmonocd_w5regular_">'Hello'</span>を保存しても例外が送出されません。他方で、SQLiteのデータ型は全く意味がないかといえばそうでもなく、カラムのデータ型に応じて可能な場合にはデータが自動的に<i class="calibre5">キャスト</i>（変更）されます。この機能は<i class="calibre5">型親和性</i>と呼ばれます。例えば、文字列の<span class="thesansmonocd_w5regular_">'42'</span>を<span class="thesansmonocd_w5regular_">INTEGER</span>型のカラムに追加したとすると、このカラムには整数型に親和性があるので、SQLiteは自動的に整数の<span class="thesansmonocd_w5regular_">42</span>を値として保存します。しかし、<span class="thesansmonocd_w5regular_">INTEGER</span>型のカラムに文字列<span class="thesansmonocd_w5regular_">'Hello'</span>を追加したとすると、整数型に親和性があるといっても<span class="thesansmonocd_w5regular_">'Hello'</span>は整数に変換できないので、SQLiteは<span class="thesansmonocd_w5regular_">'Hello'</span>を保存します（エラーは発生しません）。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">STRICT</span>キーワードでそのテーブルについて<i class="calibre5">厳格モード</i>を有効にできます。厳格モードでは、各カラムにデータ型を設定して、間違った型のデータをテーブルに挿入しようとしたら<span class="thesansmonocd_w5regular_">sqlite3.IntegrityError</span>例外が送出されるようになります。SQLiteはカラムのデータ型に応じてデータを自動的にキャストします。<span class="thesansmonocd_w5regular_">'42'</span>を<span class="thesansmonocd_w5regular_">INTEGER</span>型のカラムに入れようとしたら整数の<span class="thesansmonocd_w5regular_">42</span>が挿入されます。しかし、文字列の<span class="thesansmonocd_w5regular_">'Hello'</span>は整数にキャストできないので、これを挿入しようとすると例外が送出されます。厳格モードを使うことを強くおすすめします。そうすれば不適切なデータをテーブルに挿入するというバグがあったときに早い段階で警告を発してくれます。</p>
<p class="tx">SQLiteは<span class="thesansmonocd_w5regular_">STRICT</span>キーワードをバージョン3.37.0で追加しました。これはPython 3.11以降で使われています。それ以前のバージョンでは厳格モードがなく、厳格モードにしようとすると構文エラーになります。Pythonが使っているSQLiteのバージョンは、以下のように、<span class="thesansmonocd_w5regular_">sqlite3.sqlite _version</span>変数で確かめられます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">sqlite3.sqlite_version</b>
'3.<var class="calibre20">xx</var>.<var class="calibre20">xx</var>'
</code></pre>
<p class="tx">SQLiteにはブール型はありませんので、ブール値には<span class="thesansmonocd_w5regular_">INTEGER</span>型を用いてください。<span class="thesansmonocd_w5regular_">True</span>の場合は<span class="thesansmonocd_w5regular_">1</span>を、<span class="thesansmonocd_w5regular_">False</span>の場合は<span class="thesansmonocd_w5regular_">0</span>を保存します。SQLiteには日付型や時間型や日時型もありませんので、表16-1に示していますように、<span class="thesansmonocd_w5regular_">TEXT</span>型で文字列を保存します。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-780"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 16-1：</span></span><span class="sans_futura_std_book_">SQLiteで日付、時間、日時を表すのに推奨される形式</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">形式</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">例</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">YYYY-MM-DD</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">'2035-10-31'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">YYYY-MM-DD HH:MM:SS</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'2035-10-31 16:30:00'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">YYYY-MM-DD HH:MM:SS.SSS</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'2035-10-31 16:30:00.407'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">HH:MM:SS</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'16:30:00'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">HH:MM:SS.SSS</span></p></td>
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">'16:30:00.407'</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1250" aria-label="391"></span><span class="thesansmonocd_w5regular_">name TEXT NOT NULL</span>の<span class="thesansmonocd_w5regular_">NOT NULL</span>という部分では、Pythonの<span class="thesansmonocd_w5regular_">None</span>値が<span class="thesansmonocd_w5regular_">name</span>カラムに保存できないことを指定しています。必須項目についてはこのように指定します。</p>
<p class="tx">SQLiteのテーブルでは、自動的に一意の主キーとなる整数を含む<span class="thesansmonocd_w5regular_">rowid</span>というカラムが作成されます。<span class="thesansmonocd_w5regular_">cats</span>テーブルに偶然名前と生年月日と毛色と体重が同じ2匹のネコがいたとしても、<span class="thesansmonocd_w5regular_">rowid</span>により区別できます。</p>
</section>
<section type="division" aria-labelledby="sec7">
<h4 class="h1" id="calibre_link-1897"><span id="calibre_link-437"></span><span class="sans_futura_std_heavy_oblique_bi_">テーブルとカラムの一覧表示</span></h4>
<p class="tni">すべてのSQLiteデータベースに<span class="thesansmonocd_w5regular_">sqlite_schema</span>という名前のテーブルがあり、そこにはすべてのテーブルに関して、データベースについてのメタデータが一覧で保存されています。SQLiteデータベースのテーブル一覧を表示するには、以下のクエリを実行してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('example.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type="table"').fetchall()</b>
[('cats',)]
</code></pre>
<p class="tx">先ほど作成した<span class="thesansmonocd_w5regular_">cats</span>テーブルが出力されています。（<span class="thesansmonocd_w5regular_">SELECT</span>文の構文については<span>「データベースからデータを読み取る」</span>で説明します。）<span class="thesansmonocd_w5regular_">cats</span>テーブルのカラム情報を取得するには、以下のクエリを実行してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('example.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('PRAGMA TABLE_INFO(cats)').fetchall()</b>
[(0, 'name', 'TEXT', 1, None, 0), (1, 'birthdate', 'TEXT', 0, None, 0), (2,
'fur', 'TEXT', 0, None, 0), (3, 'weight_kg', 'REAL', 0, None, 0)]
</code></pre>
<p class="tx">このクエリは、テーブルの各カラムを説明するタプルのリストを返します。例えば、<span class="thesansmonocd_w5regular_">(1, 'birthdate', 'TEXT', 0, None, 0)</span>のタプルは<span class="thesansmonocd_w5regular_">birthdate</span>カラムの情報です。</p>
<p class="listplain"><b class="calibre10">カラム位置</b> <span class="thesansmonocd_w5regular_">1</span>はそのカラムがテーブルの2番目にあることを示します。カラム番号は、Pythonのリストと同じようにゼロ始まりですので、最初のカラムの位置は0です。</p>
<p class="listplain"><b class="calibre10">カラム名</b> <span class="thesansmonocd_w5regular_">'birthdate'</span>はカラム名です。SQLiteのカラム名とテーブル名は大文字と小文字を区別しません。</p>
<p class="listplain"><b class="calibre10">データ型</b> <span class="thesansmonocd_w5regular_">'TEXT'</span>は<span class="thesansmonocd_w5regular_">birthdate</span>カラムのSQLiteのデータ型です。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">NOT NULLの有無</span> <span class="thesansmonocd_w5regular_">0</span>は<span class="thesansmonocd_w5regular_">False</span>を意味し、このカラムは<span class="thesansmonocd_w5regular_">NOT NULL</span>ではないこと（このカラムに<span class="thesansmonocd_w5regular_">None</span>値を入れられること）を示します。</p>
<p class="listplain"><b class="calibre10">デフォルト値</b> <span class="thesansmonocd_w5regular_">None</span>は値が指定されなかったときに挿入されるデフォルトの値です。</p>
<p class="listplain"><b class="calibre10">主キーの有無</b> <span class="thesansmonocd_w5regular_">0</span>は<span class="thesansmonocd_w5regular_">False</span>を意味し、このカラムは主キーのカラムではないことを示します。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1079" aria-label="392"></span><span class="thesansmonocd_w5regular_">sqlite_schema</span>テーブル自体はテーブルとして一覧表示されません。<span class="thesansmonocd_w5regular_">sqlite_schema</span>テーブルを自分で修正することは決してないでしょうし、そのようなことをしたらデータベースが破損して読めなくなる可能性があります。</p>
</section>
</section>
<section type="division" aria-labelledby="sec8">
<h3 class="h" id="calibre_link-1898"><span id="calibre_link-438"></span><span class="sans_futura_std_bold_b_">データベースのCRUD操作</span></h3>
<p class="tni"><i class="calibre5">CRUD</i>はデータベースが実行する4つの基本操作――作成（Create）、読み取り（Read）、更新（Update）、削除（Delete）――の頭字語です。SQLiteでは、これらの操作を、それぞれ、<span class="thesansmonocd_w5regular_">INSERT</span>文、<span class="thesansmonocd_w5regular_">SELECT</span>文、<span class="thesansmonocd_w5regular_">UPDATE</span>文、<span class="thesansmonocd_w5regular_">DELETE</span>文で行います。<span class="thesansmonocd_w5regular_">conn.execute()</span>に文字列として渡すことになる、それぞれの文の例を示します。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">INSERT INTO cats VALUES ("Zophie", "2021-01-24", "black", 5.6)</span></li>
<li class="bl"><span class="thesansmonocd_w5regular_">SELECT rowid, * FROM cats ORDER BY fur</span></li>
<li class="bl"><span class="thesansmonocd_w5regular_">UPDATE cats SET fur</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">"gray tabby" WHERE rowid</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">1</span></li>
<li class="bl"><span class="thesansmonocd_w5regular_">DELETE FROM cats WHERE rowid</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">1</span></li>
</ul>
<p class="tx">ほとんどのアプリケーションやソーシャルメディアサイトは、実際のところ、CRUDデータベースの手の込んだユーザーインターフェイスです。写真を投稿したり返信したりすると、どこかにあるデータベースにレコードを作成しています。ソーシャルメディアのタイムラインをスクロールしたら、データベースからレコードを読み取っています。投稿を編集や削除したら、更新や削除の操作を実行しています。新しいアプリやプログラミング言語やクエリ言語の使い方を学ぶ際には、CRUDの基本操作を軸に考えてください。</p>
<section type="division" aria-labelledby="sec9">
<h4 class="h1" id="calibre_link-1899"><span id="calibre_link-439"></span><span class="sans_futura_std_heavy_oblique_bi_">データベースにデータを挿入する</span></h4>
<p class="tni">データベースと<span class="thesansmonocd_w5regular_">cats</span>テーブルを作成したので、私のペットのネコのレコードを挿入しましょう。私は約300匹のネコを家で飼っていて、SQLiteデータベースを使って管理しています。<span class="thesansmonocd_w5regular_">INSERT</span>文でテーブルに新しいレコードを挿入できます。対話型シェルに以下のコードを入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('example.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('CREATE TABLE IF NOT EXISTS cats (name TEXT NOT NULL, birthdate TEXT,</b>
<b class="calibre10">fur TEXT, weight_kg REAL) STRICT')</b>
&lt;sqlite3.Cursor object at 0x00000201B2399540&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO cats VALUES ("Zophie", "2021-01-24", "black", 5.6)')</b>
&lt;sqlite3.Cursor object at 0x00000162842E78C0&gt;
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">INSERT</span>クエリは<span class="thesansmonocd_w5regular_">cats</span>テーブルに新しい行を追加します。丸かっこ内はカンマ区切りの各カラムの値です。<span class="thesansmonocd_w5regular_">INSERT</span>クエリでは丸かっこが必須です。<span class="thesansmonocd_w5regular_">TEXT</span>値を挿入する際には、すでにシングルクォート（<span class="thesansmonocd_w5regular_">'</span>）をクエリ文字列で使っているので、ダブルクォート（<span class="sans_thesansmonocd_w7bold_b_">"</span>）を使っています。<span class="thesansmonocd_w5regular_">sqlite3</span>モジュールでは、<span class="thesansmonocd_w5regular_">TEXT</span>値にシングルクォートでもダブルクォートでも使えます。</p>
<section type="division" aria-labelledby="sec10">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-869" aria-label="393"></span>
<h5 class="h2" id="calibre_link-1900"><span class="sans_futura_std_bold_b_">トランザクション</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">INSERT</span>文は<i class="calibre5">トランザクション</i>を開始します。トランザクションとは、データベースでの作業単位です。トランザクションは<i class="calibre5">ACID</i>特性を持たなければなりません。ACIDとは、以下の概念を指します。</p>
<p class="listplain"><b class="calibre10">Atomic（原子性）</b> トランザクションは全部実行されるか全く実行されないかのどちらかでなければならない。</p>
<p class="listplain"><b class="calibre10">Consistent（一貫性）</b> トランザクションは、カラムの<span class="thesansmonocd_w5regular_">NOT NULL</span>などの制約に違反してはならない。</p>
<p class="listplain"><b class="calibre10">Isolated（独立性）</b> 一つのトランザクションは別のトランザクションに影響を及ぼしてはならない。</p>
<p class="listplain"><b class="calibre10">Durable（永続性）</b> コミットされたらトランザクションの結果はハードドライブなどの永続的なストレージに書き込まれる。</p>
<p class="tx">SQLiteはACID特性を持つデータベースです。トランザクションの途中でコンピュータの電源が落ちても大丈夫だと検証されているので、データベースファイルが破損して読めなくなることはないと信頼できます。SQLiteのクエリはデータを全部データベースに挿入するか、全く挿入しないかのいずれかです。</p>
</section>
<section type="division" aria-labelledby="sec11">
<h5 class="h2" id="calibre_link-1901"><span class="sans_futura_std_bold_b_">SQLインジェクション攻撃</span></h5>
<p class="tni"><i class="calibre5">SQLインジェクション攻撃</i>と呼ばれる攻撃手法により、意図しないクエリに変更されてしまうことがあります。こうした攻撃手法について解説するのは本書の範囲外であり、自分で書いたプログラムがインターネット上の知らない人からデータを受け取ることがなければこの攻撃を受けることもないでしょう。しかし、この攻撃を防ぐために、データベースのデータの挿入や更新に変数を参照する場合は常にクエスチョンマーク構文を使うようにしてください。</p>
<p class="tx">例えば、変数に格納されたデータをもとに新しいネコのレコードを挿入したいとしたら、このようにPythonでこれらの変数を直接クエリ文字列に挿入しないでください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">cat_name = 'Zophie'</b>
&gt;&gt;&gt; <b class="calibre10">cat_bday = '2021-01-24'</b>
&gt;&gt;&gt; <b class="calibre10">fur_color = 'black'</b>
&gt;&gt;&gt; <b class="calibre10">cat_weight = 5.6</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute(f'INSERT INTO cats VALUES ("{cat_name}", "{cat_bday}",</b>
<b class="calibre10">"{fur_color}", {cat_weight})')</b>
&lt;sqlite3.Cursor object at 0x0000022B91BB7C40&gt;
</code></pre>
<p class="tx">これらの変数の値がウェブアプリのフォームなどユーザーの入力に由来する場合は、攻撃者がクエリの意味を変える文字列を指定する可能性があります。変数を直接クエリ文字列に挿入するのではなく、クエリ文字列で<span class="thesansmonocd_w5regular_">?</span>を用いて、クエリ文字列のあとでリスト引数内で変数を渡します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO cats VALUES (?, ?, ?, ?)', [cat_name, cat_bday,</b>
<b class="calibre10">fur_color, cat_weight])</b>
&lt;sqlite3.Cursor object at 0x0000022B91BB7C40&gt;
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">execute()</span>メソッドは、SQLインジェクションを引き起こさないことを確認してから、<span class="thesansmonocd_w5regular_">?</span>のクエリ文字列中のプレースホルダーを変数の値に置き換えます。自分が書いて自分が実行するプログラムでそうした攻撃を受けることはないでしょうが、クエリ文字列を自分で組み立てるのではなく<span class="thesansmonocd_w5regular_">?</span>プレースホルダーを用いるのはよい習慣です。</p>
</section>
</section>
<section type="division" aria-labelledby="sec12">
<h4 class="h1" id="calibre_link-1902"><span id="calibre_link-440"></span><span class="sans_futura_std_heavy_oblique_bi_">データベースからデータを読み取る</span></h4>
<p class="tni">データベースにデータがあれば、<span class="thesansmonocd_w5regular_">SELECT</span>クエリでそのデータを読み取ることができます。対話型シェルに以下の内容を入力して、<i class="calibre5">example.db</i>データベースからデータを読み取ってみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('example.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats').fetchall()</b>
[('Zophie', '2021-01-24', 'black', 5.6)]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">SELECT</span>クエリを実行する<span class="thesansmonocd_w5regular_">execute()</span>メソッドを呼び出すと、<span class="thesansmonocd_w5regular_">Cursor</span>オブジェクトが返されます。実際のデータを取得するには、この<span class="thesansmonocd_w5regular_">Cursor</span>オブジェクトについて<span class="thesansmonocd_w5regular_">fetchall()</span>メソッドを呼び出します。各レコードがタプルとして返され、そのタプルがリストになっています。各タプル中のデータはテーブルのカラム順になっています。</p>
<p class="tx">このタプルのリストから抽出するPythonのコードを自分で書くのではなく、SQLiteでほしい情報を抽出します。<span class="thesansmonocd_w5regular_">SELECT</span>クエリには4つの部分があります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">SELECT</span>キーワード</li>
<li class="bl">取得するカラム（<span class="thesansmonocd_w5regular_">*</span>は<span class="thesansmonocd_w5regular_">rowid</span>以外のすべてのカラムという意味）</li>
<li class="bl"><span class="thesansmonocd_w5regular_">FROM</span>キーワード</li>
<li class="bl">データを取得するテーブル（この例の場合は<span class="thesansmonocd_w5regular_">cats</span>テーブル）</li>
</ul>
<p class="tx"><span class="thesansmonocd_w5regular_">cats</span>テーブルの<span class="thesansmonocd_w5regular_">rowid</span>カラムと<span class="thesansmonocd_w5regular_">name</span>カラムのレコードだけが必要なのであれば、次のようなクエリを書きます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT rowid, name FROM cats').fetchall()</b>
[(1, 'Zophie')]
</code></pre>
<p class="tx">次の節で説明するように、SQLでクエリの結果をフィルタリングすることもできます。</p>
<section type="division" aria-labelledby="sec13">
<h5 class="h2" id="calibre_link-1903"><span class="sans_futura_std_bold_b_">クエリ結果を反復処理する</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">fetchall()</span>メソッドは<span class="thesansmonocd_w5regular_">SELECT</span>クエリ結果をタプルのリストとして返します。このデータを使って<span class="thesansmonocd_w5regular_">for</span>ループで各タプルに何らかの操作を行うというコードのパターンがよくあります。例えば、<i class="calibre5"><a href="https://nostarch.com/automate-boring-stuff-python-3rd-edition" class="calibre1">https://<wbr></wbr>nostarch<wbr></wbr>.com<wbr></wbr>/automate<wbr></wbr>-boring<wbr></wbr>-stuff<wbr></wbr>-python<wbr></wbr>-3rd<wbr></wbr>-edition</a></i>から<i class="calibre5">sweigartcats.db</i>ファイルをダウンロードして、対話型シェルに以下の内容を入力してデータを処理してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">for row in conn.execute('SELECT * FROM cats'):</b>
<b class="calibre10">...     print('Row data:', row)</b>
...     <b class="calibre10">print(row[0], 'is one of my favorite cats.')</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1904" aria-label="395"></span>...
Row data: ('Zophie', '2021-01-24', 'gray tabby', 5.6)
Zophie is one of my favorite cats.
Row data: ('Miguel', '2016-12-24', 'siamese', 6.2)
Miguel is one of my favorite cats.
Row data: ('Jacob', '2022-02-20', 'orange and white', 5.5)
Jacob is one of my favorite cats.
<var class="calibre20">--snip--</var>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループは<span class="thesansmonocd_w5regular_">fetchall()</span>を呼び出さずに<span class="thesansmonocd_w5regular_">conn.execute()</span>が返す行のデータのタプルを反復処理します（訳注：<span class="thesansmonocd_w5regular_">fetchall()</span>を呼び出すと一度すべての結果を取得するのに対し、呼び出さないと結果を逐次処理します）。<span class="thesansmonocd_w5regular_">for</span>ループ内のコードでは各行を処理します。変数<span class="thesansmonocd_w5regular_">row</span>にはクエリの結果のデータ行のタプルが入っているからです。タプルの整数のインデックスでカラムにアクセスできます。インデックス<span class="thesansmonocd_w5regular_">0</span>は名前で、インデックス<span class="thesansmonocd_w5regular_">1</span>は生年月日で、といった具合です。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h5 class="h2" id="calibre_link-1905"><span class="sans_futura_std_bold_b_">取得したデータのフィルタリング</span></h5>
<p class="tni">先ほどの<span class="thesansmonocd_w5regular_">SELECT</span>クエリではテーブルのすべての行を取得しましたが、何らかのフィルタリング基準に沿って一部の行だけがほしいこともあるでしょう。<i class="calibre5">sweigartcats.db</i>ファイルで、<span class="thesansmonocd_w5regular_">WHERE</span>節を<span class="thesansmonocd_w5regular_">SELECT</span>文につけて検索条件を指定します。例えば毛色が黒のネコだけを取得してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE fur = "black"').fetchall()</b>
[<span class="code_codeannotation" aria-label="annotation1">❶</span>('Zophie', '2021-01-24', 'black', 5.6), ('Toby', '2021-05-17', 'black',
6.8), ('Thor', '2013-05-14', 'black', 5.2), ('Sassy', '2017-08-20', 'black',
7.5), ('Hope', '2016-05-22', 'black', 7.6)]
</code></pre>
<p class="tx">この例では、<span class="thesansmonocd_w5regular_">WHERE</span>節の<span class="thesansmonocd_w5regular_">WHERE fur</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">"black"</span>により、<span class="thesansmonocd_w5regular_">fur</span>カラムの値が<span class="thesansmonocd_w5regular_">"black"</span>のレコードのみを取得します。</p>
<p class="tx">SQLiteは<span class="thesansmonocd_w5regular_">WHERE</span>節で固有の演算子を使いますが、Pythonの演算子に似ています。<span class="thesansmonocd_w5regular_">=</span>、<span class="thesansmonocd_w5regular_">!=</span>、<span class="thesansmonocd_w5regular_">&lt;</span>、<span class="thesansmonocd_w5regular_">&gt;</span>、<span class="thesansmonocd_w5regular_">&lt;=</span>、<span class="thesansmonocd_w5regular_">&gt;=</span>、<span class="thesansmonocd_w5regular_">AND</span>、<span class="thesansmonocd_w5regular_">OR</span>、<span class="thesansmonocd_w5regular_">NOT</span>です。SQLiteは「等しい」という意味で<b class="calibre10">=</b>演算子を使うことに注意してください。Pythonでは「等しい」という意味の演算子は<span class="thesansmonocd_w5regular_">==</span>です。演算子のどちらの側にカラム名を置いてもリテラル値を置いても動作します。</p>
<p class="tx">比較はテーブルの各行について行われます。例えば、<span class="thesansmonocd_w5regular_">WHERE fur</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">"black"</span>では、SQLiteが以下の比較を行います。</p>
<ul class="ul">
<li class="bl">1行目では<span class="thesansmonocd_w5regular_">fur</span>が<span class="thesansmonocd_w5regular_">'black'</span>であり、<span class="thesansmonocd_w5regular_">'black'</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'black'</span>はtrueになりますから、SQLiteはこの<span class="codeannotation" aria-label="annotation1">❶</span>の行を結果に含めます。</li>
<li class="bl">2行目では<span class="thesansmonocd_w5regular_">(2, 'Miguel', '2016-12-24', 'siamese', 6.2)</span>の<span class="thesansmonocd_w5regular_">fur</span>は<span class="thesansmonocd_w5regular_">'siamese'</span>であり、<span class="thesansmonocd_w5regular_">'siamese'</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'black'</span>はfalseになりますから、この行は結果に含まれません。</li>
<li class="bl">3行目では<span class="thesansmonocd_w5regular_">(3, 'Jacob', '2022-02-20', 'orange and white', 5.5)</span>の<span class="thesansmonocd_w5regular_">fur</span>は<span class="thesansmonocd_w5regular_">'orange and white'</span>であり、<span class="thesansmonocd_w5regular_">'orange and white'</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'black'</span>はfalseになりますから、この行は結果に含まれません。</li>
</ul>
<p class="tni"><span class="thesansmonocd_w5regular_">cats</span>テーブルのすべての行についてこのように比較します。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-935" aria-label="396"></span><span class="thesansmonocd_w5regular_">WHERE fur</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">"black" OR birthdate &gt;=</span> <span class="thesansmonocd_w5regular_">"2024-01-01"'</span>という、もっと複雑な<span class="thesansmonocd_w5regular_">WHERE</span>節の例を見てみましょう。<span class="thesansmonocd_w5regular_">pprint.pprint()</span>関数を使って結果のリストをきれいに表示しましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pprint</b>
&gt;&gt;&gt; <b class="calibre10">matching_cats = conn.execute('SELECT * FROM cats WHERE fur = "black"</b>
<b class="calibre10">OR birthdate &gt;= "2024-01-01"').fetchall()</b>
&gt;&gt;&gt; <b class="calibre10">pprint.pprint(matching_cats)</b>
[('Zophie', '2021-01-24', 'black', 5.6),
 ('Toby', '2021-05-17', 'black', 6.8),
 ('Taffy', '2024-12-09', 'white', 7.0),
 ('Hollie', '2024-08-07', 'calico', 6.0),
 ('Lewis', '2024-03-19', 'orange tabby', 5.1),
 ('Thor', '2013-05-14', 'black', 5.2),
 ('Shell', '2024-06-16', 'tortoiseshell', 6.5),
 ('Jasmine', '2024-09-05', 'orange tabby', 6.3),
 ('Sassy', '2017-08-20', 'black', 7.5),
 ('Hope', '2016-05-22', 'black', 7.6)]
</code></pre>
<p class="tx">結果のリスト<span class="thesansmonocd_w5regular_">matching_cats</span>に含まれるネコは、毛色が黒か生年月日が2024年1月1日以降です。生年月日は文字列です。<span class="thesansmonocd_w5regular_">&gt;=</span>のような演算子の比較は文字列ではアルファベット順の比較になりますが、生年月日のフォーマットが<i class="calibre5">YYYY-MM-DD</i>であれば日付順の比較と同じになります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">LIKE</span>演算子でパーセント記号（<span class="thesansmonocd_w5regular_">%</span>）をワイルドカードとして使えば、値の先頭あるいは末尾にマッチさせられます。例えば、<span class="thesansmonocd_w5regular_">name LIKE "%y"</span>は<span class="thesansmonocd_w5regular_">'y'</span>で終わるすべての名前にマッチしますし、<span class="thesansmonocd_w5regular_">name LIKE "Ja%"</span>は<span class="thesansmonocd_w5regular_">'Ja'</span>で始まるすべての名前にマッチします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT rowid, name FROM cats WHERE name LIKE "%y"').fetchall()</b>
[(5, 'Toby'), (11, 'Molly'), (12, 'Dusty'), (17, 'Mandy'), (18, 'Taffy'), (25, 'Rocky'), (27,
'Bobby'), (30, 'Misty'), (34, 'Mitsy'), (38, 'Colby'), (40, 'Riley'), (46, 'Ruby'), (65,
'Daisy'), (67, 'Crosby'), (72, 'Harry'), (77, 'Sassy'), (85, 'Lily'), (93, 'Spunky')]
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT rowid, name FROM cats WHERE name LIKE "Ja%"').fetchall()</b>
[(3, 'Jacob'), (49, 'Java'), (75, 'Jasmine'), (80, 'Jamison')]
</code></pre>
<p class="tx">パーセント記号を文字列の先頭と末尾に置けば、部分一致になります。例えば、<span class="thesansmonocd_w5regular_">name LIKE "%ob%"</span>は文字列中のどこかに<span class="thesansmonocd_w5regular_">'ob'</span>があるすべての名前にマッチします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT rowid, name FROM cats WHERE name LIKE "%ob%"').fetchall()</b>
[(3, 'Jacob'), (5, 'Toby'), (27, 'Bobby')]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">LIKE</span>演算子は大文字と小文字を区別せずにマッチします。よって、<span class="thesansmonocd_w5regular_">name LIKE "%ob%"</span>は<span class="thesansmonocd_w5regular_">'%OB%'</span>、<span class="thesansmonocd_w5regular_">'%Ob%'</span>、<span class="thesansmonocd_w5regular_">'%oB%'</span>にもマッチします。大文字と小文字を区別してマッチさせるには、<span class="thesansmonocd_w5regular_">GLOB</span>演算子と<span class="thesansmonocd_w5regular_">*</span>をワイルドカードとして使います。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT rowid, name FROM cats WHERE name GLOB "*m*"').fetchall()</b>
[(4, 'Gumdrop'), (9, 'Thomas'), (44, 'Sam'), (63, 'Cinnamon'), (75, 'Jasmine'),
(79, 'Samantha'), (80, 'Jamison')]
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-930" aria-label="397"></span><span class="thesansmonocd_w5regular_">name LIKE "%m%"</span>は大文字と小文字の<i class="calibre5">m</i>にマッチするのに対し、<span class="thesansmonocd_w5regular_">name GLOB "*m*"</span>は小文字の<i class="calibre5">m</i>にしかマッチしません。</p>
<p class="tx">SQLiteの演算子は、プログラミング言語の演算子と同じくらい幅広いです。<i class="calibre5"><a href="https://www.sqlite.org/lang_expr.html" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.sqlite<wbr></wbr>.org<wbr></wbr>/lang<wbr></wbr>_expr<wbr></wbr>.html</a></i>のSQLiteのドキュメントでもっと詳しく説明されています。</p>
</section>
<section type="division" aria-labelledby="sec15">
<h5 class="h2" id="calibre_link-1906"><span class="sans_futura_std_bold_b_">結果の並べ替え</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">fetchall()</span>で返されるリストにPythonの<span class="thesansmonocd_w5regular_">sort()</span>メソッドを適用して並べ替えをすることができますが、<span class="thesansmonocd_w5regular_">SELECT</span>クエリに<span class="thesansmonocd_w5regular_">ORDER BY</span>節をつけてSQLiteのデータの並べ替えをしたほうが簡単です。例えば、ネコを毛色で並べ替えたければ、以下のようにします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3, pprint</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">pprint.pprint(conn.execute('SELECT * FROM cats ORDER BY fur').fetchall())</b>
[('Iris', '2017-07-13', 'bengal', 6.8),
 ('Ruby', '2023-12-22', 'bengal', 5.0),
 ('Elton', '2020-05-28', 'bengal', 5.4),
 ('Toby', '2021-05-17', 'black', 6.8),
 ('Thor', '2013-05-14', 'black', 5.2),
<var class="calibre20">--snip--</var>
 ('Celine', '2015-04-18', 'white', 7.3),
 ('Daisy', '2019-03-19', 'white', 6.0)]
</code></pre>
<p class="tx">クエリに<span class="thesansmonocd_w5regular_">WHERE</span>節があれば、<span class="thesansmonocd_w5regular_">ORDER BY</span>節はそれより後に書きます。複数のカラムに基づいて並べ替えることもできます。例えば、まず毛色で並べ替えて、同じ毛色内では生年月日で並べ替えるなら、以下のように実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">cur = conn.execute('SELECT * FROM cats ORDER BY fur, birthdate')</b>
&gt;&gt;&gt; <b class="calibre10">pprint.pprint(cur.fetchall())</b>
[('Iris', '2017-07-13', 'bengal', 6.8),
 ('Elton', '2020-05-28', 'bengal', 5.4),
 ('Ruby', '2023-12-22', 'bengal', 5.0),
 ('Thor', '2013-05-14', 'black', 5.2),
 ('Hope', '2016-05-22', 'black', 7.6),
<var class="calibre20">--snip--</var>
 ('Ginger', '2020-09-22', 'white', 5.8),
 ('Taffy', '2024-12-09', 'white', 7.0)]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">ORDER BY</span>節は<span class="thesansmonocd_w5regular_">fur</span>カラムを先に書き、カンマで区切って<span class="thesansmonocd_w5regular_">birthdate</span>カラムを続けて書きます。デフォルトでは、昇順で並べ替えられます。小さな値が先で大きな値が後に来ます。降順で並べ替えるには、カラム名の後に<span class="thesansmonocd_w5regular_">DESC</span>キーワードをつけます。<span class="thesansmonocd_w5regular_">ASC</span>キーワードをつけて昇順であることを明示してクエリを読みやすくすることもできます。これらのキーワードの練習として、対話型シェルで以下の内容を実行してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">cur = conn.execute('SELECT * FROM cats ORDER BY fur ASC, birthdate DESC')</b>
&gt;&gt;&gt; <b class="calibre10">pprint.pprint(cur.fetchall())</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1217" aria-label="398"></span>[('Ruby', '2023-12-22', 'bengal', 5.0),
 ('Elton', '2020-05-28', 'bengal', 5.4),
 ('Iris', '2017-07-13', 'bengal', 6.8),
 ('Toby', '2021-05-17', 'black', 6.8),
 ('Sassy', '2017-08-20', 'black', 7.5),
<var class="calibre20">--snip--</var>
 ('Mitsy', '2015-05-29', 'white', 5.0),
 ('Celine', '2015-04-18', 'white', 7.3)]
</code></pre>
<p class="tx">毛色の昇順でネコの一覧を出力します（<span class="thesansmonocd_w5regular_">'bengal'</span>は<span class="thesansmonocd_w5regular_">'white'</span>よりも前に来ます）。同じ毛色内では、生年月日の降順になります（<span class="thesansmonocd_w5regular_">'2023-12-22'</span>は<span class="thesansmonocd_w5regular_">'2020-05-28'</span>よりも前に来ます）。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h5 class="h2" id="calibre_link-1907"><span class="sans_futura_std_bold_b_">結果の数を限定する</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">SELECT</span>クエリで返される最初の数行を確認したいだけであれば、Pythonのリストのスライスで結果の数を限定しようと考えるかもしれません。例えば、<span class="thesansmonocd_w5regular_">[:3]</span>というスライスを使えば、<span class="thesansmonocd_w5regular_">cats</span>テーブルの最初の3行だけを表示できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats').fetchall()[:3]</b>  # これは非効率
[('Zophie', '2021-01-24', 'gray tabby', 5.6), ('Miguel', '2016-12-24',
'siamese', 6.2), ('Jacob', '2022-02-20', 'orange and white', 5.5)]
</code></pre>
<p class="tx">このコードは意図した通りに動きますが非効率です。まずテーブルからすべての行を取得し、次に最初の3行以外を捨てています。データベースから最初の3行だけを取得したほうがプログラムは速くなります。<span class="thesansmonocd_w5regular_">LIMIT</span>節でそれができます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats LIMIT 3').fetchall()</b>
[('Zophie', '2021-01-24', 'gray tabby', 5.6), ('Miguel', '2016-12-24',
'siamese', 6.2), ('Jacob', '2022-02-20', 'orange and white', 5.5)]
</code></pre>
<p class="tx">このコードは、特に行数の多いテーブルに関しては、すべての行を取得するコードよりも実行が速いです。<span class="thesansmonocd_w5regular_">LIMIT</span>節は<span class="thesansmonocd_w5regular_">WHERE</span>節と<span class="thesansmonocd_w5regular_">ORDER BY</span>節よりも後に来ますので、<span class="thesansmonocd_w5regular_">SELECT</span>クエリにそれらの節があるのであれば、次のように書きます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE fur="orange" ORDER BY birthdate LIMIT 4').fetchall()</b>
[('Mittens', '2013-07-03', 'orange', 7.4), ('Piers', '2014-07-08', 'orange', 5.2),
('Misty', '2016-07-08', 'orange', 5.2), ('Blaze', '2023-01-16', 'orange', 7.4)]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">SELECT</span>クエリにつけられる節はほかにもいくつかありますが、本章の範囲を超えます。それらについてはSQLiteのドキュメントで調べることができます。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h5 class="h2" id="calibre_link-1908"><span class="sans_futura_std_bold_b_">データの読み取り速度を向上させるためにインデックスを作成する</span></h5>
<p class="tni">前の節では、<span class="thesansmonocd_w5regular_">SELECT</span>クエリを実行して名前のマッチに基づいてレコードを検索しました。<span class="thesansmonocd_w5regular_">name</span>カラムにインデックスを作成することでこの検索の速度を向上させられます。SQLの<i class="calibre5">インデックス</i>は、カラムのデータを整理するデータ構造です。これを利用すると、インデックスを作成したカラムについて<span class="thesansmonocd_w5regular_">WHERE</span>節のあるクエリの実行速度が向上します。インデックスに少し容量が必要なのと、SQLiteがデータのインデックスも更新しないといけないのでデータの挿入と更新が少し遅くなるのが欠点です。データベースが大規模で、データの挿入や更新よりも読み取りの頻度が高ければ、インデックスを検討する価値があるでしょう。しかし、インデックスが実際に速度を向上させることをテストすべきです。</p>
<p class="tx">例えば、<span class="thesansmonocd_w5regular_">cats</span>テーブルの<span class="thesansmonocd_w5regular_">names</span>カラムと<span class="thesansmonocd_w5regular_">birthdate</span>カラムにインデックスを作成するなら、以下の<span class="thesansmonocd_w5regular_">CREATE INDEX</span>クエリを実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('CREATE INDEX idx_name ON cats (name)')</b>
&lt;sqlite3.Cursor object at 0x0000013EC121A040&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('CREATE INDEX idx_birthdate ON cats (birthdate)')</b>
&lt;sqlite3.Cursor object at 0x0000013EC121A040&gt;
</code></pre>
<p class="tx">インデックスには名前が必要で、慣習的に、適用するカラム名に<span class="thesansmonocd_w5regular_">idx_</span>という接頭辞をつけます。インデックス名はデータベース全体でグローバルにアクセスできるので、データベースに<span class="thesansmonocd_w5regular_">birthdate</span>カラムのあるテーブルが複数あるなら、<span class="thesansmonocd_w5regular_">idx_cats_birthdate</span>のように、テーブル名もインデックス名に含めたほうがよいでしょう。テーブルで作成されているすべてのインデックスを確認するには、組み込みの<span class="thesansmonocd_w5regular_">sqlite_schema</span>テーブルに<span class="thesansmonocd_w5regular_">SELECT</span>クエリを実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type = "index" AND</b>
<b class="calibre10">tbl_name = "cats"').fetchall()</b>
[('idx_name',), ('idx_birthdate',)]
</code></pre>
<p class="tx">考えが変わったりインデックスが速度を向上させなかったりしたら、<span class="thesansmonocd_w5regular_">DROP INDEX</span>クエリでインデックスを削除できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type = "index" AND</b>
<b class="calibre10">tbl_name = "cats"').fetchall()</b>
[('idx_birthdate',) ('idx_name',)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('DROP INDEX idx_name')</b>
&lt;sqlite3.Cursor object at 0x0000013EC121A040&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type = "index" AND</b>
<b class="calibre10">tbl_name = "cats"').fetchall()</b>
[('idx_birthdate',)]
</code></pre>
<p class="tx">数千レコード程度の小さなデータベースであれば、インデックスを作成しても作成しなくても大差はないので、インデックスを気にしなくて構いません。しかし、データベースのクエリが気になるほど時間を要するなら、インデックスを作成すると速度が向上するかもしれません。</p>
</section>
</section>
<section type="division" aria-labelledby="sec18">
<h4 class="h1" id="calibre_link-1909"><span id="calibre_link-441"></span><span class="sans_futura_std_heavy_oblique_bi_">データベースのデータを更新する</span></h4>
<p class="tni">テーブルに行を挿入したあとで、<span class="thesansmonocd_w5regular_">UPDATE</span>文を実行すれば行を変更できます。例えば、<i class="calibre5">sweigartcats.db</i>ファイルの<span class="thesansmonocd_w5regular_">(1, 'Zophie', '2021-01-24',</span> <span role="doc-pagebreak" type="pagebreak" id="calibre_link-1276" aria-label="400"></span><span class="thesansmonocd_w5regular_">'black', 5.6)</span>のレコードの毛色を<span class="thesansmonocd_w5regular_">'black'</span>から<span class="thesansmonocd_w5regular_">'gray tabby'</span>に変更してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE rowid = 1').fetchall()</b>
[('Zophie', '2021-01-24', 'black', 5.6)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('UPDATE cats SET fur = "gray tabby" WHERE rowid = 1')</b>
&lt;sqlite3.Cursor object at 0x0000013EC121A040&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE rowid = 1').fetchall()</b>
[('Zophie', '2021-01-24', 'gray tabby', 5.6)]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">UPDATE</span>文には以下の部分があります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">UPDATE</span>キーワード</li>
<li class="bl">更新する行を含むテーブル名</li>
<li class="bl">更新するカラムと値を指定する<span class="thesansmonocd_w5regular_">SET</span>節</li>
<li class="bl">更新する行を指定する<span class="thesansmonocd_w5regular_">WHERE</span>節</li>
</ul>
<p class="tx">カンマで区切って指定すれば複数のカラムを一度に更新できます。例えば、<span class="thesansmonocd_w5regular_">'UPDATE cats SET fur</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">"black", weight_kg</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">6 WHERE rowid</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">1'</span>というクエリは、<span class="thesansmonocd_w5regular_">fur</span>カラムの値を<span class="thesansmonocd_w5regular_">"black"</span>に、<span class="thesansmonocd_w5regular_">weight</span>カラムの値を<span class="thesansmonocd_w5regular_">6</span>に更新します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">UPDATE</span>クエリは<span class="thesansmonocd_w5regular_">WHERE</span>節がtrueになるすべての行を更新します。<span class="thesansmonocd_w5regular_">'UPDATE cats SET fur</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">"gray tabby" WHERE name</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">"Zophie"'</span>クエリを実行すると、Zophieという名前のすべてのネコについて更新が適用されます。意図していたよりも多く更新してしまう可能性があります。そのため、更新クエリでは、<span class="thesansmonocd_w5regular_">WHERE</span>節で更新するレコードを一つだけ指定するために主キーの<span class="thesansmonocd_w5regular_">rowid</span>カラムを使うことが多いです。主キーは行を一意に識別しますから、<span class="thesansmonocd_w5regular_">WHERE</span>節でそれを使うと意図した行だけ更新することを保証できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">WHERE</span>節をつけ忘れてデータを更新してしまうというのはよくあるバグです。例えば、すべてのネコについて、毛色の<span class="thesansmonocd_w5regular_">'white and orange'</span> を<span class="thesansmonocd_w5regular_">'orange and white'</span>に置換したいとしたら、以下を実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('UPDATE cats SET fur = "orange and white" WHERE fur = "white and orange"')</b></code></pre>
<p class="tx">このとき<span class="thesansmonocd_w5regular_">WHERE</span>節をつけ忘れたら、テーブルのすべての行に更新が適用され、突然すべてのネコの毛色が'orange and white'になってしまいます。</p>
<p class="tx">このバグを避けるために、すべての行に変更を適用したい場合であっても、<span class="thesansmonocd_w5regular_">UPDATE</span>クエリには必ず<span class="thesansmonocd_w5regular_">WHERE</span>節をつけるようにしてください。すべての行に変更を適用する場合は、<span class="thesansmonocd_w5regular_">WHERE 1</span>とします。<span class="thesansmonocd_w5regular_">1</span>はSQLiteでブール値の<span class="thesansmonocd_w5regular_">True</span>を表しますから、すべての行に変更を適用するという意味になります。余計な<span class="thesansmonocd_w5regular_">WHERE 1</span>をクエリの末尾につけるのはバカげているように見えるかもしれませんが、実データを簡単に消し去ってしまう危険なバグを避けるのに役立ちます。</p>
</section>
<section type="division" aria-labelledby="sec19">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-958" aria-label="401"></span>
<h4 class="h1" id="calibre_link-1910"><span id="calibre_link-442"></span><span class="sans_futura_std_heavy_oblique_bi_">データベースからデータを削除する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">DELETE</span>クエリでベーブルから行を削除できます。例えば、<i class="calibre5">sweigartcats.db</i>ファイルの<span class="thesansmonocd_w5regular_">cats</span>テーブルからZophieを削除するには、以下の内容を実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT rowid, * FROM cats WHERE rowid = 1').fetchall()</b>
[(1, 'Zophie', '2021-01-24', 'gray tabby', 5.6)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('DELETE FROM cats WHERE rowid = 1')</b>
&lt;sqlite3.Cursor object at 0x0000020322D183C0&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE rowid = 1').fetchall()</b>
[]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">DELETE</span>文には以下の部分があります。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">DELETE FROM</span>キーワード</li>
<li class="bl">削除する行を含むテーブル名</li>
<li class="bl">削除する行を指定する<span class="thesansmonocd_w5regular_">WHERE</span>節</li>
</ul>
<p class="tx"><span class="thesansmonocd_w5regular_">UPDATE</span>文と同じように、<span class="thesansmonocd_w5regular_">DELETE</span>文には必ず<span class="thesansmonocd_w5regular_">WHERE</span>節をつけるようにしてください。そうでなければ、テーブルからすべての行を削除してしまいます。もしすべての行を削除したいなら、<span class="thesansmonocd_w5regular_">WHERE 1</span>をつけてください。そうすれば、<span class="thesansmonocd_w5regular_">WHERE</span>節のない<span class="thesansmonocd_w5regular_">DELETE</span>文はバグだとわかりやすくなります。</p>
</section>
</section>
<section type="division" aria-labelledby="sec20">
<h3 class="h" id="calibre_link-1911"><span id="calibre_link-443"></span><span class="sans_futura_std_bold_b_">トランザクションのロールバック</span></h3>
<p class="tni">いくつかのクエリをまとめて実行するか全部実行しないかのどちらかにしたいことが時々あります。しかし、クエリを実行してみないと、そのどちらがいいのかわかりません。こうした状況に対応する一つの方法は、トランザクションを開始することです。クエリを実行し、すべてのクエリをデータベースに<i class="calibre5">コミット</i>してトランザクションを完了させるか、<i class="calibre5">ロールバック</i>してデータベースを何事もなかったかのような状態にするかのいずれかになります。</p>
<p class="tx">SQLiteデータベースに自動コミットモードで接続していれば、通常、1回の<span class="thesansmonocd_w5regular_">conn.execute()</span>呼び出しごとにトランザクションを開始して終了します。しかし、<span class="thesansmonocd_w5regular_">BEGIN</span>クエリで新しいトランザクションを開始することもできます。そうすると、<span class="thesansmonocd_w5regular_">conn.commit()</span>を呼び出してトランザクションを完了させるか、<span class="thesansmonocd_w5regular_">conn.rollback()</span>を呼び出してすべてのクエリをなかったことにするかのいずれかになります。</p>
<p class="tx">例えば、<span class="thesansmonocd_w5regular_">cats</span>テーブルに2匹の新しいネコを追加して、そのトランザクションをロールバックしてみます。そうすればテーブルは変更されないままです。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('BEGIN')</b>
&lt;sqlite3.Cursor object at 0x00000219C8BF7C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO cats VALUES ("Socks", "2022-04-04", "white", 4.2)')</b>
&lt;sqlite3.Cursor object at 0x00000219C8BF7C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO cats VALUES ("Fluffy", "2022-10-30", "gray", 4.5)')</b>
&lt;sqlite3.Cursor object at 0x00000219C8BF7C40&gt;
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-950" aria-label="402"></span>&gt;&gt;&gt; <b class="calibre10">conn.rollback()</b>  # これによりINSERT文がなかったことになる
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE name = "Socks"').fetchall()</b>
[]
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE name = "Fluffy"').fetchall()</b>
[]
</code></pre>
<p class="tx">新しいネコのSocksとFluffyは、データベースに挿入されていません。</p>
<p class="tx">反対に、実行したクエリをすべて適用したければ、<span class="thesansmonocd_w5regular_">conn.commit()</span>を呼び出してデータベースに変更をコミットします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('BEGIN')</b>
&lt;sqlite3.Cursor object at 0x00000219C8BF7C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO cats VALUES ("Socks", "2022-04-04", "white", 4.2)')</b>
&lt;sqlite3.Cursor object at 0x00000219C8BF7C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO cats VALUES ("Fluffy", "2022-10-30", "gray", 4.5)')</b>
&lt;sqlite3.Cursor object at 0x00000219C8BF7C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.commit()</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE name = "Socks"').fetchall()</b>
[('Socks', '2022-04-04', 'white', 4.2)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats WHERE name = "Fluffy"').fetchall()</b>
[('Fluffy', '2022-10-30', 'gray', 4.5)]
</code></pre>
<p class="tx">SocksとFluffyのネコはデータベースのレコードに存在します。</p>
</section>
<section type="division" aria-labelledby="sec21">
<h3 class="h" id="calibre_link-1912"><span id="calibre_link-444"></span><span class="sans_futura_std_bold_b_">データベースのバックアップ</span></h3>
<p class="tni">ある私の友人が、収集用のスポーツカードを専門に扱っているECサイトで使っているデータベースに変更を加えようとしていました。いくつかのカードに含まれる誤りを訂正しなければならず、<span class="thesansmonocd_w5regular_">UPDATE cards SET name</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">'Chris Clemons'</span>と入力したところで、その友人のネコがキーボートの上に乗り、<small class="calibre4">ENTER</small>キーを押しました。<span class="thesansmonocd_w5regular_">WHERE</span>節がなかったので、このクエリはウェブサイトで販売中の数千枚のカードすべてを更新してしまいました。</p>
<p class="tx">幸い、その友人はデータベースのバックアップを取得していたので、以前の状態に復元することができました。（バックアップを取得していて本当によかったです。というのも、同じことが再び起こりました。そのネコはわざとやっているのでしょう。）</p>
<p class="tx">プログラムが現在SQLiteデータベースに接続していなければ、データベースファイルを単純にコピーするだけでバックアップを取得できます。Pythonプログラムでは、<span>第11章</span>で説明したように、<span class="thesansmonocd_w5regular_">shutil.copy('sweigartcats.db', 'backup.db')</span>を呼び出せばファイルをコピーできます。しかし、ソフトウェアから絶えずデータベースの内容を読み書きしているなら、（単純にファイルをコピーするというわけにはいかないので）<span class="thesansmonocd_w5regular_">Connection</span>オブジェクトの<span class="thesansmonocd_w5regular_">backup()</span>メソッドを使う必要があります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">backup_conn = sqlite3.connect('backup.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.backup(backup_conn)</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-901" aria-label="403"></span><span class="thesansmonocd_w5regular_">backup()</span>メソッドは、他のクエリが実行中であっても、<i class="calibre5">sweigartcats.db</i>データベースの内容を<i class="calibre5">backup.db</i>ファイルへと安全にバックアップします。これでデータを安全にバックアップできましたから、ネコが好きなだけキーボートの上に乗ることができます。</p>
</section>
<section type="division" aria-labelledby="sec22">
<h3 class="h" id="calibre_link-1913"><span id="calibre_link-445"></span><span class="sans_futura_std_bold_b_">テーブルの変更と削除</span></h3>
<p class="tni">データベースにテーブルを作成して行を挿入してから、テーブル名やカラム名を変更したくなることがあるかもしれません。テーブルのカラムの追加や削除、あるいはテーブル全体を削除したい場合もあるでしょう。<span class="thesansmonocd_w5regular_">ALTER TABLE</span>クエリを実行すればこれらの操作ができます。</p>
<p class="tx">以下の対話型シェルの例では、<i class="calibre5">sweigartcats.db</i>データベースファイルの最初の状態から始めます。<span class="thesansmonocd_w5regular_">ALTER TABLE RENAME</span>クエリを実行して、テーブル名を<span class="thesansmonocd_w5regular_">cats</span>から<span class="thesansmonocd_w5regular_">felines</span>に変更します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type="table"').fetchall()</b>
[('cats',)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('ALTER TABLE cats RENAME TO felines')</b>  # テーブル名の変更
&lt;sqlite3.Cursor object at 0x000001EDDB477C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type="table"').fetchall()</b>
[('felines',)]
</code></pre>
<p class="tx">テーブル内のカラム名を変更するには、<span class="thesansmonocd_w5regular_">ALTER TABLE RENAME COLUMN</span>クエリを実行します。例えば、カラム名を<span class="thesansmonocd_w5regular_">fur</span>から<span class="thesansmonocd_w5regular_">description</span>に変更してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('PRAGMA TABLE_INFO(felines)').fetchall()[2]</b>  # 3番目のカラムを表示
(2, 'fur', 'TEXT', 0, None, 0)
&gt;&gt;&gt; <b class="calibre10">conn.execute('ALTER TABLE felines RENAME COLUMN fur TO description')</b>
&lt;sqlite3.Cursor object at 0x000001EDDB477C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('PRAGMA TABLE_INFO(felines)').fetchall()[2]</b>  # 3番目のカラムを表示
(2, 'description', 'TEXT', 0, None, 0)
</code></pre>
<p class="tx">テーブルに新しいカラムを追加するには、<span class="thesansmonocd_w5regular_">ALTER TABLE ADD COLUMN</span>クエリを実行します。例えば、<span class="thesansmonocd_w5regular_">felines</span>テーブルに、ブール値が入る<span class="thesansmonocd_w5regular_">is_loved</span>カラムを新しく追加してみます。SQLiteでは、<span class="thesansmonocd_w5regular_">0</span>がfalseを、<span class="thesansmonocd_w5regular_">1</span>がtrueを表します。<span class="thesansmonocd_w5regular_">is_loved</span>のデフォルト値は<span class="thesansmonocd_w5regular_">1</span>にします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('ALTER TABLE felines ADD COLUMN is_loved INTEGER DEFAULT 1')</b>
&lt;sqlite3.Cursor object at 0x000001EDDB477C40&gt;
&gt;&gt;&gt; <b class="calibre10">import pprint</b>
&gt;&gt;&gt; <b class="calibre10">pprint.pprint(conn.execute('SELECT * FROM felines LIMIT 3').fetchall())</b>
[('Zophie', '2021-01-24', 'gray tabby', 5.6, 1),
 ('Miguel', '2016-12-24', 'siamese', 6.2, 1),
 ('Jacob', '2022-02-20', 'orange and white', 5.5, 1)]
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-902" aria-label="404"></span>私はどのネコについても<span class="thesansmonocd_w5regular_">1</span>を保存するので、<span class="thesansmonocd_w5regular_">is_loved</span>カラムは不要だとわかりました。そこで、<span class="thesansmonocd_w5regular_">ALTER TABLE DROP COLUMN</span>クエリでこのカラムを削除します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('PRAGMA TABLE_INFO(felines)').fetchall()</b>  # すべてのカラムを表示
[(0, 'name', 'TEXT', 1, None, 0), (1, 'birthdate', 'TEXT', 0, None, 0), (2, 'description', 'TEXT',
0, None, 0), (3, 'weight_kg', 'REAL', 0, None, 0), (4, 'is_loved', 'INTEGER', 0, '1', 0)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('ALTER TABLE felines DROP COLUMN is_loved')</b>  # カラムの削除
&lt;sqlite3.Cursor object at 0x000001EDDB477C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('PRAGMA TABLE_INFO(felines)').fetchall()</b>  # すべてのカラムを表示
[(0, 'name', 'TEXT', 1, None, 0), (1, 'birthdate', 'TEXT', 0, None, 0), (2, 'description', 'TEXT',
0, None, 0), (3, 'weight_kg', 'REAL', 0, None, 0)]
</code></pre>
<p class="tx">削除されるカラムに保存されているデータはすべて削除されます。</p>
<p class="tx">テーブル全体を削除したければ、<span class="thesansmonocd_w5regular_">DROP TABLE</span>クエリを実行します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type="table"').fetchall()</b>
[('felines',)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('DROP TABLE felines')</b>  # テーブル全体を削除
&lt;sqlite3.Cursor object at 0x000001EDDB477C40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT name FROM sqlite_schema WHERE type="table"').fetchall()</b>
[]
</code></pre>
<p class="tx">テーブルやカラムの変更は控えめにしてください。これらを変更すると、対応するプログラムのクエリも変更しなければならないからです。</p>
</section>
<section type="division" aria-labelledby="sec23">
<h3 class="h" id="calibre_link-1914"><span id="calibre_link-446"></span><span class="sans_futura_std_bold_b_">外部キーで複数のテーブルを結合する</span></h3>
<p class="tni">SQLiteのテーブル構造はかなり厳格です。例えば、それぞれの行についてカラムの数が定まっています。しかし、現実世界のデータは一つのテーブルに収まるほと単純ではないことがしばしばあります。リレーショナルデータベースでは、複雑なデータを複数のテーブルに保存し、<i class="calibre5">外部キー</i>でテーブルを結合します。</p>
<p class="tx">ネコが接種したワクチンの情報を保存したいとしましょう。ネコが接種するワクチンは複数になる可能性があるので、<span class="thesansmonocd_w5regular_">cats</span>テーブルにカラムを追加するわけにはいきません。さらに、ワクチンの接種ごとに、接種日と担当医師をリスト化したいです。SQLのテーブルはカラムのリストを保存するのに適していません。<span class="thesansmonocd_w5regular_">vaccination1</span>、<span class="thesansmonocd_w5regular_">vaccination2</span>、<span class="thesansmonocd_w5regular_">vaccination3</span>といった名前のカラムを作りたくないです。<span class="thesansmonocd_w5regular_">vaccination1</span>、<span class="thesansmonocd_w5regular_">vaccination2</span>といった名前の変数を作りたくないのと同じです。カラムや変数を作りすぎると、コードが冗長になり、散らかって読みにくくなってしまいます。逆にこの要領で最初に用意するカラムが少なすぎると、必要に応じて追加するときにプログラムを更新しなければならなくなります。</p>
<p class="tx">一つの行に追加するデータの量が変わる場合は、別のテーブルの行にデータを追加するのが理に適っています。そうすれば、別テーブルの行を元のメインとなるテーブルの行から参照できます。<i class="calibre5">sweigartcats.db</i>データベースで、対話型シェルで以下の内容を入力して、<span class="thesansmonocd_w5regular_">vaccinations</span>という2つ目のテーブルを追加してください。</p>
<pre class="pre"><code class="calibre9"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1267" aria-label="405"></span>&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">conn.execute('PRAGMA foreign_keys = ON')</b>
&lt;sqlite3.Cursor object at 0x000001E730AD03C0&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('CREATE TABLE IF NOT EXISTS vaccinations (vaccine TEXT,</b>
<b class="calibre10">date_administered TEXT, administered_by TEXT, cat_id INTEGER,</b>
<b class="calibre10">FOREIGN KEY(cat_id) REFERENCES cats(rowid)) STRICT')</b>
&lt;sqlite3.Cursor object at 0x000001CA42767D40&gt;
</code></pre>
<p class="tx">新しい<span class="thesansmonocd_w5regular_">vaccinations</span>テーブルには、<span class="thesansmonocd_w5regular_">INTEGER</span>型の<span class="thesansmonocd_w5regular_">cat_id</span>という名前のカラムがあります。このカラムの整数値は<span class="thesansmonocd_w5regular_">cats</span>テーブルの行の<span class="thesansmonocd_w5regular_">rowid</span>の値に対応します。別のテーブルの主キーを参照するので、<span class="thesansmonocd_w5regular_">cat_id</span>カラムを<i class="calibre5">外部キー</i>と呼びます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">cats</span>テーブルでは、ネコのZophieの<span class="thesansmonocd_w5regular_">rowid</span>は<span class="thesansmonocd_w5regular_">1</span>です。そのネコのワクチンを記録するには、<span class="thesansmonocd_w5regular_">vaccinations</span>テーブルに<span class="thesansmonocd_w5regular_">cat_id</span>の値が<span class="thesansmonocd_w5regular_">1</span>の行を挿入します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO vaccinations VALUES ("rabies", "2023-06-06", "Dr. Echo", 1)')</b>
&lt;sqlite3.Cursor object at 0x000001CA42767D40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO vaccinations VALUES ("FeLV", "2023-06-06", "Dr. Echo", 1)')</b>
&lt;sqlite3.Cursor object at 0x000001CA42767D40&gt;
&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM vaccinations').fetchall()</b>
[('rabies', '2023-06-06', 'Dr. Echo', 1), ('FeLV', '2023-06-06', 'Dr. Echo', 1)]
</code></pre>
<p class="tx">他のネコについても<span class="thesansmonocd_w5regular_">rowid</span>を使ってワクチンの記録ができます。Mangoのワクチン記録を追加するなら、<span class="thesansmonocd_w5regular_">cats</span>テーブルのMangoの<span class="thesansmonocd_w5regular_">rowid</span>を探し、その値を<span class="thesansmonocd_w5regular_">vaccinations</span>テーブルの<span class="thesansmonocd_w5regular_">cat_id</span>カラムに入れてレコードを追加します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT rowid, * FROM cats WHERE name = "Mango"').fetchall()</b>
[(23, 'Mango', '2017-02-12', 'tuxedo', 6.8)]
&gt;&gt;&gt; <b class="calibre10">conn.execute('INSERT INTO vaccinations VALUES ("rabies", "2023-07-11", "Dr. Echo", 23)')</b>
&lt;sqlite3.Cursor object at 0x000001CA42767D40&gt;
</code></pre>
<p class="tx"><i class="calibre5">inner join（内部結合）</i>と呼ばれる<span class="thesansmonocd_w5regular_">SELECT</span>クエリを実行して、両方のテーブルの行を結合した結果を得ることができます。例えば、対話型シェルに以下の内容を入力して、<span class="thesansmonocd_w5regular_">cats</span>テーブルのデータと<span class="thesansmonocd_w5regular_">vaccinations</span>の行を結合した結果を取得してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('SELECT * FROM cats INNER JOIN vaccinations ON cats.rowid = </b>
<b class="calibre10">vaccinations.cat_id').fetchall()</b>
[('Zophie', '2021-01-24', 'gray tabby', 5.6, 'rabies', '2023-06-06', 'Dr. Echo', 1),
 ('Zophie', '2021-01-24', 'gray tabby', 5.6, 'FeLV', '2023-06-06', 'Dr. Echo', 1),
 ('Mango', '2017-02-12', 'tuxedo', 6.8, 'rabies', '2023-07-11', 'Dr. Echo', 23)]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">cat_id</span>を<span class="thesansmonocd_w5regular_">INTEGER</span>型のカラムにして<span class="thesansmonocd_w5regular_">FOREIGN KEY(cat_id) REFERENCES cats(rowid)</span>構文を使わずに外部キーとして利用することも可能ではありますが、構文を使った外部キーにはデータの整合性を保つための安全装置が組み込まれています。例えば、存在しないネコの<span class="thesansmonocd_w5regular_">cat_id</span>を使ったワクチンレコードの挿入や更新はできません。「孤立した」ワクチンレコードを残してしまわないように、SQLiteでは（catsテーブルの）ネコを削除する前にそのネコのワクチンレコードをすべて削除することが強制されます。</p>
<p class="tx">こうした安全装置はデフォルトで無効になっています。<span class="thesansmonocd_w5regular_">sqlite3.connect()</span>呼び出しのあとで<span class="thesansmonocd_w5regular_">PRAGMA</span>クエリを実行すると有効にできます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">conn.execute('PRAGMA foreign_keys = ON')</b></code></pre>
<p class="tx">外部キーと結合にはさらに発展的な機能がありますが、本書での説明はこれくらいにします。</p>
</section>
<section type="division" aria-labelledby="sec24">
<h3 class="h" id="calibre_link-1915"><span id="calibre_link-447"></span><span class="sans_futura_std_bold_b_">インメモリデータベースとバックアップ</span></h3>
<p class="tni">プログラムから多数のクエリを実行するのであれば、<i class="calibre5">インメモリデータベース</i>を利用するとデータベースの速度を劇的に向上させられる可能性があります。インメモリデータベースは、コンピュータのハードドライブ上のファイルではなく、すべてメモリ上に保存されます。そのおかげで変更がとても高速になります。しかし、<span class="thesansmonocd_w5regular_">backup()</span>メソッドでインメモリデータベースをファイルに保存することを忘れないようにしなければなりません。プログラムが実行中にクラッシュすれば、プログラムの変数に格納された値を失ってしまうのと同じように、インメモリデータベース全体を失ってしまいます。</p>
<p class="tx">以下の例では、インメモリデータベースを作成し、<i class="calibre5">test.db</i>というファイルにデータベースを保存します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">memory_db_conn = sqlite3.connect(':memory:',</b>
<b class="calibre10">isolation_level=None)</b>  # インメモリデータベースを作成
&gt;&gt;&gt; <b class="calibre10">memory_db_conn.execute('CREATE TABLE test (name TEXT, number REAL)')</b>
&lt;sqlite3.Cursor object at 0x000001E730AD0340&gt;
&gt;&gt;&gt; <b class="calibre10">memory_db_conn.execute('INSERT INTO test VALUES ("foo", 3.14)')</b>
&lt;sqlite3.Cursor object at 0x000001D9B0A07EC0&gt;
&gt;&gt;&gt; <b class="calibre10">file_db_conn = sqlite3.connect('test.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">memory_db_conn.backup(file_db_conn)</b>  # データベースをtest.dbファイルに保存
</code></pre>
<p class="tx">SQLiteデータベースファイルのロードも同様に<span class="thesansmonocd_w5regular_">backup()</span>メソッドで行います。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">file_db_conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">memory_db_conn = sqlite3.connect(':memory:', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">file_db_conn.backup(memory_db_conn)</b>
&gt;&gt;&gt; <b class="calibre10">memory_db_conn.execute('SELECT * FROM cats LIMIT 3').fetchall()</b>
[('Zophie', '2021-01-24', 'gray tabby', 5.6), ('Miguel', '2016-12-24',
'siamese', 6.2), ('Jacob', '2022-02-20', 'orange and white', 5.5)]
</code></pre>
<p class="tx">インメモリデータベースには欠点があります。例外を処理せずにプログラムがクラッシュすると、データベースを失ってしまいます。<span class="thesansmonocd_w5regular_">try</span>文でコードを囲んで例外を捕捉し、<span class="thesansmonocd_w5regular_">except</span>文でデータベースをファイルに保存することにより、そのリスクを緩和できます。<span>第4章</span>で<span class="thesansmonocd_w5regular_">try</span>文と<span class="thesansmonocd_w5regular_">except</span>文による例外処理を説明しました。</p>
</section>
<section type="division" aria-labelledby="sec25">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-921" aria-label="407"></span>
<h3 class="h" id="calibre_link-1916"><span id="calibre_link-448"></span><span class="sans_futura_std_bold_b_">データベースを複製する</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">Connection</span>オブジェクトについて<span class="thesansmonocd_w5regular_">iterdump()</span>メソッドを呼び出すと、データベースの複製を取得できます。このメソッドは、データベースを再作成するのに必要なSQLiteのクエリのテキストを生成するイテレータを返します。イテレーターを<span class="thesansmonocd_w5regular_">for</span>ループで使うか<span class="thesansmonocd_w5regular_">list()</span>関数に渡して文字列のリストに変換します。例えば、<i class="calibre5">sweigartcats.db</i>データベースを再作成するのに必要なSQLiteのクエリを取得するには、対話型シェルで以下の内容を入力します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import sqlite3</b>
&gt;&gt;&gt; <b class="calibre10">conn = sqlite3.connect('sweigartcats.db', isolation_level=None)</b>
&gt;&gt;&gt; <b class="calibre10">with open('sweigartcats-queries.txt', 'w', encoding='utf-8') as fileObj:</b>
...     <b class="calibre10">for line in conn.iterdump():</b>
...         <b class="calibre10">fileObj.write(line + '\n')</b>
</code></pre>
<p class="tx">このコードを実行すると、データベースを再作成する以下のSQLiteクエリが書かれた<i class="calibre5">sweigartcats-queries.txt</i>ファイルが作成されます。</p>
<pre class="pre"><code class="calibre9">BEGIN TRANSACTION;
CREATE TABLE "cats" (name TEXT NOT NULL, birthdate TEXT, fur TEXT, weight_kg REAL) STRICT;
INSERT INTO "cats" VALUES('Zophie','2021-01-24','gray tabby',5.6);
INSERT INTO "cats" VALUES('Miguel','2016-12-24','siamese',6.2);
INSERT INTO "cats" VALUES('Jacob','2022-02-20','orange and white',5.5);
<var class="calibre20">--snip--</var>
INSERT INTO "cats" VALUES('Spunky','2015-09-04','gray',5.9);
INSERT INTO "cats" VALUES('Shadow','2021-01-18','calico',6.0);
COMMIT;
</code></pre>
<p class="tx">このクエリのテキストは、まず間違いなく、元のデータベースよりもサイズが大きくなります。他方で、人間にとって読みやすく、PythonのコードやSQLiteアプリ（次に説明します）で複製する前に、簡単に編集できるという利点があります。</p>
</section>
<section type="division" aria-labelledby="sec26">
<h3 class="h" id="calibre_link-1917"><span id="calibre_link-449"></span><span class="sans_futura_std_bold_b_">SQLiteアプリ</span></h3>
<p class="tni">データベースとは本質的には関係のないPythonのコードを書かずに、SQLiteデータベースを直接調べたいことがあるかもしれません。そのためには、<span class="thesansmonocd_w5regular_">sqlite3</span>コマンドをインストールして、ターミナルコマンドラインウィンドウから実行します。<i class="calibre5"><a href="https://sqlite.org/cli.html" class="calibre1">https://<wbr></wbr>sqlite<wbr></wbr>.org<wbr></wbr>/cli<wbr></wbr>.html</a></i>にドキュメントがあります。</p>
<p class="tx">Windowsでは、<i class="calibre5"><a href="https://sqlite.org/download.html" class="calibre1">https://<wbr></wbr>sqlite<wbr></wbr>.org<wbr></wbr>/download<wbr></wbr>.html</a></i>から“A bundle of command line tools for managing SQLite database files”と書かれたファイルをダウンロードして、システムの<span class="thesansmonocd_w5regular_">PATH</span>が通っているフォルダに<i class="calibre5">sqlite3.exe</i>プログラムを配置します。（<span class="thesansmonocd_w5regular_">PATH</span>環境変数とターミナルウィンドウについては<span>第12章</span>を参照してください。）macOSには<span class="thesansmonocd_w5regular_">sqlite3</span>コマンドが最初からインストールされています。Ubuntu Linuxでは、<span class="thesansmonocd_w5regular_">sudo apt install sqlite3</span>でインストールしてください。</p>
<p class="tx">次に、ターミナルウィンドウで、<b class="calibre10">sqlite3 example.db</b>を実行して<i class="calibre5">example.db</i>のデータベースに接続します。このファイルが存在しなければ、<span class="thesansmonocd_w5regular_">sqlite3</span>は空のデータベースでこのファイルを作成します。それから、SQLクエリを入力します。Pythonの<span class="thesansmonocd_w5regular_">conn.execute()</span>に渡したクエリとは異なり、末尾にセミコロンをつけなければなりません。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-981" aria-label="408"></span>例えば、ターミナルウィンドウで以下の内容を入力してください。</p>
<pre class="pre"><code class="calibre9">C:\Users\Al&gt;<b class="calibre10">sqlite3 example.db</b>
SQLite version 3.<var class="calibre20">xx.xx</var>
Enter ".help" for usage hints.
sqlite&gt; <b class="calibre10">CREATE TABLE IF NOT EXISTS cats (name TEXT NOT NULL,</b>
<b class="calibre10">birthdate TEXT, fur TEXT, weight_kg REAL) STRICT;</b>
sqlite&gt; <b class="calibre10">INSERT INTO cats VALUES ('Zophie', '2021-01-24', 'gray tabby', 4.7);</b>
sqlite&gt; <b class="calibre10">SELECT * from cats;</b>
Zophie|2021-01-24|gray tabby|4.7
</code></pre>
<p class="tx">この例からわかるように、<span class="thesansmonocd_w5regular_">sqlite3</span>コマンドラインツールは一種のSQLite対話型シェルを提供し、その<span class="thesansmonocd_w5regular_">sqlite&gt;</span>プロンプトでクエリを入力します。<span class="thesansmonocd_w5regular_">.help</span>コマンドで、<span class="thesansmonocd_w5regular_">.tables</span>（データベースのテーブルを表示する）や<span class="thesansmonocd_w5regular_">.headers</span>（カラムヘッダーのオン／オフを切り替える）などの、さらなるコマンドが表示されます。</p>
<pre class="pre"><code class="calibre9">sqlite&gt; <b class="calibre10">.tables</b>
cats
sqlite&gt; <b class="calibre10">.headers on</b>
sqlite&gt; <b class="calibre10">SELECT * from cats;</b>
name|birthdate|fur|weight_kg
Zophie|2021-01-24|gray tabby|4.7
</code></pre>
<p class="tx">コマンドラインツールが不親切だと思われるなら、SQLiteデータベースをGUIで表示するフリーでオープンソースのアプリもあります。Windows、macOS、Linuxで使えます。</p>
<ul class="ul">
<li class="bl">DB Browser for SQLite (<i class="calibre5"><a href="https://sqlitebrowser.org" class="calibre1">https://<wbr></wbr>sqlitebrowser<wbr></wbr>.org</a></i>)</li>
<li class="bl">SQLite Studio (<i class="calibre5"><a href="https://sqlitestudio.pl" class="calibre1">https://<wbr></wbr>sqlitestudio<wbr></wbr>.pl</a></i>)</li>
<li class="bl">DBeaver Community (<i class="calibre5"><a href="https://dbeaver.io" class="calibre1">https://<wbr></wbr>dbeaver<wbr></wbr>.io</a></i>)</li>
</ul>
<p class="tx">これらのGUIアプリはSQLiteデータベースを扱いやすくしてくれますが、テキストベースのSQLiteクエリの構文を学ぶことには意義があります。</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec27">
<h3 class="h" id="calibre_link-1918"><span id="calibre_link-450"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">コンピュータでは大量のデータを扱えますが、データをテキストファイルやスプレッドシートに保存すると、構造化が不十分です。SQLiteなどのSQLデータベースを活用すると、大量の情報を効率的に保存できるだけでなく、SQL言語で必要なデータを正確に取得できます。</p>
<p class="tx">SQLiteは素晴らしいデータベースで、<span class="thesansmonocd_w5regular_">sqlite3</span>モジュールがPythonの標準ライブラリに同梱されています。SQLiteのSQLには他のリレーショナルデータベースで用いられるSQLと異なる点が多少あるもののほぼ同じなので、SQLiteの学習はデータベース一般へのいい導入になります。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-998" aria-label="409"></span>SQLiteデータベースは専用のサーバーが不要で、一つのファイルに保存されます。複数のテーブルが含まれ（テーブルはスプレッドシートになぞらえられます）、各テーブルには複数のカラムがあります。<span class="thesansmonocd_w5regular_">INSERT</span>、<span class="thesansmonocd_w5regular_">SELECT</span>、<span class="thesansmonocd_w5regular_">UPDATE</span>、<span class="thesansmonocd_w5regular_">DELETE</span>のクエリでCRUD（Create、Read、Update、Delete）操作を行い、テーブルの値を編集します。<span class="thesansmonocd_w5regular_">ALTER TABLE</span>と<span class="thesansmonocd_w5regular_">DROP TABLE</span>のクエリでテーブルやカラム自体を変更できます。外部キーという仕組みで複数テーブルのレコードを結合できます。</p>
<p class="tx">SQLiteやデータベースについては、1つの章で説明できないほどたくさんの事柄があります。SQLデータベース一般についてもっと知りたければ、Anthony DeBarrosの<i class="calibre5">Practical SQL,</i> 2nd edition (No Starch Press, 2022)をおすすめします。</p>
</section>
<section type="division" aria-labelledby="sec28">
<h3 class="h" id="calibre_link-1919"><span id="calibre_link-451"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. <i class="calibre5">example.db</i>という名前のファイルのSQLデータベースについて<span class="thesansmonocd_w5regular_">Connection</span>オブジェクトを取得するPythonのコードを書いてください。</p>
<p class="listnumber">  2. <span class="thesansmonocd_w5regular_">students</span>という名前のテーブルに、<span class="thesansmonocd_w5regular_">first_name</span>、<span class="thesansmonocd_w5regular_">last_name</span>、<span class="thesansmonocd_w5regular_">favorite_color</span>という名前の<span class="thesansmonocd_w5regular_">TEXT</span>型のカラムを作成するPythonのコードを書いてください。</p>
<p class="listnumber">  3. 自動コミットモードでSQLiteデータベースに接続する方法を教えてください。</p>
<p class="listnumber">  4. SQLiteで<span class="thesansmonocd_w5regular_">INTEGER</span>型のデータと<span class="thesansmonocd_w5regular_">REAL</span>型のデータはどう違いますか？</p>
<p class="listnumber">  5. 厳格モードを設定するとテーブルはどうなりますか？</p>
<p class="listnumber">  6. <span class="thesansmonocd_w5regular_">'SELECT * FROM cats'</span>というクエリ中の<span class="thesansmonocd_w5regular_">*</span>はどういう意味ですか？</p>
<p class="listnumber">  7. CRUDは何の略ですか？</p>
<p class="listnumber">  8. ACIDは何の略ですか？</p>
<p class="listnumber">  9. テーブルに新しいレコードを追加するクエリを書いてください。</p>
<p class="listnumber">10. テーブルからレコードを削除するクエリを書いてください。</p>
<p class="listnumber">11. <span class="thesansmonocd_w5regular_">UPDATE</span>クエリで<span class="thesansmonocd_w5regular_">WHERE</span>節を指定しないとどうなりますか？</p>
<p class="listnumber">12. インデックスとは何ですか？　<span class="thesansmonocd_w5regular_">cats</span>という名前のテーブルの<span class="thesansmonocd_w5regular_">birthdate</span>という名前のカラムにインデックスを作成するコードはどのように書きますか？</p>
<p class="listnumber">13. 外部キーとは何ですか？</p>
<p class="listnumber">14. <span class="thesansmonocd_w5regular_">cats</span>という名前のテーブルを削除するコードを書いてください。</p>
<p class="listnumber">15. インメモリデータベースを作成する際に「ファイル名」をどう指定しますか？</p>
<p class="listnumber">16. データベースを複製する方法を教えてください。</p>
</section>
<section type="division" aria-labelledby="sec29">
<h3 class="h" id="calibre_link-1920"><span id="calibre_link-452"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec30">
<h4 class="h1" id="calibre_link-1921"><span id="calibre_link-453"></span><span class="sans_futura_std_heavy_oblique_bi_">ネコのワクチン接種チェック</span></h4>
<p class="tni"><i class="calibre5"><a href="https://nostarch.com/automate-boring-stuff-python-3rd-edition" class="calibre1">https://<wbr></wbr>nostarch<wbr></wbr>.com<wbr></wbr>/automate<wbr></wbr>-boring<wbr></wbr>-stuff<wbr></wbr>-python<wbr></wbr>-3rd<wbr></wbr>-edition</a></i>の本書のオンライン素材から<i class="calibre5">sweigartcats.db</i>データベースをダウンロードしてください。このデータベースを開いて、<span class="thesansmonocd_w5regular_">'rabies'</span>、<span class="thesansmonocd_w5regular_">'FeLV'</span>、<span class="thesansmonocd_w5regular_">'FVRCP'</span>という名前のワクチンを接種していないネコをすべてリストアップするプログラムを書いてください。また、ネコの生年月日よりも前にワクチンを接種したとされている誤りを探してください。</p>
</section>
<section type="division" aria-labelledby="sec31">
<h4 class="h1" id="calibre_link-1922"><span id="calibre_link-454"></span><span class="sans_futura_std_heavy_oblique_bi_">食材データベース</span></h4>
<p class="tni">食事と材料の2つのテーブルを作成するプログラムを書きます。以下のSQLクエリを使ってください。</p>
<pre class="pre"><code class="calibre9">CREATE TABLE IF NOT EXISTS meals (name TEXT) STRICT
CREATE TABLE IF NOT EXISTS ingredients (name TEXT,
meal_id INTEGER, FOREIGN KEY(meal_id) REFERENCES meals
(rowid)) STRICT
</code></pre>
<p class="tx">ユーザーに入力を求めるプログラムを書きます。ユーザーが<span class="thesansmonocd_w5regular_">'quit'</span>と入力すると、プログラムは終了します。ユーザーは、<span class="thesansmonocd_w5regular_">'meal:ingredient1,ingredient2'</span>のように、食事の名前のあとにコロンで区切って材料を入力することができます。そうするとその食事と材料を<span class="thesansmonocd_w5regular_">meals</span>テーブルと<span class="thesansmonocd_w5regular_">ingredients</span>テーブルに保存します。</p>
<p class="tx">ユーザーは、食事の名前ないし材料の名前を入力することもできます。<span class="thesansmonocd_w5regular_">meals</span>テーブルにその名前が存在すれば、プログラムはその食事の材料を出力します。<span class="thesansmonocd_w5regular_">ingredients</span>テーブルにその名前が存在すれば、プログラムはその材料を使う食事を出力します。例えば、このプログラムの出力は以下のようになります。</p>
<pre class="pre"><code class="calibre9">&gt; <b class="calibre10">onigiri:rice,nori,salt,sesame seeds</b>
Meal added: onigiri
&gt; <b class="calibre10">chicken and rice:chicken,rice,cream of chicken soup</b>
Meal added: chicken and rice
&gt; <b class="calibre10">onigiri</b>
Ingredients of onigiri:
  rice
  nori
  salt
  sesame seeds
&gt; <b class="calibre10">chicken</b>
Meals that use chicken:
  chicken and rice
&gt; <b class="calibre10">rice</b>
Meals that use rice:
  onigiri
chicken and rice
&gt; <b class="calibre10">quit</b>
</code></pre>
</section>
</section>
</section>
</div>


</div>



</body></html>