<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-145">
<section type="chapter" role="doc-chapter" aria-labelledby="ch7">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-848" aria-label="139"></span>
<hgroup>
<h2 class="title" id="calibre_link-1566">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">7</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">辞書とデータの構造化</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">本章では辞書型を取り上げます。辞書を使うと、データのアクセスや整理を柔軟に管理できます。前章で学んだリストと組み合わせて、チェス盤をモデル化するデータ構造を作成します。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1567"><span id="calibre_link-146"></span><span class="sans_futura_std_bold_b_">辞書型</span></h3>
<p class="tni">リストと同じように、<i class="calibre5">辞書</i>はミュータブルな複数の値の集合です。しかし、リストのインデックスとは異なり、辞書のインデックスには整数に限らずいろいろなデータ型が使えます。辞書のインデックスは<i class="calibre5">キー</i>と呼ばれ、値と関連付けられたものは<i class="calibre5">キーと値のペア（key-value pair）</i>と呼ばれます。</p>
<p class="tx">コードでは、波かっこ（<span class="thesansmonocd_w5regular_">{}</span>）で辞書を作成します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">my_cat = {'size': 'fat', 'color': 'gray', 'age': 17}</b></code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1111" aria-label="140"></span>これは辞書を変数<span class="thesansmonocd_w5regular_">my_cat</span>に代入します。この辞書のキーは<span class="thesansmonocd_w5regular_">'size'</span>、<span class="thesansmonocd_w5regular_">'color'</span>、<span class="thesansmonocd_w5regular_">'age'</span>です。そのキーに対応する値はそれぞれ<span class="thesansmonocd_w5regular_">'fat'</span>、<span class="thesansmonocd_w5regular_">'gray'</span>、<span class="thesansmonocd_w5regular_">17</span>です。キーを指定すれば値にアクセスできます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">my_cat['size']</b>
'fat'
&gt;&gt;&gt; <b class="calibre10">'My cat has ' + my_cat['color'] + ' fur.'</b>
'My cat has gray fur.'
</code></pre>
<p class="tx">辞書を使うと、何らかの対象についての複数のデータを一つの変数に格納できます。変数<span class="thesansmonocd_w5regular_">my_cat</span>は、私のネコについての3つの異なる文字列を格納しています。この辞書を引数や返り値として使えるので、3つの別々の変数を作らなくてすみます。</p>
<p class="tx">辞書は、リストのインデックスのように、キーに整数値を使うことができますが、<span class="thesansmonocd_w5regular_">0</span>で始める必要性はなく、どの数値でも使えます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = {12345: 'Luggage Combination', 42: 'The Answer'}</b>
&gt;&gt;&gt; <b class="calibre10">spam[12345]</b>
'Luggage Combination'
&gt;&gt;&gt; <b class="calibre10">spam[42]</b>
'The Answer'
&gt;&gt;&gt; <b class="calibre10">spam[0]</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
KeyError: 0
</code></pre>
<p class="tx">辞書にあるのはキーで、インデックスはありません。この例では、辞書<span class="thesansmonocd_w5regular_">spam</span>は整数のキー<span class="thesansmonocd_w5regular_">12345</span>と<span class="thesansmonocd_w5regular_">42</span>を持っていますが、リストのように<span class="thesansmonocd_w5regular_">0</span>から<span class="thesansmonocd_w5regular_">41</span>のインデックスがあるわけではありません。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1568"><span id="calibre_link-147"></span><span class="sans_futura_std_heavy_oblique_bi_">辞書とリストの比較</span></h4>
<p class="tni">リストとは異なり、辞書の中に入っている要素に順番はありません。<span class="thesansmonocd_w5regular_">spam</span>という名前のリストの最初の要素は<span class="thesansmonocd_w5regular_">spam[0]</span>ですが、辞書には「最初の」要素という発想がありません。2つのリストが同じかどうかを決めるには順番が関係しますが、辞書のキーと値のペアはどの順番で作成しても同じです。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = ['cats', 'dogs', 'moose']</b>
&gt;&gt;&gt; <b class="calibre10">bacon = ['dogs', 'moose', 'cats']</b>
&gt;&gt;&gt; <b class="calibre10">spam == bacon</b>  # リストの要素は順番が関係ある
False
&gt;&gt;&gt; <b class="calibre10">eggs = {'name': 'Zophie', 'species': 'cat', 'age': '8'}</b>
&gt;&gt;&gt; <b class="calibre10">ham = {'species': 'cat', 'age': '8', 'name': 'Zophie'}</b>
&gt;&gt;&gt; <b class="calibre10">eggs == ham</b>  # 辞書のキーと値は順番が関係ない
True
</code></pre>
<p class="tx">辞書<span class="thesansmonocd_w5regular_">eggs</span>と<span class="thesansmonocd_w5regular_">ham</span>は、キーと値のペアを違う順番で作成したにもかかわらず、同じ値です。辞書には順番がありませんから、シーケンス型ではなく、リストのようにスライスを作成することはできません。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-968" aria-label="141"></span>辞書に存在しないキーにアクセスしようとすると、<span class="thesansmonocd_w5regular_">KeyError</span>エラーになります。リストの<span class="thesansmonocd_w5regular_">IndexError</span>エラーと似ています。対話型シェルに以下のコードを入力して、<span class="thesansmonocd_w5regular_">'color'</span>キーが存在しないためにエラーメッセージが表示されるのを確認してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = {'name': 'Zophie', 'age': 7}</b>
&gt;&gt;&gt; <b class="calibre10">spam['color']</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    spam['color']
KeyError: 'color'
</code></pre>
<p class="tx">辞書には順番がありませんが、自由にキーを設定できるので、データを整理できます。友人の誕生日のデータを格納したいとしましょう。友人の名前をキー、その人の誕生日を値として辞書を作成します。新しいファイルエディタウィンドウを開いて、以下のコードを<i class="calibre5">birthdays.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9"><span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> birthdays = {'Alice': 'Apr 1', 'Bob': 'Dec 12', 'Carol': 'Mar 4'}

while True:
    print('Enter a name: (blank to quit)')
    name = input()
    if name == '':
        break

  <span class="code_codeannotation" aria-label="annotation2">❷</span> if name in birthdays:
      <span class="code_codeannotation" aria-label="annotation3">❸</span> print(birthdays[name] + ' is the birthday of ' + name)
    else:
        print('I do not have birthday information for ' + name)
        print('What is their birthday?')
        bday = input()
      <span class="code_codeannotation" aria-label="annotation4">❹</span> birthdays[name] = bday
        print('Birthday database updated.')
</code></pre>
<p class="tx">このコードでは、最初に辞書を作成して、<span class="thesansmonocd_w5regular_">birthdays</span>という変数に保存しています(<span class="codeannotation" aria-label="annotation1">❶</span>)。リストと同じように、<span class="thesansmonocd_w5regular_">in</span>キーワードで、入力した名前のキーが辞書の中に存在するかを確かめられます(<span class="codeannotation" aria-label="annotation2">❷</span>)。その名前が辞書の中に存在するなら、関連付けられた値に角かっこでアクセスできます(<span class="codeannotation" aria-label="annotation3">❸</span>)。その名前が辞書の中に存在しないなら、同じく角かっこと代入演算子で値を追加できます(<span class="codeannotation" aria-label="annotation4">❹</span>)。</p>
<p class="tx">このプログラムを実行すると、次のようになります。</p>
<pre class="pre"><code class="calibre9">Enter a name: (blank to quit)
<b class="calibre10">Alice</b>
Apr 1 is the birthday of Alice
Enter a name: (blank to quit)
<b class="calibre10">Eve</b>
I do not have birthday information for Eve
What is their birthday?
<b class="calibre10">Dec 5</b>
Birthday database updated.
Enter a name: (blank to quit)
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-917" aria-label="142"></span><b class="calibre10">Eve</b>
Dec 5 is the birthday of Eve
Enter a name: (blank to quit)
</code></pre>
<p class="tx">もちろん、入力したデータはプログラム終了時に失われてしまいます。ハードドライブのファイルにデータを保存する方法は<span>第10章</span>で説明します。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h4 class="h1" id="calibre_link-1569"><span id="calibre_link-148"></span><span class="sans_futura_std_heavy_oblique_bi_">キーと値を返す</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">keys()</span>、<span class="thesansmonocd_w5regular_">values()</span>、<span class="thesansmonocd_w5regular_">items()</span>という3つの辞書メソッドがあります。それぞれ、辞書のキー、値、キーと値のペアをリストのような形式で返します。これらのメソッドが返す値は本物のリストではありません。修正できませんし、<span class="thesansmonocd_w5regular_">append()</span>メソッドもありません。しかし、これらのデータ型（それぞれ<span class="thesansmonocd_w5regular_">dict_keys</span>、<span class="thesansmonocd_w5regular_">dict_values</span>、<span class="thesansmonocd_w5regular_">dict_items</span>）は、<span class="thesansmonocd_w5regular_">for</span>ループに<i class="calibre5">使えます</i>。対話型シェルでこれらのメソッドの動作を確認してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = {'color': 'red', 'age': 42}</b>
&gt;&gt;&gt; <b class="calibre10">for v in spam.values():</b>
...     <b class="calibre10">print(v)</b>

red
42
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループが辞書<span class="thesansmonocd_w5regular_">spam</span>の値を一つずつ反復しています。<span class="thesansmonocd_w5regular_">for</span>ループで、キーの反復もキーと値の反復もできます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">for k in spam.keys():</b>
...     <b class="calibre10">print(k)</b>

color
age
&gt;&gt;&gt; <b class="calibre10">'color' in spam.keys()</b>
True
&gt;&gt;&gt; <b class="calibre10">'age' not in spam.keys()</b>
False
&gt;&gt;&gt; <b class="calibre10">'red' in spam.values()</b>
True
&gt;&gt;&gt; <b class="calibre10">for i in spam.items():</b>
...     <b class="calibre10">print(i)</b>

('color', 'red')
('age', 42)
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">keys()</span>、<span class="thesansmonocd_w5regular_">values()</span>、<span class="thesansmonocd_w5regular_">items()</span>メソッドを使うときに、<span class="thesansmonocd_w5regular_">for</span>ループは辞書のキー、値、キーと値のペアを反復します。ある値が辞書のキーまたは値の中に存在するかどうかを<span class="thesansmonocd_w5regular_">in</span>演算子と<span class="thesansmonocd_w5regular_">not in</span>演算子で調べられます。<span class="thesansmonocd_w5regular_">items()</span>メソッドが返す値<span class="thesansmonocd_w5regular_">dict_items</span>の中に入っているのは、キーと値のタプルであることに注意してください。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1107" aria-label="143"></span>辞書そのものに<span class="thesansmonocd_w5regular_">in</span>演算子または<span class="thesansmonocd_w5regular_">not in</span>演算子を使うと、ある値がキーに存在するかを調べることになります。<span class="thesansmonocd_w5regular_">keys()</span>メソッドを使うのと等しい結果になります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'color' in spam</b>
True
&gt;&gt;&gt; <b class="calibre10">'color' in spam.keys()</b>
True
</code></pre>
<p class="tx">これらのメソッドが返す値から本物のリストがほしければ、これらのメソッドが返すリストのような値を<span class="thesansmonocd_w5regular_">list()</span>関数に渡してください。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = {'color': 'red', 'age': 42}</b>
&gt;&gt;&gt; <b class="calibre10">spam.keys()</b>  # リストのようなdict_keys値を返す
dict_keys(['color', 'age'])
&gt;&gt;&gt; <b class="calibre10">list(spam.keys())</b>  # 本物のリストを返す
['color', 'age']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">list(spam.keys())</span>の行は<span class="thesansmonocd_w5regular_">keys()</span>から返された<span class="thesansmonocd_w5regular_">dict_keys</span>値を<span class="thesansmonocd_w5regular_">list()</span>に渡しています。そうすれば<span class="thesansmonocd_w5regular_">['color', 'age']</span>というリスト値が返されます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループ内でキーと値を別々の変数に代入するときには、多重代入が使えます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = {'color': 'red', 'age': 42}</b>
&gt;&gt;&gt; <b class="calibre10">for k, v in spam.items():</b>
<b class="calibre10">...     print('Key: ' + str(k) + ' Value: ' + str(v))</b>

Key: color Value: red
Key: age Value: 42
</code></pre>
<p class="tx">このコードでは、キーが <span class="thesansmonocd_w5regular_">'color'</span>と<span class="thesansmonocd_w5regular_">'age'</span>、値が<span class="thesansmonocd_w5regular_">'red'</span>と<span class="thesansmonocd_w5regular_">42</span>である辞書を作成しています。<span class="thesansmonocd_w5regular_">for</span>ループでは<span class="thesansmonocd_w5regular_">items()</span>メソッドが返す<span class="thesansmonocd_w5regular_">('color', 'red')</span>と<span class="thesansmonocd_w5regular_">('age', 42)</span>のタプルを反復処理します。2つの変数<span class="thesansmonocd_w5regular_">k</span>と<span class="thesansmonocd_w5regular_">v</span>には、このタプルから最初の値（キー）と2番目の値（値）がそれぞれ代入されます。ループの本体ではキーと値のペアから<span class="thesansmonocd_w5regular_">k</span>と<span class="thesansmonocd_w5regular_">v</span>を表示しています。</p>
<p class="tx">キーに使える値はたくさんありますが、リストと辞書をキーとして使うことはできません。リストと辞書は<i class="calibre5">ハッシュ不可能</i>です（本書ではこれ以上詳しく扱いません）。辞書のキーとしてリストを使いたいと思ったら、タプルを使うようにしてください。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1570"><span id="calibre_link-149"></span><span class="sans_futura_std_heavy_oblique_bi_">キーの存在確認</span></h4>
<p class="tni">キーを使って値にアクセスする前にそのキーが辞書の中に存在するかどうかを確認するのは面倒です。幸いなことに、辞書には<span class="thesansmonocd_w5regular_">get()</span>メソッドがあります。キーとデフォルト値の2つの引数を取って、キーが存在すればそのキーに対応する値を、キーが存在しなければデフォルト値を返してくれます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1108" aria-label="144"></span>以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">picnic_items = {'apples': 5, 'cups': 2}</b>
&gt;&gt;&gt; <b class="calibre10">'I am bringing ' + str(picnic_items.get('cups', 0)) + ' cups.'</b>
'I am bringing 2 cups.'
&gt;&gt;&gt; <b class="calibre10">'I am bringing ' + str(picnic_items.get('eggs', 0)) + ' eggs.'</b>
'I am bringing 0 eggs.'
</code></pre>
<p class="tx">辞書<span class="thesansmonocd_w5regular_">picnic_items</span>にキー<span class="thesansmonocd_w5regular_">'eggs'</span>は存在しませんから、<span class="thesansmonocd_w5regular_">get()</span>メソッドはデフォルト値の<span class="thesansmonocd_w5regular_">0</span>を返します。<span class="thesansmonocd_w5regular_">get()</span>を使わなければ、以下のように、このコードはエラーになります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">picnic_items = {'apples': 5, 'cups': 2}</b>
&gt;&gt;&gt; <b class="calibre10">'I am bringing ' + str(picnic_items['eggs']) + ' eggs.'</b>
Traceback (most recent call last):
  File "&lt;python-input-0&gt;", line 1, in &lt;module&gt;
    'I am bringing ' + str(picnic_items['eggs']) + ' eggs.'
KeyError: 'eggs'
</code></pre>
<p class="tx">キーを使って値にアクセスする前にそのキーの存在確認をすれば、プログラムがエラーでクラッシュするのを防げます。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1571"><span id="calibre_link-150"></span><span class="sans_futura_std_heavy_oblique_bi_">デフォルト値の設定</span></h4>
<p class="tni">辞書の中に特定のキーが存在しなければそのキーに対して何らかの値を設定する、という必要に迫られる場面がよくあります。次のようなコードを書こうとするでしょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = {'name': 'Pooka', 'age': 5}</b>
&gt;&gt;&gt; <b class="calibre10">if 'color' not in spam:</b>
...     <b class="calibre10">spam['color'] = 'black'</b>
...
&gt;&gt;&gt; <b class="calibre10">spam</b>
{'name': 'Pooka', 'age': 5, 'color': 'black'}
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">setdefault()</span>メソッドを使うとこれを1行で表現できます。第一引数はキー、第二引数はそのキーが存在しない場合に設定するデフォルト値です。キーが存在すれば、<span class="thesansmonocd_w5regular_">setdefault()</span>メソッドはそのキーに対応する値を返します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = {'name': 'Pooka', 'age': 5}</b>
&gt;&gt;&gt; <b class="calibre10">spam.setdefault('color', 'black')  </b>#  キー'color'に値'black'を設定する
'black'
&gt;&gt;&gt; <b class="calibre10">spam</b>
{'name': 'Pooka', 'age': 5, 'color': 'black'}
&gt;&gt;&gt; <b class="calibre10">spam.setdefault('color', 'white')  </b># 何もしない
'black'
&gt;&gt;&gt; <b class="calibre10">spam</b>
{'name': 'Pooka', 'age': 5, 'color': 'black'}
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-895" aria-label="145"></span>最初に<span class="thesansmonocd_w5regular_">setdefault()</span>を呼び出したときは、辞書<span class="thesansmonocd_w5regular_">spam</span>が<span class="thesansmonocd_w5regular_">{'color': 'black', 'age': 5, 'name': 'Pooka'}</span>へと変化します。このメソッドは、今回キー<span class="thesansmonocd_w5regular_">'color'</span>に設定した<span class="thesansmonocd_w5regular_">'black'</span>という値を返します。次に<span class="thesansmonocd_w5regular_">spam.setdefault('color', 'white')</span>を呼び出したときは、そのキーの値は<span class="thesansmonocd_w5regular_">'white'</span>へと変わることが<i class="calibre5">ありません</i>。<span class="thesansmonocd_w5regular_">spam</span>には<span class="thesansmonocd_w5regular_">'color'</span>という名前のキーがすでに存在するからです。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">setdefault()</span>メソッドは、キーを確実に存在させられる簡便な書き方です。文字列の中にある各文字の出現回数をカウントする短いプログラムを書いてみましょう。次のコードを<i class="calibre5">characterCount.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
count = {}

for character in message:
    count.setdefault(character, 0) <span class="code_codeannotation" aria-label="annotation1">❶</span>
    count[character] = count[character] + 1 <span class="code_codeannotation" aria-label="annotation2">❷</span>

print(count)   
</code></pre>
<p class="tx">このプログラムは、変数<span class="thesansmonocd_w5regular_">message</span>に格納されている文字列を1文字ずつループして、それぞれの文字が何回出現するかをカウントします。<span class="thesansmonocd_w5regular_">setdefault()</span>メソッドを呼び出しているので(<span class="codeannotation" aria-label="annotation1">❶</span>)、そのキーが辞書<span class="thesansmonocd_w5regular_">count</span>に存在することを保証できます（デフォルト値は<span class="thesansmonocd_w5regular_">0</span>）。よって、このプログラムの<span class="thesansmonocd_w5regular_">count[character]</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">count[character]</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">1</span>の行で<span class="thesansmonocd_w5regular_">KeyError</span>エラーになることはありません(<span class="codeannotation" aria-label="annotation2">❷</span>)。このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">{'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6,
'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1,
'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}
</code></pre>
<p class="tx">出力から、小文字の<i class="calibre5">c</i>が3回出現し、スペースが13回出現し、大文字の<i class="calibre5">A</i>が1回出現することがわかります。このプログラムは、変数<span class="thesansmonocd_w5regular_">message</span>に格納されている文字列が何であっても、数百万文字であっても、動作します。</p>
</section>
</section>
<section type="division" aria-labelledby="sec6">
<h3 class="h" id="calibre_link-1572"><span id="calibre_link-151"></span><span class="sans_futura_std_bold_b_">データ構造を用いた現実世界のモデル化</span></h3>
<p class="tni">インターネット登場以前でも、世界の反対側にいる人とチェスの対局を行うことはできました。
両プレイヤーが自宅にチェス盤を用意し、駒の動きを書いたハガキを郵送し合いました。そのためには、プレイヤーが盤面と駒の動きを一義的に記述する方法が必要でした。</p>
<p class="tx">図7-1に示すように、<i class="calibre5">代数式記譜法</i>では、チェス盤のマス目を数字とアルファベットの座標で特定します。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1573" aria-label="146"></span>
<figure class="img"><img class="img2" id="calibre_link-720" src="images/000102.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 7-1：代数式記譜法によるチェス盤の座標</span></p></figcaption>
</figure>
<p class="tx">チェスの駒は文字で表現します。キングは<i class="calibre5">K</i>、クイーンは<i class="calibre5">Q</i> 、ルークは<i class="calibre5">R</i> 、ビショップは<i class="calibre5">B</i>、ナイトは<i class="calibre5">N</i>です。動きを記述するには、駒を表す文字と移動先を表す座標が必要です。これらを用いて1回の手番を記述します（白が先手です）。例えば、"<i class="calibre5">2. Nf3 Nc6</i>"は、2手目で、白のナイトがf3に移動し、黒のナイトがc6に移動したことを示します（訳注：チェスでは先手と後手がそれぞれ1回ずつ駒を動かして1手と数えます）。</p>
<p class="tx">代数式記譜法にはもう少し細かいルールがありますが、チェス盤に向かい合っていなくてもチェスの対局を一義的に記述できることが要点です。世界の反対側にいる人とでも対局できます。記憶力がよければ物理的なチェス盤と駒がなくても構いません。郵送物に書かれた動きを読み取り、頭の中で盤面を更新します。</p>
<p class="tx">コンピュータは記憶力がいいです。現代のコンピュータなら、<span class="thesansmonocd_w5regular_">'2. Nf3 Nc6'</span>のような文字列を、何十億でもたやすく保存できます。このようにして、コンピュータは物理的なチェス盤なしにチェスを対局します。チェス盤を表すデータをモデル化し、そのモデルでチェスの対局をシミュレートするコードを書きます。</p>
<p class="tx">ここでリストと辞書を使えます。例えば、Pythonの辞書<span class="thesansmonocd_w5regular_">{'h1': 'bK', 'c6': 'wQ', 'g2': 'bB', 'h5': 'bQ', 'e3': 'wK'}</span>が図7-2の盤面を表すような記譜法が考えられます。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1011" aria-label="147"></span>
<figure class="img"><img class="img2" id="calibre_link-721" src="images/000103.jpg" alt="" />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 7-2：辞書{'h1': 'bK', 'c6': 'wQ', 'g2': 'bB', 'h5': 'bQ', 'e3': 'wK'}がモデル化するチェス盤</span></p></figcaption>
</figure>
<p class="tx">このデータ構造を使って、対話的なチェスプログラムを作成しましょう。</p>
<p class="ph"><span id="calibre_link-152"></span><span class="sans_futura_std_heavy_b_">プロジェクト 1：対話的なチェス盤シミュレーター</span></p>
<p class="tni">最初期のコンピュータでも人間より計算が速かったです。しかし、当時の人々は、チェスが知性を示すと考えていました（訳注：今ではチェスで人間がコンピュータに勝つことはできませんが、当時はチェスでコンピュータが人間に勝てないことが人間の知性を示していると考えられていたということです）。ここでチェス対局プログラムを作成するつもりはありません（それだけで一冊の本になってしまいます）。これまでに学んできたことを活用して、対話的なチェス盤プログラムを作成します。</p>
<p class="tx">このプログラムではチェスのルールを知らなくても大丈夫です。チェスでは、8×8の盤面で、白と黒の駒を使うということを知っていれば十分です。駒には、ポーン、ナイト、ビショップ、ルーク、クイーン、キングがあります。盤の左上と右下のマス目が白です。このプログラムでは出力ウィンドウの地の色が黒だと想定します（紙では地の色が白ですが）。このチェス盤プログラムには駒を配置できます。駒の動き方は問いません。図7-3に示すように、チェス盤を「描画」するのにテキストを使います。</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1198" aria-label="148"></span>
<figure class="img"><img class="img1" id="calibre_link-722" src="images/000104.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 7-3：テキストベースのチェス盤プログラムの出力</span></p></figcaption>
</figure>
<p class="tx">グラフィックスがあればきれいで見やすくなるでしょうが、ここでは見た目にこだわりません。テキストベースにすれば<span class="thesansmonocd_w5regular_">print()</span>関数だけでプログラムを表現でき、Pygameのようなグラフィックライブラリ（<i class="calibre5">Invent Your Own Computer Games with Python</i> [No Starch Press, 2016]で紹介しました）をインストールする必要がなくなります。</p>
<p class="tx">チェス盤と駒の配置を表現するデータ構造の設計から始めます。前節の例が使えます。チェス盤は、マス目を表す文字列の<span class="thesansmonocd_w5regular_">'a1'</span>から<span class="thesansmonocd_w5regular_">'h8'</span>をキーとするPythonの辞書で表現できます。マス目を表す文字列は必ず2文字であり、アルファベットは小文字で、そのあとに数字が続くことに注目してください。この特徴が重要で、あとで示すコードで活用します。</p>
<p class="tx">駒を表すのにも2文字を使います。1文字目は小文字の<span class="thesansmonocd_w5regular_">'w'</span>か<span class="thesansmonocd_w5regular_">'b'</span>で、白（先手）か黒（後手）を示します。2文字目は大文字の<span class="thesansmonocd_w5regular_">'P'</span>、<span class="thesansmonocd_w5regular_">'N'</span>、<span class="thesansmonocd_w5regular_">'B'</span>、<span class="thesansmonocd_w5regular_">'R'</span>、<span class="thesansmonocd_w5regular_">'Q'</span>、<span class="thesansmonocd_w5regular_">'K'</span>で、駒の種類を示します。図7-4に駒とその表し方を示しました。</p>
<figure class="img"><img class="img3" id="calibre_link-723" src="images/000105.jpg" alt=" " />
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_i_">図 7-4：チェスの駒を表す2文字の文字列</span></p></figcaption>
</figure>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1049" aria-label="149"></span>Pythonの辞書のキーがチェス盤のマス目を示し、値がそのマス目にある駒を示します。辞書にキーが存在しなければ、そのマス目に駒はありません。辞書はこうした情報を保存するのに適しています。辞書で同じキーは一度しか使えないのが、チェス盤で同じマス目には1つの駒しか配置できないことに対応します。</p>
<section type="division" aria-labelledby="sec7">
<h4 class="h1" id="calibre_link-1574"><span id="calibre_link-153"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ 1：プログラムの設定</span></h4>
<p class="tni">このプログラムの最初の部分では、<span class="thesansmonocd_w5regular_">exit()</span>関数を使うための<span class="thesansmonocd_w5regular_">sys</span>モジュールと、<span class="thesansmonocd_w5regular_">copy()</span>関数を使うための<span class="thesansmonocd_w5regular_">copy</span>モジュールをインポートしています。チェスの対局開始時には、白と黒のプレイヤーはそれぞれ16個の駒を持っています。定数<span class="thesansmonocd_w5regular_">STARTING_PIECES</span>が対局開始時の駒の配置を記述した辞書を保持します。</p>
<pre class="pre"><code class="calibre9">import sys, copy

STARTING_PIECES = {'a8': 'bR', 'b8': 'bN', 'c8': 'bB', 'd8': 'bQ',
'e8': 'bK', 'f8': 'bB', 'g8': 'bN', 'h8': 'bR', 'a7': 'bP', 'b7': 'bP',
'c7': 'bP', 'd7': 'bP', 'e7': 'bP', 'f7': 'bP', 'g7': 'bP', 'h7': 'bP',
'a1': 'wR', 'b1': 'wN', 'c1': 'wB', 'd1': 'wQ', 'e1': 'wK', 'f1': 'wB',
'g1': 'wN', 'h1': 'wR', 'a2': 'wP', 'b2': 'wP', 'c2': 'wP', 'd2': 'wP',
'e2': 'wP', 'f2': 'wP', 'g2': 'wP', 'h2': 'wP'}
</code></pre>
<p class="tx">（このコードを入力するのはやや面倒なので、<i class="calibre5"><a href="https://autbor.com/3/chessboard.py" class="calibre1">https://<wbr></wbr>autbor<wbr></wbr>.com<wbr></wbr>/3<wbr></wbr>/chessboard<wbr></wbr>.py</a></i>からコピーしてください。）チェス盤を対局開始時の状態にリセットする必要が生じたら、<span class="thesansmonocd_w5regular_">copy.copy()</span>関数で<span class="thesansmonocd_w5regular_">STARTING_PIECES</span>をコピーできます。</p>
</section>
<section type="division" aria-labelledby="sec8">
<h4 class="h1" id="calibre_link-1575"><span id="calibre_link-154"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ 2：チェス盤テンプレートの作成</span></h4>
<p class="tni">変数<span class="thesansmonocd_w5regular_">BOARD_TEMPLATE</span>はチェス盤のテンプレートの働きをする文字列を格納します。このプログラムでは、チェス盤を表示する前に、それぞれの駒を表す文字列を挿入します。三重引用符を使うと、コードの複数行にまたがる<i class="calibre5">複数行文字列</i>を作成できます。複数行文字列は三重引用符で終わります。このPythonの構文を利用すると、<span class="thesansmonocd_w5regular_">\n</span>エスケープ文字を使って全部を1行で書くよりも見やすいです。複数行文字列については次章でさらに詳しく説明します。</p>
<pre class="pre"><code class="calibre9"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-849" aria-label="150"></span>BOARD_TEMPLATE = """
    a    b    c    d    e    f    g    h
   <span aria-hidden="true">____</span> <span aria-hidden="true">____</span> <span aria-hidden="true">____</span> <span aria-hidden="true">____</span> <span aria-hidden="true">____</span> <span aria-hidden="true">____</span> <span aria-hidden="true">____</span> <span aria-hidden="true">____</span>
  ||||||    ||||||    ||||||    ||||||    |
8 ||{}|| {} ||{}|| {} ||{}|| {} ||{}|| {} |
  ||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>|
  |    ||||||    ||||||    ||||||    ||||||
7 | {} ||{}|| {} ||{}|| {} ||{}|| {} ||{}||
  |<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||
  ||||||    ||||||    ||||||    ||||||    |
6 ||{}|| {} ||{}|| {} ||{}|| {} ||{}|| {} |
  ||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>|
  |    ||||||    ||||||    ||||||    ||||||
5 | {} ||{}|| {} ||{}|| {} ||{}|| {} ||{}||
  |<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||
  ||||||    ||||||    ||||||    ||||||    |
4 ||{}|| {} ||{}|| {} ||{}|| {} ||{}|| {} |
  ||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>|
  |    ||||||    ||||||    ||||||    ||||||
3 | {} ||{}|| {} ||{}|| {} ||{}|| {} ||{}||
  |<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||
  ||||||    ||||||    ||||||    ||||||    |
2 ||{}|| {} ||{}|| {} ||{}|| {} ||{}|| {} |
  ||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>|
  |    ||||||    ||||||    ||||||    ||||||
1 | {} ||{}|| {} ||{}|| {} ||{}|| {} ||{}||
  |<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||<span aria-hidden="true">____</span>||||||
"""
WHITE_SQUARE = '||'
BLACK_SQUARE = '  '
</code></pre>
<p class="tx">波かっこは<span class="thesansmonocd_w5regular_">'wR'</span>や<span class="thesansmonocd_w5regular_">'bQ'</span>のような駒を表す文字列を挿入する場所を表します。マス目が空白の場合は、<span class="thesansmonocd_w5regular_">WHITE_SQUARE</span>または<span class="thesansmonocd_w5regular_">BLACK_SQUARE</span>を挿入します。これについては、<span class="thesansmonocd_w5regular_">print_chessboard()</span>関数の箇所で詳しく説明します。</p>
</section>
<section type="division" aria-labelledby="sec9">
<h4 class="h1" id="calibre_link-1576"><span id="calibre_link-155"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ 3：現在のチェス盤の状態を表示する</span></h4>
<p class="tni">チェス盤を表す辞書を取り、画面上にチェス盤を駒とともに表示する<span class="thesansmonocd_w5regular_">print_chessboard()</span>関数を定義します。文字列<span class="thesansmonocd_w5regular_">BOARD_TEMPLATE</span> について、文字列メソッド<span class="thesansmonocd_w5regular_">format()</span>を呼び出します。このメソッドに文字列のリストを渡します。<span class="thesansmonocd_w5regular_">format()</span>メソッドは、<span class="thesansmonocd_w5regular_">BOARD_TEMPLATE</span>の波かっこ（<span class="thesansmonocd_w5regular_">{}</span>）をリストで渡した文字列に置換した新しい文字列を返します。<span class="thesansmonocd_w5regular_">format()</span>については次章で詳しく説明します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">print_chessboard()</span>のコードを見ていきましょう。</p>
<pre class="pre"><code class="calibre9">def print_chessboard(board):
    squares = []
    is_white_square = True
    for y in '87654321':
        for x in 'abcdefgh':
            #print(x, y, is_white_square)  # デバッグ用に座標を表示する
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1577" aria-label="151"></span>チェス盤には64マスあり、文字列<span class="thesansmonocd_w5regular_">BOARD_TEMPLATE</span>には64箇所の<span class="thesansmonocd_w5regular_">{}</span>があります。これらの<span class="thesansmonocd_w5regular_">{}</span>を置換する64個の文字列のリストを作ります。そのリストを変数<span class="thesansmonocd_w5regular_">squares</span>に格納します。このリストの文字列は、<span class="thesansmonocd_w5regular_">'wB'</span>や<span class="thesansmonocd_w5regular_">'bQ'</span>のように駒を表すか、空白マスを表すかのどちらかです。空白マスが白マスか黒マスかに応じて、<span class="thesansmonocd_w5regular_">WHITE_SQUARE</span>（<span class="thesansmonocd_w5regular_">'||'</span>）と<span class="thesansmonocd_w5regular_">BLACK_SQUARE</span>（<span class="thesansmonocd_w5regular_">' '</span>）を使い分けます。変数<span class="thesansmonocd_w5regular_">is_white_square</span>にブール値を格納して、どのマスが白でどのマスが黒かを判別します。</p>
<p class="tx">入れ子になった<span class="thesansmonocd_w5regular_">for</span>ループでチェス盤の64マスすべてをループします。左上のマスから始めて右に進んでいき、下へと進んでいきます。左上のマスは白マスですから、<span class="thesansmonocd_w5regular_">is_white_square</span>は<span class="thesansmonocd_w5regular_">True</span>で始めます。<span class="thesansmonocd_w5regular_">for</span>ループは<span class="thesansmonocd_w5regular_">range()</span>で取得できる整数でも、リストの値でも、文字列の文字でもループできることを思い出してください。ここでの2つの<span class="thesansmonocd_w5regular_">for</span>ループでは、変数<span class="thesansmonocd_w5regular_">y</span>と<span class="thesansmonocd_w5regular_">x</span>が文字列<span class="thesansmonocd_w5regular_">'87654321'</span>と<span class="thesansmonocd_w5regular_">'abcdefgh'</span>の各文字になります。<span class="thesansmonocd_w5regular_">print(x, y, is_white_square)</span>行のコメントを外してプログラムを実行すれば、このコードがループする順番（とそのマスの色）を確認できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループの内側では、適切な文字列でリスト<span class="thesansmonocd_w5regular_">squares</span>を組み立てます。</p>
<pre class="pre"><code class="calibre9">            if x + y in board.keys():
                squares.append(board[x + y])
            else:
                if is_white_square:
                    squares.append(WHITE_SQUARE)
                else:
                    squares.append(BLACK_SQUARE)
            is_white_square = not is_white_square
        is_white_square = not is_white_square

    print(BOARD_TEMPLATE.format(*squares))
</code></pre>
<p class="tx">ループ変数の<span class="thesansmonocd_w5regular_">x</span>と<span class="thesansmonocd_w5regular_">y</span>の文字列を結合して、2文字のマス目を表す文字列を作ります。例えば、<span class="thesansmonocd_w5regular_">x</span>が<span class="thesansmonocd_w5regular_">'a'</span>で<span class="thesansmonocd_w5regular_">y</span>が<span class="thesansmonocd_w5regular_">'8'</span>なら、<span class="thesansmonocd_w5regular_">x</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">y</span>は<span class="thesansmonocd_w5regular_">'a8'</span>になり、<span class="thesansmonocd_w5regular_">x</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">y in board.keys()</span>でその文字列がチェス盤を表す辞書のキーに存在するかを調べます。存在すれば、チェスの駒を表す文字列をリスト<span class="thesansmonocd_w5regular_">squares</span> のそのマスに追加します。</p>
<p class="tx">存在しなければ、空白マスを表す文字列を追加します。<span class="thesansmonocd_w5regular_">is_white_square</span>の値に応じて<span class="thesansmonocd_w5regular_">WHITE_SQUARE</span>か<span class="thesansmonocd_w5regular_">BLACK_SQUARE</span>のどちらかになります。1つのマスの処理が終われば、<span class="thesansmonocd_w5regular_">is_white_square</span>のブール値を反対の値にトグルします（隣り合うマス目の色は異なるので）。外側の<span class="thesansmonocd_w5regular_">for</span>ループが終わり、1つの行の処理が終われば、この変数の値をもう一度トグルします。</p>
<p class="tx">ループ処理が終われば、リスト<span class="thesansmonocd_w5regular_">squares</span>には64個の文字列が入っています。ただし、文字列メソッド<span class="thesansmonocd_w5regular_">format()</span>は1つのリストを引数に取るのではなく、<span class="thesansmonocd_w5regular_">{}</span>ごとに1つの文字列を引数に取ります。squaresの横にアスタリスク（<span class="thesansmonocd_w5regular_">*</span>）をつけると、そのリストの値を一つずつの引数として渡すことになります。これは微妙な違いです。<span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">['cat', 'dog', 'rat']</span>というリストを例に説明します。<span class="thesansmonocd_w5regular_">print(spam)</span>を呼び出すと、角かっことクォートとカンマのあるリスト値を表示します。これに対し、<span class="thesansmonocd_w5regular_">print(*spam)</span>を呼び出すと、<span class="thesansmonocd_w5regular_">print('cat', 'dog', 'rat')</span>を呼び出したのと同じになるので、<span class="thesansmonocd_w5regular_">cat dog rat</span>を表示します。私はこれを<i class="calibre5">スター構文</i>と呼んでいます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">print_chessboard()</span>関数は、チェス盤を表現するためにここで使っている特定のデータ構造で機能するように書かれています。<span class="thesansmonocd_w5regular_">'a8'</span>のようなマス目を表す文字列をキー、<span class="thesansmonocd_w5regular_">'bQ'</span>のような駒を表す文字列を値とする、Pythonの辞書というデータ構造です。データ構造を変えたとしたら、この関数も変えなければなりません。<span class="thesansmonocd_w5regular_">print_chessboard()</span>はチェス盤をテキストで表現しますが、チェス盤の描画にPygameのようなグラフィックライブラリを使うとしても、このPythonの辞書でチェス盤の配置を表現できるでしょう。</p>
</section>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1579"><span id="calibre_link-156"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ 4：チェス盤の操作</span></h4>
<p class="tni">これでチェス盤をPythonの辞書で表現できるようになり、その辞書に基づいてチェス盤を表示する関数が用意できましたから、辞書のキーと値を操作してチェス盤で駒を動かすコードを書きましょう。<span class="thesansmonocd_w5regular_">def</span>ブロックの<span class="thesansmonocd_w5regular_">print_chessboard()</span>関数のあとに、対話型のチェス盤プログラムの使い方を説明するテキストを表示するプログラムのメイン部分が来ます。</p>
<pre class="pre"><code class="calibre9">print('Interactive Chessboard')
print('by Al Sweigart al@inventwithpython.com')
print()
print('Pieces:')
print('  w - White, b - Black')
print('  P - Pawn, N - Knight, B - Bishop, R - Rook, Q - Queen, K - King')
print('Commands:')
print('  move e2 e4 - Moves the piece at e2 to e4')
print('  remove e2 - Removes the piece at e2')
print('  set e2 wP - Sets square e2 to a white pawn')
print('  reset - Resets pieces back to their starting squares')
print('  clear - Clears the entire board')
print('  fill wP - Fills entire board with white pawns.')
print('  quit - Quits the program')
</code></pre>
<p class="tx">このプログラムでは、辞書を変更することにより、駒の移動と除去とマス目への配置ができ、チェス盤のリセットとクリアができます。</p>
<pre class="pre"><code class="calibre9">main_board = copy.copy(STARTING_PIECES)
while True:
    print_chessboard(main_board)
    response = input('&gt; ').split()
</code></pre>
<p class="tx">まず、変数<span class="thesansmonocd_w5regular_">main_board</span>は辞書<span class="thesansmonocd_w5regular_">STARTING_PIECES</span>のコピーを受け取ります。これは対局開始時の駒の配置を表す辞書です。プログラム実行は無限ループに入り、ユーザーの命令を待ちます。例えば、ユーザーが<span class="thesansmonocd_w5regular_">input()</span>呼び出しに<b class="calibre10">move e2 e4</b>と入力すれば、<span class="thesansmonocd_w5regular_">split()</span>メソッドがリスト<span class="thesansmonocd_w5regular_">['move', 'e2', 'e4']</span>を返し、それが変数<span class="thesansmonocd_w5regular_">response</span>に格納されます。リスト<span class="thesansmonocd_w5regular_">response</span>の最初の要素である<span class="thesansmonocd_w5regular_">response[0]</span>は、ユーザーが実行したい命令です。</p>
<pre class="pre"><code class="calibre9"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1580" aria-label="153"></span>    if response[0] == 'move':
        main_board[response[2]] = main_board[response[1]]
        del main_board[response[1]]
</code></pre>
<p class="tx">ユーザーが<b class="calibre10">move e2 e4</b>と入力したら、<span class="thesansmonocd_w5regular_">response[0]</span>は<span class="thesansmonocd_w5regular_">'move'</span>になります。移動前のマス目（<span class="thesansmonocd_w5regular_">response[1]</span>）から新しいマス目（<span class="thesansmonocd_w5regular_">response[2]</span>）へと<span class="thesansmonocd_w5regular_">main_board</span>の駒をコピーすることにより、駒をあるマス目から別のマス目へと動かします。それから、<span class="thesansmonocd_w5regular_">main_board</span>の古いマス目のキーと値のペアを削除します。こうすることで、駒を移動させたかのように見えます（もう一度<span class="thesansmonocd_w5regular_">print_chessboard()</span>を呼び出すまでは変化が見えませんが）。</p>
<p class="tx">この対話型のチェス盤シミュレーターは、チェスのルールに沿った動きであるかどうかはチェックしません。ユーザーの命令をそのまま実行します。ユーザーが<b class="calibre10">remove e2</b>と入力すると、プログラムは<span class="thesansmonocd_w5regular_">response</span>に<span class="thesansmonocd_w5regular_">['remove', 'e2']</span>を設定します。</p>
<pre class="pre"><code class="calibre9">    elif response[0] == 'remove':
        del main_board[response[1]]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">main_board</span>から<span class="thesansmonocd_w5regular_">response[1]</span>をキーとするキーと値のペアを削除することにより、その駒を盤面から消しています。ユーザーが<b class="calibre10">set e2 wP</b>と入力すると、白のポーンをe2に配置します。プログラムは<span class="thesansmonocd_w5regular_">response</span>に<span class="thesansmonocd_w5regular_">['set', 'e2', 'wP']</span>を設定します。</p>
<pre class="pre"><code class="calibre9">    elif response[0] == 'set':
        main_board[response[1]] = response[2]
</code></pre>
<p class="tx">キーを<span class="thesansmonocd_w5regular_">response[1]</span>、値を<span class="thesansmonocd_w5regular_">response[2]</span>とする新しいキーと値のペアを<span class="thesansmonocd_w5regular_">main_board</span>に作成し、その駒を盤面に配置します。ユーザーが<span class="sans_thesansmonocd_w7bold_b_">reset</span>と入力すると、<span class="thesansmonocd_w5regular_">response</span>はシンプルに<span class="thesansmonocd_w5regular_">['reset']</span>となり、辞書<span class="thesansmonocd_w5regular_">STARTING_PIECES</span>を<span class="thesansmonocd_w5regular_">main_board</span>にコピーして対局開始時の配置に戻します。</p>
<pre class="pre"><code class="calibre9">    elif response[0] == 'reset':
        main_board = copy.copy(STARTING_PIECES)
</code></pre>
<p class="tx">ユーザーが<span class="sans_thesansmonocd_w7bold_b_">clear</span>と入力すると、<span class="thesansmonocd_w5regular_">response</span>はシンプルに<span class="thesansmonocd_w5regular_">['clear']</span>となり、<span class="thesansmonocd_w5regular_">main_board</span>を空辞書にすることで盤面からすべての駒を消します。</p>
<pre class="pre"><code class="calibre9">    elif response[0] == 'clear':
        main_board = {}
</code></pre>
<p class="tx">ユーザーが<span class="sans_thesansmonocd_w7bold_b_">fill wP</span>と入力すると、<span class="thesansmonocd_w5regular_">response</span>は<span class="thesansmonocd_w5regular_">['fill', 'wP']</span>となり、64マスすべてに文字列<span class="thesansmonocd_w5regular_">'wP'</span>を設定します。</p>
<pre class="pre"><code class="calibre9">    elif response[0] == 'fill':
        for y in '87654321':
            for x in 'abcdefgh':
                main_board[x + y] = response[1]
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-962" aria-label="154"></span>入れ子の<span class="thesansmonocd_w5regular_">for</span>ループはすべてのマス目を反復し、キー<span class="thesansmonocd_w5regular_">x</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">y</span>に<span class="thesansmonocd_w5regular_">response[1]</span>を設定します。64個の白のポーンをチェス盤に配置する理由なんてありませんが、どのようなことでもチェス盤のデータ構造をいじれば簡単に実現できることがわかります。最後に、ユーザーが<span class="sans_thesansmonocd_w7bold_b_">quit</span>と入力したら、プログラムが終了します。</p>
<pre class="pre"><code class="calibre9">    elif response[0] == 'quit':
        sys.exit()
</code></pre>
<p class="tx">命令を実行して<span class="thesansmonocd_w5regular_">main_board</span>を変更した後には、プログラム実行が<span class="thesansmonocd_w5regular_">while</span>ループの最初に戻り、変更後のチェス盤を表示して、ユーザーからの新しい命令を待ち受けます。</p>
<p class="tx">この対話型のチェス盤プログラムは、チェスのルールに縛られずに駒を配置します。チェス盤上の駒を表すのに辞書を使い、その辞書をチェス盤の見た目で画面上に表示する関数があります。データ構造を設計してそのデータ構造を操作する関数を書くことにより、現実世界の対象や過程をモデル化できます。データ構造でゲームをモデル化する例に興味がありましたら、<i class="calibre5">The Big Book of Small Python Projects</i> (No Starch Press, 2021)という私の別の本をご覧ください。○×ゲームなどが収録されています。
</p>
</section>
</section>
<section type="division" aria-labelledby="sec11">
<h3 class="h" id="calibre_link-1581"><span id="calibre_link-157"></span><span class="sans_futura_std_bold_b_">辞書やリストの入れ子</span></h3>
<p class="tni">複雑な事物をモデル化しようとすると、辞書やリストを入れ子にしなければならないことがあります。リストは値を順番に保持するのに適していて、辞書はキーと値を対応づけるのに適しています。例えば、以下のプログラムは、入れ子の辞書を使って、ゲストがピクニックに持っていく物を管理します。<span class="thesansmonocd_w5regular_">total_brought()</span>関数がこのデータ構造を読み取り、それぞれの持ち物の総数を計算します。次のコードを<i class="calibre5">guestpicnic.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">all_guests = {'Alice': {'apples': 5, 'pretzels': 12},
              'Bob': {'ham sandwiches': 3, 'apples': 2},
              'Carol': {'cups': 3, 'apple pies': 1}}

def total_brought(guests, item):
    num_brought = 0
  <span class="code_codeannotation" aria-label="annotation1">❶</span> for k, v in guests.items():
      <span class="code_codeannotation" aria-label="annotation2">❷</span> num_brought = num_brought + v.get(item, 0)
    return num_brought

print('Number of things being brought:')
print(' - Apples         ' + str(total_brought(all_guests, 'apples')))
print(' - Cups           ' + str(total_brought(all_guests, 'cups')))
print(' - Cakes          ' + str(total_brought(all_guests, 'cakes')))
print(' - Ham Sandwiches ' + str(total_brought(all_guests, 'ham sandwiches')))
print(' - Apple Pies     ' + str(total_brought(all_guests, 'apple pies')))
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1582" aria-label="155"></span><span class="thesansmonocd_w5regular_">total_brought()</span>関数内では、<span class="thesansmonocd_w5regular_">for</span>ループが<span class="thesansmonocd_w5regular_">guests</span>のキーと値のペアを反復処理しています(<span class="codeannotation" aria-label="annotation1">❶</span>)。ループ内では、ゲストの名前が<span class="thesansmonocd_w5regular_">k</span>に代入され、ピクニックの持ち物を表す辞書が<span class="thesansmonocd_w5regular_">v</span>に代入されます。<span class="thesansmonocd_w5regular_">get()</span>メソッドのパラメータとして渡される持ち物がその持ち物を表す辞書のキーに存在すれば、その値（個数）を<span class="thesansmonocd_w5regular_">num_brought</span>に加えます(<span class="codeannotation" aria-label="annotation2">❷</span>)。キーに存在しなければ、<span class="thesansmonocd_w5regular_">get()</span>メソッドが<span class="thesansmonocd_w5regular_">0</span>を返し、これが<span class="thesansmonocd_w5regular_">num_brought</span>に加えられます。</p>
<p class="tx">このプロブラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9"> Number of things being brought:
 - Apples 7
 - Cups 3
 - Cakes 0
 - Ham Sandwiches 3
 - Apple Pies 1
</code></pre>
<p class="tx">このピクニックの持ち物の個数は単純であり、モデル化してプログラムを書く必要なんてないと思われるかもしれませんが、<span class="thesansmonocd_w5regular_">total_brought()</span>関数は持ち物が数千個あるゲストの人数が数千人になってもそのまま使えます。そのような状況であれば、情報をデータ構造に保持し、<span class="thesansmonocd_w5regular_">total_brought()</span>関数で処理すれば、大いに時間を節約できます。</p>
<p class="tx">プログラムで正しく処理できる形にしさえすれば、データ構造を使って事物を好きなようにモデル化できます。プログラミングを始めてしばらくの間は、モデル化の「正しい」方法をそこまで気にしないでください。経験を積めば、効率的なモデル化の方法がわかってきます。データを処理して目的を達成できるプログラムを書くのが大切です。</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec12">
<h3 class="h" id="calibre_link-1583"><span id="calibre_link-158"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">この章では辞書について説明しました。リストと辞書は複数の値を持つことのできる値です。辞書やリストを入れ子にすることもできます。リストは単純に値を順番に格納するのに対し、辞書はある項目（キー）を別の項目（値）に結びつけることができるので便利です。リストと同様に、角かっこで辞書の中に入っている値にアクセスできます。整数のインデックスの代わりに、辞書では、整数、浮動小数点数、文字列、タプルなど、いろいろなデータ型のキーを持てます。プログラムで利用する値をデータ構造に整理すると、本章でチェス盤をモデル化したように、現実世界の対象を表現できるようになります。</p>
</section>
<section type="division" aria-labelledby="sec13">
<h3 class="h" id="calibre_link-1584"><span id="calibre_link-159"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. 空辞書を作成してください。</p>
<p class="listnumber">  2. キーが<span class="thesansmonocd_w5regular_">'foo'</span>で値が<span class="thesansmonocd_w5regular_">42</span>の辞書を作成してください。</p>
<p class="listnumber">  3. 辞書とリストの主な違いは何ですか？</p>
<p class="listnumber">  4. <span class="thesansmonocd_w5regular_">spam</span>が<span class="thesansmonocd_w5regular_">{'bar': 100}</span>であるときに、<span class="thesansmonocd_w5regular_">spam['foo']</span>でアクセスしようとするとどうなりますか？</p>
<p class="listnumber"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1012" aria-label="156"></span>  5. <span class="thesansmonocd_w5regular_">spam</span>に辞書が格納されているとして、<span class="thesansmonocd_w5regular_">'cat' in spam</span>と<span class="thesansmonocd_w5regular_">'cat' in spam.keys()</span>はどう違いますか？</p>
<p class="listnumber">  6. <span class="thesansmonocd_w5regular_">spam</span>に辞書が格納されているとして、<span class="thesansmonocd_w5regular_">'cat' in spam</span>と<span class="thesansmonocd_w5regular_">'cat' in spam.values()</span>はどう違いますか？</p>
<p class="listnumber">  7. 以下のコードを短く書いてください。</p>
<pre class="pre"><code class="calibre9">if 'color' not in spam:
    spam['color'] = 'black'
</code></pre>
<p class="listnumber">  8. 辞書の値を整形して出力（pretty-print）するのに使えるモジュールと関数は何ですか？</p>
</section>
<section type="division" aria-labelledby="sec14">
<h3 class="h" id="calibre_link-1585"><span id="calibre_link-160"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec15">
<h4 class="h1" id="calibre_link-1586"><span id="calibre_link-161"></span><span class="sans_futura_std_heavy_oblique_bi_">チェス辞書の検証</span></h4>
<p class="tni">本章では、チェス盤を表すのに<span class="thesansmonocd_w5regular_">{'h1': 'bK', 'c6': 'wQ', 'g2': 'bB', 'h5': 'bQ', 'e3': 'wK'}</span>のような辞書値を使いました。辞書を引数に取り、チェス盤として正しいかどうかに応じて<span class="thesansmonocd_w5regular_">True</span>または<span class="thesansmonocd_w5regular_">False</span>を返す<span class="thesansmonocd_w5regular_">isValidChessBoard()</span>という名前の関数を書いてください。</p>
<p class="tx">正しいチェス盤には、白のキングと黒のキングが必ず1つずつ存在します。各プレイヤーは最大16個の駒を盤上に持てます。ポーンは8個までです。駒が存在できるのは<span class="thesansmonocd_w5regular_">'1a'</span>から<span class="thesansmonocd_w5regular_">'8h'</span>までのマス目だけです。<span class="thesansmonocd_w5regular_">'9z'</span>のようなマス目に駒は存在できません。駒の名前は、白または黒を表す<span class="thesansmonocd_w5regular_">'w'</span>か<span class="thesansmonocd_w5regular_">'b'</span>のどちらかで始まり、<span class="thesansmonocd_w5regular_">'pawn'</span>、<span class="thesansmonocd_w5regular_">'knight'</span>、<span class="thesansmonocd_w5regular_">'bishop'</span>、<span class="thesansmonocd_w5regular_">'rook'</span>、<span class="thesansmonocd_w5regular_">'queen'</span>、<span class="thesansmonocd_w5regular_">'king'</span>のいずれかが続きます。この関数はバグにより不適切なチェス盤になっていることを検知します（上記の説明は正しいチェス盤の条件を完全に網羅しているわけではありませんが、ここでの練習ではそれで十分です）。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h4 class="h1" id="calibre_link-1587"><span id="calibre_link-162"></span><span class="sans_futura_std_heavy_oblique_bi_">ファンタジーゲームの所持品一覧</span></h4>
<p class="tni">中世のファンタジーゲームを作っているとします。プレイヤーの所持品一覧を辞書でモデル化しています。キーは所持品の文字列で、値はそのプレイヤーが所持している個数です。例えば、<span class="thesansmonocd_w5regular_">{'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12}</span>という辞書値は、そのプレイヤーがロープを1つ、トーチを6つ、金貨を42枚、短剣を1つ、矢を12本持っていることを意味します。</p>
<p class="tx">所持品一覧を取り、以下のように表示する<span class="thesansmonocd_w5regular_">display_inventory()</span>という名前の関数を書いてください。</p>
<pre class="pre"><code class="calibre9">Inventory:
12 arrow
42 gold coin
1 rope
6 torch
1 dagger
Total number of items: 62
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1221" aria-label="157"></span>ヒント：辞書のキーをループ処理するのに<span class="thesansmonocd_w5regular_">for</span>ループが使えます。</p>
<pre class="pre"><code class="calibre9">stuff = {'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12}

def display_inventory(inventory):
    print("Inventory:")
    item_total = 0
    for k, v in inventory.items():
        # この部分のプログラムを書く
    print("Total number of items: " + str(item_total))

display_inventory(stuff)
</code></pre>
</section>
<section type="division" aria-labelledby="sec17">
<h4 class="h1" id="calibre_link-1588"><span id="calibre_link-163"></span><span class="sans_futura_std_heavy_oblique_bi_">戦利品のリストから辞書への変換</span></h4>
<p class="tni">このファンタジーゲームでは、ドラゴンを退治した戦利品を次のようなリストで表すとします。</p>
<pre class="pre"><code class="calibre9">dragon_loot = ['gold coin', 'dagger', 'gold coin', 'gold coin', 'ruby']</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">add_to_inventory(inventory, added_items)</span>という関数を書いてください。パラメータ<span class="thesansmonocd_w5regular_">inventory</span>は、先に見たように、そのプレイヤーの所持品一覧を表す辞書です。パラメータ<span class="thesansmonocd_w5regular_">added_items</span>は、<span class="thesansmonocd_w5regular_">dragon_loot</span>のようなリストです。<span class="thesansmonocd_w5regular_">add_to_inventory()</span>関数はプレイヤーの最新の所持品を表す辞書を返します。リスト<span class="thesansmonocd_w5regular_">added_items</span>には同じ所持品が複数含まれる可能性があることに留意してください。コードは次のようになります。</p>
<pre class="pre"><code class="calibre9">def add_to_inventory(inventory, added_items):
    # ここにコードを書く

inv = {'gold coin': 42, 'rope': 1}
dragon_loot = ['gold coin', 'dagger', 'gold coin', 'gold coin', 'ruby']
inv = add_to_inventory(inv, dragon_loot)
display_inventory(inv)
</code></pre>
<p class="tx">このコードを実行してから、前のプログラムの<span class="thesansmonocd_w5regular_">display_inventory()</span>関数を呼び出すと、以下のように出力します。</p>
<pre class="pre"><code class="calibre9">Inventory:
45 gold coin
1 rope
1 ruby
1 dagger

Total number of items: 48
</code></pre>
</section>
</section>
</section>
</div>


</div>



</body></html>