<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-256">
<section type="chapter" role="doc-chapter" aria-labelledby="ch11">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1698" aria-label="243"></span>
<hgroup>
<h2 class="title" id="calibre_link-1699">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">11</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">ファイルの整理</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">新しいファイルの作成と書き込みだけでなく、ハードドライブ上の既存のファイルの整理も、プログラムで行えます。数十、数百、ひょっとしたら数千ファイルが入っているフォルダで、コピー、リネーム（名前変更）、移動、圧縮を手動で行ったことがあるでしょう。あるいは、以下のような作業を想定してください。</p>
<ul class="ul">
<li class="bl">すべてのサブフォルダの中に入っているPDFファイル（PDFファイル<i class="calibre5">だけ</i>）をコピーする</li>
<li class="bl">数百あるファイルすべてのファイル名（<i class="calibre5">spam001.txt</i>、<i class="calibre5">spam002.txt</i>、<i class="calibre5">spam003.txt</i>など）の最初のゼロを削除する</li>
<li class="bl">数個のフォルダの中身を一つのZIPファイルに圧縮する（シンプルなバックアップ）</li>
</ul>
<p class="tx">こうした退屈な作業はPythonで自動化するのにうってつけです。プログラミングにより自分のコンピュータを絶対に間違えない事務員に仕立て上げられます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1062" aria-label="244"></span>Windowsではファイルパスのフォルダの区切りにバックスラッシュ（\）を使いますが、本章のコードではすべてのOSで機能するようにスラッシュ（/）を使います。</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1700"><span id="calibre_link-257"></span><span class="sans_futura_std_bold_b_">shutilモジュール</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">shutil</span>モジュールには、ファイルをコピー、移動、リネーム、削除する関数があります（このモジュールの名前はshell utilitiesを縮めたものです。<i class="calibre5">shell</i>はターミナルコマンドラインの別の呼び方です）。<span class="thesansmonocd_w5regular_">shutil</span>関数を使うには、最初に<span class="thesansmonocd_w5regular_">import shutil</span>を実行します。</p>
<p class="tx">対話型シェルで次のコードを実行して、本章で例として使用するファイルとフォルダを作成してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">h = Path.home()</b>
&gt;&gt;&gt; <b class="calibre10">(h / 'spam').mkdir(exist_ok=True)</b>
&gt;&gt;&gt; <b class="calibre10">with open(h / 'spam/file1.txt', 'w', encoding='utf-8') as file:</b>
...     <b class="calibre10">file.write('Hello')</b>
...
</code></pre>
<p class="tx"><i class="calibre5">file1.txt</i>という名前のテキストファイルが入っている<i class="calibre5">spam</i>フォルダを作成しています。本章では、このファイルとフォルダを例にして、コピー、移動、リネーム、削除を行います。<span class="thesansmonocd_w5regular_">shutil</span>関数は、文字列と<span class="thesansmonocd_w5regular_">Path</span>オブジェクトのどちらでも引数に取れます。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1701"><span id="calibre_link-258"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルとフォルダのコピー</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">shutil</span>モジュールには、ファイルをコピーする関数とフォルダ全体をコピーする関数があります。<span class="thesansmonocd_w5regular_">shutil.copy(</span><span class="sans_thesansmonocd_w5regular_italic_">source</span><span class="thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">destination</span><span class="thesansmonocd_w5regular_">)</span>を呼び出すと、<span class="sans_thesansmonocd_w5regular_italic_">source</span>で指定されたファイルを<span class="sans_thesansmonocd_w5regular_italic_">destination</span>で指定されたフォルダにコピーします。<span class="sans_thesansmonocd_w5regular_italic_">source</span>と<span class="sans_thesansmonocd_w5regular_italic_">destination</span>の両方とも、文字列または<span class="thesansmonocd_w5regular_">Path</span>オブジェクトです。<span class="sans_thesansmonocd_w5regular_italic_">destination</span>がファイル名なら、コピーされたファイルの新しい名前になります。<span class="sans_thesansmonocd_w5regular_italic_">destination</span>がフォルダなら、そのフォルダ内に元の名前のままでコピーされます。この関数は、コピーしたファイルのパスを返します。</p>
<p class="tx">対話型シェルに次の内容を入力して<span class="thesansmonocd_w5regular_">shutil.copy()</span>の動作を確認してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import shutil</b>
&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">h = Path.home()</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">shutil.copy(h / 'spam/file1.txt', h)</b>
'C:\\Users\\Al\\file1.txt'
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span> &gt;&gt;&gt; <b class="calibre10">shutil.copy(h / 'spam/file1.txt', h / 'spam/file2.txt')</b>
WindowsPath('C:/Users/Al/spam/file2.txt')
</code></pre>
<p class="tx">最初の<span class="thesansmonocd_w5regular_">shutil.copy()</span>呼び出しでは、<i class="calibre5">C:\Users\Al\spam\file1.txt</i>のファイルをホームフォルダ<i class="calibre5">C:\Users\Al</i>にコピーしています。返り値は新しくコピーしたファイルのパスです。移動先にフォルダを指定したので(<span class="codeannotation" aria-label="annotation1">❶</span>)、新しくコピーしたファイルは元の<i class="calibre5">file1.txt</i>というファイルのファイル名と同じ名前になります。2回目の<span class="thesansmonocd_w5regular_">shutil.copy()</span>呼び出しでは、<i class="calibre5">C:\Users\Al\spam\file1.txt</i>のファイルを<i class="calibre5">file2.txt</i>という名前で<i class="calibre5">C:\Users\Al\spam</i>フォルダにコピーしています(<span class="codeannotation" aria-label="annotation2">❷</span>)。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">shutil.copy()</span>は一つのファイルをコピーしますが、<span class="thesansmonocd_w5regular_">shutil.copytree(</span><span class="sans_thesansmonocd_w5regular_italic_">source</span><span class="thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">destination</span><span class="thesansmonocd_w5regular_">)</span>を呼び出すと<span class="sans_thesansmonocd_w5regular_italic_">source</span>のフォルダをその中に入っているファイルとサブフォルダを全部含めて<span class="sans_thesansmonocd_w5regular_italic_">destination</span>のフォルダにコピーします。この関数は、コピーしたフォルダのパスを返します。</p>
<p class="tx">以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import shutil</b>
&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">h = Path.home()</b>
&gt;&gt;&gt; <b class="calibre10">shutil.copytree(h / 'spam', h / 'spam_backup')</b>
WindowsPath('C:/Users/Al/spam_backup')
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">shutil.copytree()</span>を呼び出して、元の<i class="calibre5">spam</i>フォルダと同じ内容の<i class="calibre5">spam_backup</i>という名前の新しいフォルダを作成しています。大切なspamを安全にバックアップできました。</p>
</section>
<section type="division" aria-labelledby="sec3">
<h4 class="h1" id="calibre_link-1702"><span id="calibre_link-259"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルとフォルダの移動、リネーム</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">shutil.move(</span><span class="sans_thesansmonocd_w5regular_italic_">source</span><span class="thesansmonocd_w5regular_">,</span> <span class="sans_thesansmonocd_w5regular_italic_">destination</span><span class="thesansmonocd_w5regular_">)</span>を呼び出すと、<span class="sans_thesansmonocd_w5regular_italic_">source</span>で指定したファイルやフォルダを<span class="sans_thesansmonocd_w5regular_italic_">destination</span>で指定したパスに移動できます。移動先の絶対パスの文字列が返されます。</p>
<p class="tx"><span class="sans_thesansmonocd_w5regular_italic_">destination</span>がフォルダを指していたら、<span class="sans_thesansmonocd_w5regular_italic_">source</span>ファイルが<span class="sans_thesansmonocd_w5regular_italic_">destination</span>に移動され、ファイル名はそのままになります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import shutil</b>
&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">h = Path.home()</b>
&gt;&gt;&gt; <b class="calibre10">(h / 'spam2').mkdir()</b>
&gt;&gt;&gt; <b class="calibre10">shutil.move(h / 'spam/file1.txt', h / 'spam2')</b>
'C:\\Users\\Al\\spam2\\file1.txt'
</code></pre>
<p class="tx">ホームフォルダに<i class="calibre5">spam2</i>フォルダを作成してから、<span class="thesansmonocd_w5regular_">shutil.move()</span>を呼び出して、<i class="calibre5">C:\Users\Al\spam\file1.txt</i>を<i class="calibre5">C:\Users\Al\spam2</i>に移動させています。<i class="calibre5">C:\Users\Al\spam2</i>内にすでに<i class="calibre5">file1.txt</i>ファイルが存在していたとしたら、上書きします。</p>
<p class="tx"><span class="sans_thesansmonocd_w5regular_italic_">destination</span>が既存のフォルダでなければ、<span class="thesansmonocd_w5regular_">shutil.move()</span>がその名前にリネームします。以下の例では、<span class="sans_thesansmonocd_w5regular_italic_">source</span>ファイルが移動されてリネームされます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">shutil.move(h / 'spam/file1.txt', h / 'spam2/new_name.txt')</b>
'C:\\Users\\Al\\spam2\\new_name.txt'
</code></pre>
<p class="tx">この行は、「<i class="calibre5">C:\Users\Al\spam\file1.txt</i>を<i class="calibre5">C:\Users\Al\spam2</i>フォルダに移動して、<i class="calibre5">file1.txt</i>というファイル名を<i class="calibre5">new_name.txt</i>にリネームする」と読めます。</p>
</section>
<section type="division" aria-labelledby="sec4">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1180" aria-label="246"></span>
<h4 class="h1" id="calibre_link-1703"><span id="calibre_link-260"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルとフォルダを完全に削除する</span></h4>
<p class="tni">一つのファイルまたは空フォルダを<span class="thesansmonocd_w5regular_">os</span>モジュールの関数で削除できます。フォルダとその中身を一括して削除するなら、<span class="thesansmonocd_w5regular_">shutil</span>モジュールを使います。</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">shutil.rmtree(</span><span class="sans_thesansmonocd_w5regular_italic_">path</span><span class="thesansmonocd_w5regular_">)</span>を呼び出すと、ファイルとサブフォルダを一括して<span class="sans_thesansmonocd_w5regular_italic_">path</span>のフォルダ以下全体を削除します。</li>
<li class="bl"><span class="thesansmonocd_w5regular_">os.unlink(</span><span class="sans_thesansmonocd_w5regular_italic_">path</span><span class="thesansmonocd_w5regular_">)</span>を呼び出すと、<span class="sans_thesansmonocd_w5regular_italic_">path</span>の一ファイルを削除します。</li>
<li class="bl"><span class="thesansmonocd_w5regular_">os.rmdir(</span><span class="sans_thesansmonocd_w5regular_italic_">path</span><span class="thesansmonocd_w5regular_">)</span>を呼び出すと、<span class="sans_thesansmonocd_w5regular_italic_">path</span>の空ディレクトリを削除します。</li>
</ul>
<p class="tx">プログラムでこれらの関数を使うときには気をつけてください。最初はこれらの関数をコメントアウトして<span class="thesansmonocd_w5regular_">print()</span>を呼び出し削除予定のファイルを表示することをおすすめします。これは<i class="calibre5">dry run</i>と呼ばれるやり方です。以下は拡張子<i class="calibre5">.txt</i>のファイルを削除することを意図して書いたプログラムですが、タイプミスがあり（太字の部分です）、<i class="calibre5">.rxt</i>ファイルが削除されてしまいます。</p>
<pre class="pre"><code class="calibre9">import os
from pathlib import Path
for filename in Path.home().glob('*.<b class="calibre10">r</b>xt'):
    os.unlink(filename)
</code></pre>
<p class="tx">ファイル名が<i class="calibre5">.rxt</i>で終わる重要なファイルがあったとしたら、そのファイルが完全に削除されてしまいます。いきなり削除を実行するのではなく、次のように実行してください。</p>
<pre class="pre"><code class="calibre9">import os
from pathlib import Path
for filename in Path.home().glob('*.rxt'):
    #os.unlink(filename)
    print('Deleting', filename)
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">os.unlink()</span>の呼び出しはコメントアウトされていますから無視されます。その代わりに、削除予定のファイル名を表示しています。まずこのようなプログラムを実行するようにすれば、<i class="calibre5">.txt</i>ファイルではなく<i class="calibre5">.rxt</i>ファイルを削除しようとしていたことに気づけます。</p>
<p class="tx">ファイルのコピー、リネーム、移動でもdry runを実行したほうがよいでしょう。さらに、プログラムで操作するファイルのバックアップのコピーを作成しておくのも望ましいです。そうすれば万一の際にファイルを復元できます。プログラムが意図通りに動くことが確信できたら、<span class="thesansmonocd_w5regular_">print(filename)</span>の行を削除して<span class="thesansmonocd_w5regular_">os.unlink(filename)</span>の行のコメントアウトを外してください。それからプログラムを実行すれば、意図したファイルを削除します。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1704"><span id="calibre_link-261"></span><span class="sans_futura_std_heavy_oblique_bi_">ごみ箱に移動する</span></h4>
<p class="tni">Python本体に付属している<span class="thesansmonocd_w5regular_">shutil.rmtree()</span>関数はファイルとフォルダを完全に削除します。バグにより意図しないファイルを削除してしまうかもしれないので、この関数は危険です。サードパーティの<span class="thesansmonocd_w5regular_">send2trash</span>モジュールを使ってファイルとフォルダを削除するほうが安全です（サードパーティのパッケージをインストールする方法は<span>付録A</span>をご参照ください）。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">send2trash</span>モジュールの<span class="thesansmonocd_w5regular_">send2trash()</span>関数は、フォルダやファイルを完全に削除するのではなく、コンピュータのごみ箱に移動させるので、Python標準の削除関数よりもずっと安全です。プログラムのバグにより<span class="thesansmonocd_w5regular_">send2trash</span>で意図しないファイルやフォルダを削除してしまったとしても、あとでごみ箱から復元できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">send2trash</span>をインストールしたら、対話型シェルで次のコードを実行して、<i class="calibre5">file1.txt</i>をごみ箱に移動させてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import send2trash</b>
&gt;&gt;&gt; <b class="calibre10">send2trash.send2trash('file1.txt')</b>
</code></pre>
<p class="tx">一般的に、ファイルやフォルダを削除するには、<span class="thesansmonocd_w5regular_">send2trash.send2trash()</span>関数を使ったほうがよいでしょう。しかし、ファイルをごみ箱に移動させると、あとで復元できますが、ディスク容量は解放されません。<span class="thesansmonocd_w5regular_">send2trash()</span>はファイルをごみ箱に移動させられるだけで、ごみ箱からファイルを取り出すことはできません。</p>
</section>
</section>
<section type="division" aria-labelledby="sec6">
<h3 class="h" id="calibre_link-1705"><span id="calibre_link-262"></span><span class="sans_futura_std_bold_b_">ディレクトリツリーを走査する</span></h3>
<p class="tni">あるフォルダ以下のファイルとサブフォルダの一覧を取得したければ、<span class="thesansmonocd_w5regular_">os.listdir()</span>関数にフォルダ名を渡します。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import os</b>
&gt;&gt;&gt; <b class="calibre10">os.listdir(r'C:\Users\Al')</b>
['.anaconda', '.android', '.cache', '.dotnet', '.eclipse', '.gitconfig',
<var class="calibre20">--snip--</var>
'__pycache__']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">iterdir()</span>メソッドを呼び出すとフォルダ内の<span class="thesansmonocd_w5regular_">Path</span>オブジェクトの一覧を取得できます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">home = Path.home()</b>
&gt;&gt;&gt; <b class="calibre10">list(home.iterdir())</b>
[WindowsPath('C:/Users/Al/.anaconda'), WindowsPath('C:/Users/Al/.android'),
WindowsPath('C:/Users/Al/.cache'),
<var class="calibre20">--snip--</var>
WindowsPath('C:/Users/Al/__pycache__')]
</code></pre>
<p class="tx">あるフォルダ以下のすべてのファイルをサブフォルダ内のファイルも含めてリネームしたいとします。ディレクトリツリーを走査して、それぞれのファイルにアクセスしたいということです。このプログラムを書くのはややこしいですが、Pythonにはこの状況に対応できる<span class="thesansmonocd_w5regular_">os.walk()</span>関数があります。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1144" aria-label="248"></span>対話型シェルで以下のコードを実行して、一連のフォルダとファイルを作成しましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from pathlib import Path</b>
&gt;&gt;&gt; <b class="calibre10">h = Path.home()</b>
&gt;&gt;&gt; <b class="calibre10">(h / 'spam').mkdir(exist_ok=True)</b>
&gt;&gt;&gt; <b class="calibre10">(h / 'spam/eggs').mkdir(exist_ok=True)</b>
&gt;&gt;&gt; <b class="calibre10">(h / 'spam/eggs2').mkdir(exist_ok=True)</b>
&gt;&gt;&gt; <b class="calibre10">(h / 'spam/eggs/bacon').mkdir(exist_ok=True)</b>
&gt;&gt;&gt; <b class="calibre10">for f in ['spam/file1.txt', 'spam/eggs/file2.txt', 'spam/eggs/file3.txt',</b>
<b class="calibre10">'spam/eggs/bacon/file4.txt']:</b>
...     <b class="calibre10">with open(h / f, 'w', encoding='utf-8') as file:</b>
...         <b class="calibre10">file.write('Hello')</b>
...
&gt;&gt;&gt; # この時点でフォルダとファイルが存在
</code></pre>
<p class="tx">このコードは、ホームフォルダに以下のフォルダとファイルを作成します。</p>
<ul class="ul">
<li class="bl"><i class="calibre5">spam</i>フォルダ</li>
<li class="bl"><i class="calibre5">spam/file1.txt</i>ファイル</li>
<li class="bl"><i class="calibre5">spam/eggs</i>フォルダ</li>
<li class="bl"><i class="calibre5">spam/eggs/file2.txt</i>ファイル</li>
<li class="bl"><i class="calibre5">spam/eggs/file3.txt</i>ファイル</li>
<li class="bl"><i class="calibre5">spam/eggs2</i>フォルダ</li>
<li class="bl"><i class="calibre5">spam/eggs/bacon</i>フォルダ</li>
<li class="bl"><i class="calibre5">spam/eggs/bacon/file4.txt</i>ファイル</li>
</ul>
<p class="tx">以下のプログラムを実行すると、このフォルダツリーで<span class="thesansmonocd_w5regular_">os.walk()</span>関数を使い、各ファイルの名前を大文字にします。</p>
<pre class="pre"><code class="calibre9">import os, shutil
from pathlib import Path
h = Path.home()

for folder_name, subfolders, filenames in os.walk(h / 'spam'):
    print('The current folder is ' + folder_name)

    for subfolder in subfolders:
        print('SUBFOLDER OF ' + folder_name + ': ' + subfolder)

    for filename in filenames:
        print('FILE INSIDE ' + folder_name + ': '+ filename)
        # ファイル名を大文字にリネーム
        p = Path(folder_name)
        shutil.move(p / filename, p / filename.upper())
   
    print('')
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">os.walk()</span>関数には、フォルダのパスを示す一つの文字列値を渡します。<span class="thesansmonocd_w5regular_">os.walk()</span>を<span class="thesansmonocd_w5regular_">for</span>ループで使い、ディレクトリツリーを走査します。<span class="thesansmonocd_w5regular_">range()</span>関数で一連の数値を走査するのと似ています。<span class="thesansmonocd_w5regular_">range()</span>とは異なり、<span class="thesansmonocd_w5regular_">os.walk()</span>関数はループの反復ごとに3つの値を返します。</p>
<ul class="ul">
<li class="bl">現在のフォルダ名の文字列</li>
<li class="bl">現在のフォルダ内のサブフォルダの文字列のリスト</li>
<li class="bl">現在のフォルダ内のファイル名文字列のリスト</li>
</ul>
<p class="tx">ここで<i class="calibre5">現在のフォルダ</i>は<span class="thesansmonocd_w5regular_">for</span>ループの現在の反復でアクセスされているフォルダを指します。<span class="thesansmonocd_w5regular_">os.walk()</span>関数はプログラムの現在の作業ディレクトリを変更しません。<span class="thesansmonocd_w5regular_">for i in range(10):</span>の変数名<span class="thesansmonocd_w5regular_">i</span>を自由に変えられるのと同じように、先に示した3つの変数の名前を自由に変えられます。私はいつも<span class="thesansmonocd_w5regular_">folder_name</span>、<span class="thesansmonocd_w5regular_">subfolders</span>、<span class="thesansmonocd_w5regular_">filenames</span>というわかりやすい名前を使うようにしています。</p>
<p class="tx">このプログラムを私のコンピュータで実行すると、以下の出力になりました。</p>
<pre class="pre"><code class="calibre9">The current folder is C:\Users\Al\spam
SUBFOLDER OF C:\Users\Al\spam: eggs
SUBFOLDER OF C:\Users\Al\spam: eggs2
FILE INSIDE C:\Users\Al\spam: file1.txt

The current folder is C:\Users\Al\spam\eggs
SUBFOLDER OF C:\Users\Al\spam\eggs: bacon
FILE INSIDE C:\Users\Al\spam\eggs: file2.txt
FILE INSIDE C:\Users\Al\spam\eggs: file3.txt

The current folder is C:\Users\Al\spam\eggs\bacon
FILE INSIDE C:\Users\Al\spam\eggs\bacon: file4.txt

The current folder is C:\Users\Al\spam\eggs2
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">os.walk()</span>は変数<span class="thesansmonocd_w5regular_">subfolder</span>と<span class="thesansmonocd_w5regular_">filename</span>で文字列のリストを返しますから、その返り値を<span class="thesansmonocd_w5regular_">for</span>ループで使えます。この例でしているように、<span class="thesansmonocd_w5regular_">shutil.move()</span>のような関数にフォルダやファイル名を渡せます。</p>
</section>
<section type="division" aria-labelledby="sec7">
<h3 class="h" id="calibre_link-1706"><span id="calibre_link-263"></span><span class="sans_futura_std_bold_b_">zipfileモジュールでファイルを圧縮する</span></h3>
<p class="tni">（拡張子<i class="calibre5">.zip</i>の）ZIPファイルはご存知でしょう。たくさんのファイルを圧縮して一つのファイルにできます。ファイルを圧縮するとサイズが減りますから、インターネットで転送する際に便利です。また、複数のファイルとサブフォルダを一つのZIPファイルにできますから、一つのパッケージにまとめるという面でも便利です。<i class="calibre5">アーカイブファイル</i>と呼ばれることもあります。メールにも添付できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">zipfile</span>モジュールの関数を使うとZIPファイルの作成と展開ができます。</p>
<section type="division" aria-labelledby="sec8">
<h4 class="h1" id="calibre_link-1707"><span id="calibre_link-264"></span><span class="sans_futura_std_heavy_oblique_bi_">ZIPファイルの作成と追加</span></h4>
<p class="tni">圧縮ZIPファイルを作成するには、第二引数に<span class="thesansmonocd_w5regular_">'w'</span>を渡して<span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトを書き込みモードで開きます（<span class="thesansmonocd_w5regular_">zipfile</span>モジュールの名前はすべて小文字ですが、<span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトの名前は<i class="calibre5">Z</i> <span role="doc-pagebreak" type="pagebreak" id="calibre_link-1046" aria-label="250"></span>と<i class="calibre5">F</i>が大文字であることに注意してください）。<span class="thesansmonocd_w5regular_">open()</span>関数に<span class="thesansmonocd_w5regular_">'w'</span>を渡して書き込みモードでテキストファイルを開くのと似ています。ファイル名には、文字列と<span class="thesansmonocd_w5regular_">Path</span>オブジェクトのどちらでも渡せます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトの<span class="thesansmonocd_w5regular_">write()</span>メソッドにパスを渡すと、そのパスのファイルを圧縮してZIPファイルに追加します。<span class="thesansmonocd_w5regular_">write()</span>メソッドの第一引数は追加するファイル名の文字列です。第二引数は、ファイルを圧縮する際に用いるアルゴリズムを指定する、<i class="calibre5">圧縮タイプ</i>のパラメータです。あらゆるデータでうまく機能する<i class="calibre5">deflate</i>圧縮アルゴリズムを指定するなら、この値を常に<span class="thesansmonocd_w5regular_">zipfile.ZIP_DEFLATED</span>とします。この第二引数の値を渡さなければ、<span class="thesansmonocd_w5regular_">write()</span>メソッドはZIPファイルに指定したファイルを無圧縮で追加します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import zipfile</b>
&gt;&gt;&gt; <b class="calibre10">with open('file1.txt', 'w', encoding='utf-8') as file_obj:</b>
...     <b class="calibre10">file_obj.write('Hello' * 10000)</b>
...
&gt;&gt;&gt; <b class="calibre10">with zipfile.ZipFile('example.zip', 'w') as example_zip:</b>
...     <b class="calibre10">example_zip.write('file1.txt', compress_type=zipfile.ZIP_DEFLATED,</b>
<b class="calibre10">        compresslevel=9)</b>
</code></pre>
<p class="tx">このコードは、<i class="calibre5">file1.txt</i>という名前のテキストファイルを作成し、<span class="thesansmonocd_w5regular_">'Hello' * 10000</span>で50,000文字を書き込んでいます（約49KBになります）。次に、<i class="calibre5">file1.txt</i>の内容を圧縮した<i class="calibre5">example.zip</i>という名前の新しいZIPファルを作成しています（約213バイト、繰り返しの多いデータは圧縮率が高くなります）。Python3.7以降で利用できるようになった<span class="thesansmonocd_w5regular_">compresslevel</span>キーワード引数（名前付きパラメータ）には、<span class="thesansmonocd_w5regular_">0</span>から<span class="thesansmonocd_w5regular_">9</span>までの値を設定できます。<span class="thesansmonocd_w5regular_">9</span>が最も遅いけれども最も圧縮率が高いです。このキーワード引数を指定しなければ、デフォルトの<span class="thesansmonocd_w5regular_">6</span>になります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">with</span>文の<span class="thesansmonocd_w5regular_">zipfile.ZipFile()</span>関数でZIPファイルを開いています。<span class="thesansmonocd_w5regular_">open()</span>関数でファイルを開くのと似ています。こうすれば、プログラム実行が<span class="thesansmonocd_w5regular_">with</span>文のブロックを抜けるときに<span class="thesansmonocd_w5regular_">close()</span>関数が自動的に呼び出されます。</p>
<p class="tx">ファイルへの書き込みと同じように、書き込みモードでは既存のZIPファイルの内容が上書きされて消えてしまいます。既存のZIPファイルにファイルを追加したければ、ZIPファイルを開くときに<span class="thesansmonocd_w5regular_">zipfile.ZipFile()</span>の第二引数に<span class="thesansmonocd_w5regular_">'a'</span>を渡して<i class="calibre5">追記モード</i>にします。</p>
</section>
<section type="division" aria-labelledby="sec9">
<h4 class="h1" id="calibre_link-1708"><span id="calibre_link-265"></span><span class="sans_futura_std_heavy_oblique_bi_">ZIPファイルの読み取り</span></h4>
<p class="tni">ZIPファイルの内容を読み取るには、ZIPファイルの名前を渡して<span class="thesansmonocd_w5regular_">zipfile.ZipFile()</span>関数を呼び出して<span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトを作成します。<span class="thesansmonocd_w5regular_">zipfile</span>はモジュール名で、<span class="thesansmonocd_w5regular_">ZipFile()</span>は関数名です。</p>
<p class="tx">対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import zipfile</b>

&gt;&gt;&gt; <b class="calibre10">example_zip = zipfile.ZipFile('example.zip')</b>
&gt;&gt;&gt; <b class="calibre10">example_zip.namelist()</b>
['file1.txt']
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1029" aria-label="251"></span>&gt;&gt;&gt; <b class="calibre10">file1_info = example_zip.getinfo('file1.txt')</b>
&gt;&gt;&gt; <b class="calibre10">file1_info.file_size</b>
50000
&gt;&gt;&gt; <b class="calibre10">file1_info.compress_size</b>
97
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">f'Compressed file is {round(file1_info.file_size / file1_info</b>
<b class="calibre10">    .compress_size, 2)}x smaller!'</b>

'Compressed file is 515.46x smaller!'
&gt;&gt;&gt; <b class="calibre10">example_zip.close()</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトには、そのZIPファイルに含まれているすべてのファイルとフォルダの名前の文字列のリストを返す<span class="thesansmonocd_w5regular_">namelist()</span>メソッドがあります。これらの文字列を<span class="thesansmonocd_w5regular_">getinfo() ZipFile</span>メソッドに渡すと、そのファイルについての<span class="thesansmonocd_w5regular_">ZipInfo</span>オブジェクトが得られます。<span class="thesansmonocd_w5regular_">ZipInfo</span>オブジェクトには、元のファイルサイズを保持している<span class="thesansmonocd_w5regular_">file_size</span>や圧縮したファイルサイズを保持している<span class="thesansmonocd_w5regular_">compress_size</span>などの固有の属性があります。ファイルサイズはバイト単位の整数値です。<span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトはアーカイブファイル全体を表すのに対し、<span class="thesansmonocd_w5regular_">ZipInfo</span>オブジェクトはアーカイブ内の個々のファイルについての情報を保持します。</p>
<p class="tx"><span class="codeannotation" aria-label="annotation1">❶</span>のコマンドでどれくらい効率的に<i class="calibre5">example.zip</i>が圧縮されているか、元のファイルサイズを圧縮されたファイルサイズで割って計算し、その結果を表示しています。</p>
</section>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1709"><span id="calibre_link-266"></span><span class="sans_futura_std_heavy_oblique_bi_">ZIPファイルからの抽出</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトの<span class="thesansmonocd_w5regular_">extractall()</span>メソッドはZIPファイルからすべてのファイルとフォルダを抽出し、現在の作業ディレクトリに展開します。<span>「ZIPファイルの作成と追加」</span>の指示に従って<i class="calibre5">example.zip</i>という名前のZIPファイルを作成してから、対話型シェルで以下のコードを実行してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import zipfile</b>
&gt;&gt;&gt; <b class="calibre10">example_zip = zipfile.ZipFile('example.zip')</b>
<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span> &gt;&gt;&gt; <b class="calibre10">example_zip.extractall()</b>
&gt;&gt;&gt; <b class="calibre10">example_zip.close()</b>
</code></pre>
<p class="tx">このコードを実行すると、<i class="calibre5">example.zip</i>の中身が現在の作業ディレクトリに抽出されます。オプションでフォルダ名を<span class="thesansmonocd_w5regular_">extractall()</span>に渡すことができ、そうすると抽出したファイルがそのフォルダに展開されます。<span class="thesansmonocd_w5regular_">extractall()</span>に渡されたフォルダが存在しなければ作成されます。例えば、<span class="codeannotation" aria-label="annotation1">❶</span>の呼び出しを<span class="thesansmonocd_w5regular_">example_zip.extractall('C:\\spam)</span>に書き換えると、<i class="calibre5">example.zip</i>から抽出したファイルを新しく作成された<i class="calibre5">C:\spam</i>フォルダに展開します。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトの<span class="thesansmonocd_w5regular_">extract()</span>メソッドはZIPファイルから一つのファイルを抽出します。対話型シェルで続けて以下のように入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">example_zip.extract('file1.txt')</b>
'C:\\Users\\Al\\Desktop\\file1.txt'
&gt;&gt;&gt; <b class="calibre10">example_zip.extract('file1.txt', 'C:\\some\\new\\folders')</b>
'C:\\some\\new\\folders\\file1.txt'
&gt;&gt;&gt; <b class="calibre10">example_zip.close()</b>
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-949" aria-label="252"></span><span class="thesansmonocd_w5regular_">extract()</span>に渡した文字列は<span class="thesansmonocd_w5regular_">namelist()</span>で返されるリストの中に入っている文字列のどれかに一致しなければなりません。オプションで<span class="thesansmonocd_w5regular_">extract()</span>の第二引数に抽出したファイルを展開するフォルダを指定できます。この第二引数のフォルダが存在しなければ作成されます。</p>
<p class="ph"><span id="calibre_link-267"></span><span class="sans_futura_std_heavy_b_">プロジェクト5：フォルダをZIPファイルにバックアップする</span></p>
<p class="tni"><i class="calibre5">C:\Users\Al\AlsPythonBook</i>という名前のフォルダに作業中のファイルを保存しているとします。これまでの作業を失いたくないので、フォルダ全体のスナップショットをZIPファイルに保存したいです。そのスナップショットをバージョン管理したいので、ZIPファイルの名前を<i class="calibre5">AlsPythonBook_1.zip</i>、<i class="calibre5">AlsPythonBook_2.zip</i>、<i class="calibre5">AlsPythonBook_3.zip</i>のようにしたいです。手動でこれを行うこともできますが、面倒ですし、ZIPファイルの名前を間違うかもしれません。この退屈な作業をしてくれるプログラムを実行するほうがずっと簡単です。</p>
<p class="tx">このプロジェクト用に、新しいファイルエディタウィンドウを開いて、<i class="calibre5">backup_to_zip.py</i>という名前で保存してください。</p>
</section>
<section type="division" aria-labelledby="sec11">
<h4 class="h1" id="calibre_link-1710"><span id="calibre_link-268"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：ZIPファイルの名前を調整する</span></h4>
<p class="tni">このプログラムのコードを<span class="thesansmonocd_w5regular_">backup_to_zip()</span>という名前の関数に書きます。こうすれば別のPythonプログラムでこの関数をコピーアンドペーストして利用できます。プログラムの最後でこの関数を呼び出してバックアップを実行します。プログラムは次のようになります。</p>
<pre class="pre"><code class="calibre9"># backup_to_zip.py - フォルダ全体をその中身ごとZIPファイルに
# コピーし、ZIPファイルの名前の数字を増やしていく

import zipfile, os
from pathlib import Path

def backup_to_zip(folder):
    # folder全体を中身ごとZIPファイルにバックアップする
    folder = Path(folder)  # folderは文字列ではなくPathオブジェクトに統一

    # 既存のZIPファイルから、
    # 作成するZIPファイルのファイル名を決める
  <span class="code_codeannotation" aria-label="annotation1">❶</span> number = 1
  <span class="code_codeannotation" aria-label="annotation2">❷</span> while True:

        zip_filename = Path(folder.parts[-1] + '_' + str(number) + '.zip')
        if not zip_filename.exists():
            break
        number = number + 1

  <span class="code_codeannotation" aria-label="annotation3">❸</span> # TODO：ZIPファイルを作成する

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1711" aria-label="253"></span>    # TODO：フォルダ全体を走査して各フォルダ内のファイルを圧縮する
    print('Done.')

backup_to_zip(Path.home() / 'spam')
</code></pre>
<p class="tx">まず、<span class="thesansmonocd_w5regular_">zipfile</span> モジュールと<span class="thesansmonocd_w5regular_">os</span>モジュールをインポートします。 次に、<span class="thesansmonocd_w5regular_">folder</span>引数を一つ取る<span class="thesansmonocd_w5regular_">backup_to_zip()</span>関数を定義します。この引数はバックアップしたいフォルダの文字列または<span class="thesansmonocd_w5regular_">Path</span>オブジェクトです。この関数では、作成するZIPファイルのファイル名を決めます。それから、フォルダ<span class="thesansmonocd_w5regular_">folder</span>を走査し、各サブフォルダとファイルを追加して、ZIPファイルを作成します。あとで思い出せるように、これらのステップの<span class="thesansmonocd_w5regular_">TODO</span>コメントを書きます(<span class="codeannotation" aria-label="annotation3">❸</span>)。</p>
<p class="tx">ZIPファイルの名前を決めるという最初の作業には<span class="thesansmonocd_w5regular_">folder</span>の絶対パスのベースネームを利用します。バックアップするフォルダが<i class="calibre5">C:\Users\Al\spam</i>だとすると、ZIPファイルの名前は<i class="calibre5">spam_N.zip</i>になります。初回のプログラム実行時に<i class="calibre5">N</i>は1で、次の回は2になります。</p>
<p class="tx"><i class="calibre5">spam_1.zip</i>がすでに存在するかどうか、<i class="calibre5">spam_2.zip</i>がすでに存在するかどうかを順に確認することにより、<i class="calibre5">N</i>を決めます。<span class="thesansmonocd_w5regular_">number</span>という名前の変数に<i class="calibre5">N</i>を格納し(<span class="codeannotation" aria-label="annotation1">❶</span>)、ファイルがすでに存在するかを確認する <span class="thesansmonocd_w5regular_">exists()</span>を呼び出しているループ内で<i class="calibre5">N</i>を増やしていきます(<span class="codeannotation" aria-label="annotation2">❷</span>)。存在しないファイル名を見つけたらループを<span class="thesansmonocd_w5regular_">break</span>します。これが新しく作成するZIPファイルの名前になります。</p>
</section>
<section type="division" aria-labelledby="sec12">
<h4 class="h1" id="calibre_link-1712"><span id="calibre_link-269"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：新しいZIPファイルを作成する</span></h4>
<p class="tni">次はZIPファイルを作成しましょう。以下のようなコードになります。</p>
<pre class="pre"><code class="calibre9"># backup_to_zip.py - フォルダ全体をその中身ごとZIPファイルに
# コピーし、ZIPファイルの名前の数字を増やしていく

<var class="calibre20">--snip--</var>

    <b class="calibre10"># ZIPファイルを作成する</b>
<b class="calibre10">    print(f'Creating {zip_filename}...')</b>
<b class="calibre10">    backup_zip = zipfile.ZipFile(zip_filename, 'w')</b>

    # TODO：フォルダ全体を走査して各フォルダ内のファイルを圧縮する
    print('Done.')

backup_to_zip(Path.home() / 'spam')
</code></pre>
<p class="tx">変数<span class="thesansmonocd_w5regular_">zip_filename</span>に新しいZIPファイルの名前が格納されていますから、<span class="thesansmonocd_w5regular_">zipfile.ZipFile()</span>を呼び出して実際にZIPファイルを作成できます。第二引数に<span class="thesansmonocd_w5regular_">'w'</span>を渡してZIPファイルを書き込みモードで開きます。コードを書き終えたのでTODOコメントを削除します。</p>
</section>
<section type="division" aria-labelledby="sec13">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1713" aria-label="254"></span>
<h4 class="h1" id="calibre_link-1714"><span id="calibre_link-270"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：ディレクトリツリーを走査する</span></h4>
<p class="tni">対象フォルダ内のすべてのファイルとサブフォルダをリストアップするために<span class="thesansmonocd_w5regular_">os.walk()</span>関数を呼び出す必要があります。以下のようなコードになります。</p>
<pre class="pre"><code class="calibre9"># backup_to_zip.py - フォルダ全体をその中身ごとZIPファイルに
# コピーし、ZIPファイルの名前の数字を増やしていく

<var class="calibre20">--snip--</var>

<b class="calibre10">    # フォルダ全体を走査して各フォルダ内のファイルを圧縮する</b>
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation1">❶</span><b class="calibre10"> for folder_name, subfolders, filenames in os.walk(folder):</b>
<b class="calibre10">        folder_name = Path(folder_name)</b>
<b class="calibre10">        print(f'Adding files in folder {folder_name}...')</b>

        <b class="calibre10"># このフォルダ内のすべてのファイルをZIPファイルに追加</b>
<b class="calibre10">      </b><span class="code_codeannotation" aria-label="annotation2">❷</span><b class="calibre10"> for filename in filenames:</b>
<b class="calibre10">            print(f'Adding file {filename}...')</b>
<b class="calibre10">            backup_zip.write(folder_name / filename)</b>
<b class="calibre10">    backup_zip.close()</b>
    print('Done.')
backup_to_zip(Path.home() / 'spam')
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループで<span class="thesansmonocd_w5regular_">os.walk()</span>を使います(<span class="codeannotation" aria-label="annotation1">❶</span>)。反復ごとに現在のフォルダ名とサブフォルダとファイル名が返されます。入れ子になっている<span class="thesansmonocd_w5regular_">for</span> ループでは<span class="thesansmonocd_w5regular_">filenames</span>リストの各ファイルを処理します(<span class="codeannotation" aria-label="annotation2">❷</span>)。各ファイルをZIPファイルに追加します。</p>
<p class="tx">このプログラムを実行すると、次のような出力になります。</p>
<pre class="pre"><code class="calibre9">Creating spam_1.zip...
Adding files in spam...
Adding file file1.txt...
Done.
</code></pre>
<p class="tx">2回目のプログラム実行では、フォルダ<i class="calibre5">spam</i>のすべてのファイルを<i class="calibre5">spam_2.zip</i>という名前のZIPファイルにまとめます。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1715"><span id="calibre_link-271"></span><span class="sans_futura_std_heavy_oblique_bi_">ほかのプログラムのアイデア</span></h4>
<p class="tni">ディレクトリツリーを走査してファイルを圧縮したZIPアーカイブに追加する、別のプログラムを書けます。例えば、以下の内容が考えられます。</p>
<ul class="ul">
<li class="bl">ディレクトリツリーを走査して<i class="calibre5">.txt</i>や<i class="calibre5">.py</i>など、特定の拡張子のファイルだけをアーカイブする。</li>
<li class="bl">ディレクトリツリーを走査して、<i class="calibre5">.txt</i>と<i class="calibre5">.py</i>以外のファイルだけをアーカイブする。</li>
<li class="bl">ディスク容量を一番多く使っているディレクトリや、前回のアーカイブ以降に更新されたディレクトリだけをアーカイブする。</li>
</ul>
</section>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec15">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1102" aria-label="255"></span>
<h3 class="h" id="calibre_link-1716"><span id="calibre_link-272"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">コンピュータの熟練者であっても、マウスとキーボードでファイルを手動で操作しているでしょう。現代のファイルエクスプローラーでは少数のファイルを操作するのは簡単です。しかしファイルエクスプローラーでは数時間を要するような作業が必要になることも時にはあるでしょう。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">os</span>モジュールと<span class="thesansmonocd_w5regular_">shutil</span>モジュールには、ファイルをコピー、移動、リネーム、削除する関数があります。ファイルを削除する際には、完全に削除するのではなく、ごみ箱に移動するために<span class="thesansmonocd_w5regular_">send2trash</span>モジュールを使いたい場合があるかもしれません。さらに、ファイルを操作するプログラムを書くときには、dry runの実施を検討してください。実際にコピー、移動、リネーム、削除するコードをコメントアウトし、その代わりに<span class="thesansmonocd_w5regular_">print()</span>を呼び出すのです。プログラムを実行すれば、どのファイルが対象になるかを確かめられます。</p>
<p class="tx">一つのフォルダ内のファイルだけでなく、すべてのサブフォルダ内のファイルやサブフォルダ内のサブフォルダ内のファイルを操作する必要が生じる場合もあるでしょう。<span class="thesansmonocd_w5regular_">os.walk()</span>関数でフォルダを走査できますから、ファイルの操作に集中できます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">zipfile</span>モジュールを使うとPythonで<i class="calibre5">.zip</i>アーカイブの圧縮と展開ができます。<span class="thesansmonocd_w5regular_">os</span>や<span class="thesansmonocd_w5regular_">shutil</span>と組み合わせて使えば、ハードドライブ上の複数のファイルを<span class="thesansmonocd_w5regular_">zipfile</span>で簡単にパッケージ化できます。このようにしてZIPファイルを作成すれば、ウェブサイトにアップロードしたりメールに添付したりしやすくなります。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h3 class="h" id="calibre_link-1717"><span id="calibre_link-273"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. <span class="thesansmonocd_w5regular_">shutil.copy()</span>と<span class="thesansmonocd_w5regular_">shutil.copytree()</span>の違いは何ですか？</p>
<p class="listnumber">  2. ファイルのリネームにはどの関数を使いますか？</p>
<p class="listnumber">  3. <span class="thesansmonocd_w5regular_">send2trash</span>モジュールと<span class="thesansmonocd_w5regular_">shutil</span>モジュールの削除にはどのような違いがありますか？</p>
<p class="listnumber">  4. <span class="thesansmonocd_w5regular_">File</span>オブジェクトの<span class="thesansmonocd_w5regular_">close()</span>メソッドと同じように、<span class="thesansmonocd_w5regular_">ZipFile</span>オブジェクトには<span class="thesansmonocd_w5regular_">close()</span>メソッドがあります。<span class="thesansmonocd_w5regular_">File</span>オブジェクトの<span class="thesansmonocd_w5regular_">open()</span>メソッドに相当する<span class="thesansmonocd_w5regular_">ZipFile</span>のメソッドは何ですか？</p>
</section>
<section type="division" aria-labelledby="sec17">
<h3 class="h" id="calibre_link-1718"><span id="calibre_link-274"></span><span class="sans_futura_std_bold_b_">練習プログラム</span></h3>
<p class="tni">以下の練習プログラムを書いてください。</p>
<section type="division" aria-labelledby="sec18">
<h4 class="h1" id="calibre_link-1719"><span id="calibre_link-275"></span><span class="sans_futura_std_heavy_oblique_bi_">選択的なコピー</span></h4>
<p class="tni">フォルダツリーを走査して特定のファイル拡張子を検索し（<i class="calibre5">.pdf</i>や<i class="calibre5">.jpg</i>など）、見つけたファイルを新しいフォルダへコピーするプログラムを書いてください。</p>
</section>
<section type="division" aria-labelledby="sec19">
<h4 class="h1" id="calibre_link-1720"><span id="calibre_link-276"></span><span class="sans_futura_std_heavy_oblique_bi_">不必要なファイルの削除</span></h4>
<p class="tni">いくつかのファイルやフォルダがハードドライブの容量を圧迫していることは珍しくありません。コンピュータの容量を解放するには、サイズの大きい不必要なファイルを特定すると効果的です。</p>
<p class="tx">フォルダツリーを走査して、（例えば100MB以上の）サイズの大きなファイルやフォルダを探し出すプログラムを書いてください。（<span class="thesansmonocd_w5regular_">os</span>モジュールの<span class="thesansmonocd_w5regular_">os.path.getsize()</span>を使えばファイルのサイズを取得できることを思い出してください。）発見したファイルの絶対パスを画面に表示してください。</p>
</section>
<section type="division" aria-labelledby="sec20">
<h4 class="h1" id="calibre_link-1721"><span id="calibre_link-277"></span><span class="sans_futura_std_heavy_oblique_bi_">ファイルの番号再割り当て</span></h4>
<p class="tni"><i class="calibre5">spam001.txt</i>、<i class="calibre5">spam002.txt</i>のように、指定した名前で始まるファイルをすべて見つけ、飛んでいる番号（<i class="calibre5">spam001.txt</i> と<i class="calibre5">spam003.txt</i>はあるが<i class="calibre5">spam002.txt</i>がないなど）を特定するプログラムを書いてください。飛んでいる番号を詰めるようにリネームしてください。</p>
<p class="tx">この例で使うファイルを以下のコードで作成します（<i class="calibre5">spam042.txt</i>、<i class="calibre5">spam086.txt</i>、<i class="calibre5">spam103.txt</i>を飛ばします）。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">for i in range(1, 121):</b>
<b class="calibre10">...     if i not in (42, 86, 103):</b>
<b class="calibre10">...         with open(f'spam{str(i).zfill(3)}.txt', 'w') as file:</b>
<b class="calibre10">...             pass</b>
...
</code></pre>
<p class="tx">さらなる練習として、連番のファイルの途中で番号を繰り上げてあとからその番号に新しいファイルを挿入できるようにする、別のプログラムを書いてください。</p>
</section>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1722"><span id="calibre_link-278"></span><span class="sans_futura_std_heavy_oblique_bi_">アメリカ式の日付からヨーロッパ式の日付への変換</span></h4>
<p class="tni">アメリカ式の日付（MM-DD-YYYY）のファイル名をヨーロッパ式の日付（DD-MM-YYYY）のファイル名にリネームするよう、上司からメールで指示されたとします。数千ファイルあります。この退屈な作業を手動で行えば一日かかるでしょう。そこで、次のようなプログラムを作成します。</p>
<p class="listnumber">  1. 現在の作業ディレクトリ以下のすべてのファイルからアメリカ式の日付のファイル名を探します。サブフォルダを探すのに<span class="thesansmonocd_w5regular_">os.walk()</span>関数を使います。</p>
<p class="listnumber">  2. 例えば<i class="calibre5">spam12-31-1900.txt</i>など、ファイル名のMM-DD-YYYYパターンを発見するのに正規表現を使います。月と日は必ず2桁の数字で、日付として無効なファイル名（<i class="calibre5">99-99-9999.txt</i>など）はないと想定して構いません。</p>
<p class="listnumber">  3. ファイルを見つけたら、ヨーロッパ式になるように月と日を入れ替えてリネームします。リネームには<span class="thesansmonocd_w5regular_">shutil.move()</span>関数を使います。</p>
</section>
</section>
</section>
</div>

</div>



</body></html>