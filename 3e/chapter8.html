<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link href="style.css" rel="stylesheet" type="text/css" /><title>Pythonで退屈な作業を自動化する
</title></head><body><div type="frontmatter" class="calibre" id="calibre_link-0">






<div type="bodymatter" class="calibre" id="calibre_link-164">
<section type="chapter" role="doc-chapter" aria-labelledby="ch8">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1589" aria-label="159"></span>
<hgroup>
<h2 class="title" id="calibre_link-1590">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">8</span></span> <span class="ct"><span class="sans_dogma_ot_bold_b_">文字列とテキスト編集</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">テキストは、プログラムで処理する最も一般的なデータ形式の一つです。<span class="sans_thesansmonocd_w5regular_">+</span>演算子で2つの文字列値を結合する方法はすでに説明しました。しかし、文字列値から部分文字列を抽出する、スペースを追加したり除去したりする、アルファベットを小文字または大文字に変換する、文字列が望む形式であるかチェックするなど、もっとたくさんのことができます。テキストのコピーアンドペーストに使われるクリップボードにアクセスするPythonのコードさえ書くことができます。</p>
<p class="tx">本章では、こうしたテキスト処理を説明します。それから、テキストを箇条書きにするという退屈な作業を自動化するプロジェクトに取り組みます。</p>
<section type="division" aria-labelledby="sec1">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-859" aria-label="160"></span>
<h3 class="h" id="calibre_link-1591"><span id="calibre_link-165"></span><span class="sans_futura_std_bold_b_">文字列の操作</span></h3>
<p class="tni">Pythonのコードで、文字列を書き、表示し、アクセスする方法を見ていきましょう。</p>
<section type="division" aria-labelledby="sec2">
<h4 class="h1" id="calibre_link-1592"><span id="calibre_link-166"></span><span class="sans_futura_std_heavy_oblique_bi_">文字列リテラル</span></h4>
<p class="tni">文字列<i class="calibre5">値</i>はプログラムのメモリに保存されますが、コード中にそのまま書かれている文字列値を<i class="calibre5">文字列リテラル</i>と呼びます。Pythonのコードでは文字列リテラルを直接書けます。シングルクォートの中に文字列値のテキストを書きます。しかし、文字列中にクォートを使う場合はどうすればいいのでしょうか。<span class="thesansmonocd_w5regular_">'That is Alice's cat.'</span>と入力してもうまくいきません。Pythonは<span class="thesansmonocd_w5regular_">Alice</span>のあとで文字列が終わると解釈し、残りの部分（<span class="thesansmonocd_w5regular_">s cat.'</span>）を不正なPythonのコードだとみなすからです。幸い、文字列リテラルを書く複数の方法があります。<i class="calibre5">文字列</i>という用語は、実行中のプログラムの文脈では文字列値を指し、Pythonのソースコードを入力する文脈では文字列リテラルを指します。</p>
<section type="division" aria-labelledby="sec3">
<h5 class="h2" id="calibre_link-1593"><span class="sans_futura_std_bold_b_">ダブルクォート</span></h5>
<p class="tni">文字列リテラルは、シングルクォートで囲んでもダブルクォートで囲んでも構いません。ダブルクォートで囲むと文字列の中にシングルクォートを含められます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = "That is Alice's cat."</b></code></pre>
<p class="tx">文字列をダブルクォートで囲んでいますから、シングルクォートは文字列の一部であって文字列が終わる印ではないとわかります。しかし、文字列中にシングルクォートとダブルクォートの両方を使いたい場合があります。そのような場合にはエスケープ文字を使う必要があります。</p>
</section>
<section type="division" aria-labelledby="sec4">
<h5 class="h2" id="calibre_link-1594"><span class="sans_futura_std_bold_b_">エスケープ文字</span></h5>
<p class="tni"><i class="calibre5">エスケープ文字</i>を使うと、通常は文字列リテラルに含めることのできない文字を文字列に含められるようになります。エスケープ文字はバックスラッシュ（<span class="thesansmonocd_w5regular_">\</span>）に続けて文字列に含めたい文字を書きます（訳注：日本語環境では、バックスラッシュが、半角バックスラッシュのように見えることもあれば、半角円マークのようにに見えることもあります）。例えば、<span class="thesansmonocd_w5regular_">\'</span>はシングルクォートのエスケープ文字で、<span class="thesansmonocd_w5regular_">\n</span>は改行文字のエスケープ文字です。（エスケープ文字は2文字で構成されていますが、1文字だと考えるのが一般的です。）シングルクォートで囲まれた文字列中でこのエスケープ文字を使えます。対話型シェルで以下の内容を入力してエスケープ文字の働きを確認してみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = 'Say hi to Bob\'s mother.'</b></code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Bob\'s</span>のシングルクォートにはバックスラッシュがあるので、文字列値の終わりを意味するシングルクォートではないとわかります。<span class="thesansmonocd_w5regular_">\'</span>と<span class="thesansmonocd_w5regular_">\"</span>のエスケープ文字を使えば、文字列中にシングルクォートやダブルクォートを含められます。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1223" aria-label="161"></span>表8-1は使用可能なエスケープ文字の一覧です。</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-724"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">表 8-1：</span></span><span class="sans_futura_std_book_">エスケープ文字</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">エスケープ文字</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">表示</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">\'</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">シングルクォート</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">\"</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">ダブルクォート</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">\t</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">タブ</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">\n</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">改行</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">\\</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">バックスラッシュ</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">対話型シェルに以下の内容を入力して、これらのエスケープ文字を使う練習をしてみましょう。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">print("Hello there!\nHow are you?\nI\'m doing fine.")</b>
Hello there!
How are you?
I'm doing fine.
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">\</span>はエスケープ文字の開始を意味するので、文字列中にバックスラッシュそのものを使いたい場合は、エスケープ文字<span class="thesansmonocd_w5regular_">\\</span>を使います。</p>
</section>
<section type="division" aria-labelledby="sec5">
<h5 class="h2" id="calibre_link-1595"><span class="sans_futura_std_bold_b_">raw文字列</span></h5>
<p class="tni">文字列リテラルのクォートの前に<span class="thesansmonocd_w5regular_">r</span>を置けばraw文字列リテラルを作成できます。<i class="calibre5">raw文字列</i>を利用すると、エスケープ文字をすべて無視するようになるので、バックスラッシュを含む文字列値を入力しやすくなります。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">print(r'The file is in C:\Users\Alice\Desktop')</b>
The file is in C:\Users\Alice\Desktop
</code></pre>
<p class="tx">これはraw文字列ですから、バックスラッシュが文字列の一部であるとみなされ、エスケープ文字の開始だと解釈されることはありません。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">print('Hello...\n\n...world!')</b>  # raw文字列ではない
Hello...

...world!
&gt;&gt;&gt; <b class="calibre10">print(r'Hello...\n\n...world!')</b>  # raw文字列
Hello...\n\n...world!
</code></pre>
<p class="tx">raw文字列は、<span class="thesansmonocd_w5regular_">r'C:\Users\Al\Desktop'</span>のようなWindowsのファイルパスや正規表現（次章で取り上げます）の文字列など、バックスラッシュを多く含む文字列で便利です。</p>
</section>
<section type="division" aria-labelledby="sec6">
<h5 class="h2" id="calibre_link-1596"><span class="sans_futura_std_bold_b_">複数行文字列</span></h5>
<p class="tni"><span class="thesansmonocd_w5regular_">\n</span>エスケープ文字を使えば文字列中に改行を挿入することができますが、複数行文字列を使ったほうが簡単でしょう。Pythonの複数行文字列は、三重引用符（シングルクォートでもダブルクォートでも構いません）で囲みます。三重引用符に囲まれた部分では、クォートもタブも改行も文字列の一部だとみなされます。三重引用符の中では、インデントでブロックを表現するPythonのルールが適用されません。</p>
<p class="tx">例えば、新しいファイルエディタを開き、次のコードを入力してください。</p>
<pre class="pre"><code class="calibre9">print('''Dear Alice,

Can you feed Eve's cat this weekend?

Sincerely,
Bob''')
</code></pre>
<p class="tx">このプログラムを<i class="calibre5">feedcat.py</i>という名前で保存して実行してください。出力は次のようになります。</p>
<pre class="pre"><code class="calibre9">Dear Alice,

Can you feed Eve's cat this weekend?

Sincerely,
Bob
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">Eve's</span>の中にあるシングルクォートをエスケープする必要はありません。複数行文字列ではシングルクォートとダブルクォートをエスケープしてもしなくても構いません。</p>
<pre class="pre"><code class="calibre9">print("Dear Alice,\n\nCan you feed Eve's cat this weekend?\n\nSincerely,\nBob")</code></pre>
<p class="tx">この三重引用符を使っていない<span class="thesansmonocd_w5regular_">print()</span>を呼び出すと先ほどと同じテキストを表示します。</p>
</section>
<section type="division" aria-labelledby="sec7">
<h5 class="h2" id="calibre_link-1597"><span class="sans_futura_std_bold_b_">複数行コメント</span></h5>
<p class="tni">シャープ記号（<span class="thesansmonocd_w5regular_">#</span>）以下の同じ行の部分はコメントになりますが、複数行のコメントを入れるには複数行文字列を使うことが多いです。</p>
<pre class="pre"><code class="calibre9">"""This is a test Python program.
Written by Al Sweigart al@inventwithpython.com

This program was designed for Python 3, not Python 2.
"""

def say_hello():
    """This function prints hello.
    It does not return anything."""
    print('Hello!')
</code></pre>
<p class="tx">この例の複数行文字列は完全に正しいPythonのコードです。</p>
</section>
</section>
<section type="division" aria-labelledby="sec8">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1193" aria-label="163"></span>
<h4 class="h1" id="calibre_link-1598"><span id="calibre_link-167"></span><span class="sans_futura_std_heavy_oblique_bi_">インデックスとスライス</span></h4>
<p class="tni">文字列ではリストと同じようにインデックスとスライスを使えます。文字列<span class="thesansmonocd_w5regular_">'Hello, world!'</span>は、各文字を要素とするリストだと考えられます。（通常の）インデックスと負の数のインデックスは以下のように対応します。</p>
<pre class="pre1"><code class="calibre9">
'   H  e   l   l   o  ,     w  o  r  l  d   !  '
    0  1   2   3   4  5  6  7  8  9 10  11 12
  -13 -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2  -1</code></pre>
<p class="tx">スペースとエクスクラメーションマーク（<span class="thesansmonocd_w5regular_">!</span>）も文字列に含まれますから、<span class="thesansmonocd_w5regular_">'Hello, world!'</span>は13文字の長さになります。インデックス0が<span class="thesansmonocd_w5regular_">H</span>で、インデックス12が<span class="thesansmonocd_w5regular_">!</span>です。</p>
<p class="tx">以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">greeting = 'Hello, world!'</b>
&gt;&gt;&gt; <b class="calibre10">greeting[0]</b>
'H'
&gt;&gt;&gt; <b class="calibre10">greeting [4]</b>
'o'
&gt;&gt;&gt; <b class="calibre10">greeting[-1]</b>
'!'
&gt;&gt;&gt; <b class="calibre10">greeting[0:5]</b>
'Hello'
&gt;&gt;&gt; <b class="calibre10">greeting[:5]</b>
'Hello'
&gt;&gt;&gt; <b class="calibre10">greeting[7:-1]</b>
'world'
&gt;&gt;&gt; <b class="calibre10">greeting[7:]</b>
'world!'
</code></pre>
<p class="tx">インデックスを指定すると、文字列中で指定した場所の文字を取得します。インデックスの範囲を指定すると、開始インデックスを含み終了インデックスを含みません。よって、<span class="thesansmonocd_w5regular_">greeting</span>が<span class="thesansmonocd_w5regular_">'Hello, world!'</span>だとすると、<span class="thesansmonocd_w5regular_">greeting[0:5]</span>は<span class="thesansmonocd_w5regular_">'Hello'</span>に評価されます。<span class="thesansmonocd_w5regular_">greeting[0:5]</span>で取得できる部分文字列は<span class="thesansmonocd_w5regular_">greeting[0]</span>から<span class="thesansmonocd_w5regular_">greeting[4]</span>までの文字をすべて含みます。インデックス<span class="thesansmonocd_w5regular_">5</span>のカンマやインデックス<span class="thesansmonocd_w5regular_">6</span>のスペースは含みません。これは<span class="thesansmonocd_w5regular_">for</span>ループの<span class="thesansmonocd_w5regular_">range(5)</span>が<span class="thesansmonocd_w5regular_">5</span>を含まないのと似ています。</p>
<p class="tx">文字列をスライスしても元の文字列は変化しないことに気をつけてください。スライスした部分を別の変数に格納することはできます。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">greeting = 'Hello, world!'</b>
&gt;&gt;&gt; <b class="calibre10">greeting_slice = greeting[0:5]</b>
&gt;&gt;&gt; <b class="calibre10">greeting_slice</b>
'Hello'
&gt;&gt;&gt; <b class="calibre10">greeting</b>
'Hello, world!'
</code></pre>
<p class="tx">スライスして取得した部分文字列を別の変数に格納すると、元の文字列と部分文字列の両方にすぐ簡単にアクセスできます。</p>
</section>
<section type="division" aria-labelledby="sec9">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-850" aria-label="164"></span>
<h4 class="h1" id="calibre_link-1599"><span id="calibre_link-168"></span><span class="sans_futura_std_heavy_oblique_bi_">in演算子とnot in演算子</span></h4>
<p class="tni">リスト値と同じように文字列値に<span class="thesansmonocd_w5regular_">in</span>演算子と<span class="thesansmonocd_w5regular_">not in</span>演算子を使うことができます。2つの文字列の間に<span class="thesansmonocd_w5regular_">in</span>演算子または<span class="thesansmonocd_w5regular_">not in</span>演算子を置くと、それがブール値の<span class="thesansmonocd_w5regular_">True</span>または<span class="thesansmonocd_w5regular_">False</span>に評価されます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'Hello' in 'Hello, World'</b>
True
&gt;&gt;&gt; <b class="calibre10">'Hello' in 'Hello'</b>
True
&gt;&gt;&gt; <b class="calibre10">'HELLO' in 'Hello, World'</b>
False
&gt;&gt;&gt; <b class="calibre10">'' in 'spam'</b>
True
&gt;&gt;&gt; <b class="calibre10">'cats' not in 'cats and dogs'</b>
False
</code></pre>
<p class="tx">これらの式は左側の文字列（大文字と小文字を区別します）が右側の文字列中に含まれるかどうかを判定します。</p>
</section>
</section>
<section type="division" aria-labelledby="sec10">
<h3 class="h" id="calibre_link-1600"><span id="calibre_link-169"></span><span class="sans_futura_std_bold_b_">f文字列</span></h3>
<p class="tni">ある文字列中に別の文字列を埋め込むことはプログラミングでよくあります。これまでは、<span class="thesansmonocd_w5regular_">+</span>演算子を使って文字列を結合してきました。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Al'</b>
&gt;&gt;&gt; <b class="calibre10">age = 4000</b>
&gt;&gt;&gt; <b class="calibre10">'Hello, my name is ' + name + '. I am ' + str(age) + ' years old.'</b>
'Hello, my name is Al. I am 4000 years old.'
&gt;&gt;&gt; <b class="calibre10">'In ten years I will be ' + str(age + 10)</b>
'In ten years I will be 4010'
</code></pre>
<p class="tx">しかし、このように入力するのは面倒です。<i class="calibre5">f文字列</i>というもっとシンプルなアプローチがあります。文字列内に変数または式を埋め込めます。raw文字列の<span class="thesansmonocd_w5regular_">r</span>と同じように、f文字列は<span class="thesansmonocd_w5regular_">f</span>をクォートの前に置きます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Al'</b>
&gt;&gt;&gt; <b class="calibre10">age = 4000</b>
&gt;&gt;&gt; <b class="calibre10">f'My name is {name}. I am {age} years old.'</b>
'My name is Al. I am 4000 years old.'
&gt;&gt;&gt; <b class="calibre10">f'In ten years I will be {age + 10}'</b>
'In ten years I will be 4010'
</code></pre>
<p class="tx">波かっこ（<span class="thesansmonocd_w5regular_">{}</span>）で囲まれた部分は、<span class="thesansmonocd_w5regular_">str()</span>関数に渡してから<span class="thesansmonocd_w5regular_">+</span>演算子で前後の文字列と結合させたかのように解釈されます。f文字列で波かっこ自体を使いたければ、波かっこを二重にします。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Zophie'</b>
&gt;&gt;&gt; <b class="calibre10">f'{name}'</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1163" aria-label="165"></span>'Zophie'
&gt;&gt;&gt; <b class="calibre10">f'{{name}}</b>'  # 波かっこ自体は波かっこを二重にする
'{name}'
</code></pre>
<p class="tx">f文字列はPythonで便利に使える機能ですが、バージョン3.6になってようやく導入されました。それよりも古いPythonのバージョンのコードでは、別のテクニックを使うことになります。</p>
</section>
<section type="division" aria-labelledby="sec11">
<h3 class="h" id="calibre_link-1601"><span id="calibre_link-170"></span><span class="sans_futura_std_bold_b_">f文字列の代替手段：%sとformat()</span></h3>
<p class="tni">バージョン3.6以前のPythonでは、文字列の中に別の文字列を埋め込むのにf文字列とは別の方法を使っていました。一つの方法は<i class="calibre5">文字列補間</i>で、別の文字列と置き換えるフォーマット指示子<span class="thesansmonocd_w5regular_">%s</span>を文字列に入れる方法です。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Al'</b>
&gt;&gt;&gt; <b class="calibre10">age = 4000</b>
&gt;&gt;&gt; <b class="calibre10">'My name is %s. I am %s years old.' % (name, age)</b>
'My name is Al. I am 4000 years old.'
&gt;&gt;&gt; <b class="calibre10">'In ten years I will be %s' % (age + 10)</b>
'In ten years I will be 4010'
</code></pre>
<p class="tx">最初の<span class="thesansmonocd_w5regular_">%s</span>が文字列のあとのかっこ内の最初の値で置き換えられ、2番目の<span class="thesansmonocd_w5regular_">%s</span>が2番目の値で置き換えられます。文字列を1つや2つ埋め込むくらいならf文字列と同じように便利ですが、埋め込む箇所が増えるとf文字列のほうがずっと読みやすいです。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">format()</span>文字列メソッドを使って埋め込む方法もあります。f文字列と同じように、文字列を埋め込む箇所に波かっこを使います。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Al'</b>
&gt;&gt;&gt; <b class="calibre10">age = 4000</b>
&gt;&gt;&gt; <b class="calibre10">'My name is {}. I am {} years old.'.format(name, age)</b>
'My name is Al. I am 4000 years old.'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">format()</span>メソッドは<span class="thesansmonocd_w5regular_">%s</span>文字列補間よりも高機能です。波かっこ内に整数値のインデックス（<span class="thesansmonocd_w5regular_">0</span>から始まります）を入れて、<span class="thesansmonocd_w5regular_">format()</span>が挿入する引数の順番を指定できます。複数の文字列を順不同で挿入するときに役立ちます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">name = 'Al'</b>
&gt;&gt;&gt; <b class="calibre10">age = 4000</b>
&gt;&gt;&gt; <b class="calibre10">'{1} years ago, {0} was born and named {0}.'.format(name, age)</b>
'4000 years ago, Al was born and named Al.'
</code></pre>
<p class="tx">これらの2つの代替手段よりもf文字列が好まれますが、既存のコードで目にする可能性がありますので、これらの方法も知っておいてください。</p>
</section>
<section type="division" aria-labelledby="sec12">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1229" aria-label="166"></span>
<h3 class="h" id="calibre_link-1602"><span id="calibre_link-171"></span><span class="sans_futura_std_bold_b_">便利な文字列メソッド</span></h3>
<p class="tni">文字列を分析したり文字列値を変形したりする文字列メソッドがいくつかあります。この節ではよく使うメソッドを説明します。（訳注：アルファベットが想定されているメソッドがありますので、日本語に適用する際には注意してください。）</p>
<section type="division" aria-labelledby="sec13">
<h4 class="h1" id="calibre_link-1603"><span id="calibre_link-172"></span><span class="sans_futura_std_heavy_oblique_bi_">大文字と小文字の変換</span></h4>
<p class="tni">文字列メソッドの<span class="thesansmonocd_w5regular_">upper()</span>と<span class="thesansmonocd_w5regular_">lower()</span>は、元の文字をすべて大文字または小文字に変換した文字列を返します。アルファベット以外の文字は変換されずそのままです。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = 'Hello, world!'</b>
&gt;&gt;&gt; <b class="calibre10">spam = spam.upper()</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
'HELLO, WORLD!'
&gt;&gt;&gt; <b class="calibre10">spam = spam.lower()</b>
&gt;&gt;&gt; <b class="calibre10">spam</b>
'hello, world!'
</code></pre>
<p class="tx">これらのメソッドは、元の文字列を変更するのではなく、新しい文字列値を返すことに注意してください。元の文字列を変更したければ、<span class="thesansmonocd_w5regular_">upper()</span>または<span class="thesansmonocd_w5regular_">lower()</span>を呼び出した得た結果を元の文字列を格納していた変数の格納してください。変数<span class="thesansmonocd_w5regular_">spam</span>に格納されている文字列を変更するときには、<span class="thesansmonocd_w5regular_">spam.upper()</span>ではなく<span class="thesansmonocd_w5regular_">spam</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">spam.upper()</span>と書かなければなりません。（変数<span class="thesansmonocd_w5regular_">eggs</span>が<span class="thesansmonocd_w5regular_">10</span>という値を格納しているときに、<span class="thesansmonocd_w5regular_">eggs</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">3</span>と書いても<span class="thesansmonocd_w5regular_">eggs</span>の値は変更されず、変更するためには<span class="thesansmonocd_w5regular_">eggs</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">eggs</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">3</span>と書くのと同じです。）</p>
<p class="tx"><span class="thesansmonocd_w5regular_">upper()</span>メソッドと<span class="thesansmonocd_w5regular_">lower()</span>メソッドは、大文字と小文字を区別せずに比較したいときに便利です。例えば、<span class="thesansmonocd_w5regular_">'great'</span>と<span class="thesansmonocd_w5regular_">'GREat'</span>は等しくありませんが、以下のプログラムではユーザーが<span class="thesansmonocd_w5regular_">Great</span>、<span class="thesansmonocd_w5regular_">GREAT</span>、<span class="thesansmonocd_w5regular_">grEAT</span>のどれを入力しても対応できるようにしてあります。ユーザーが入力した文字列を小文字に変換しているからです。</p>
<pre class="pre"><code class="calibre9">print('How are you?')
feeling = input()
if feeling.lower() == 'great':
    print('I feel great too.')
else:
    print('I hope the rest of your day is good.')
</code></pre>
<p class="tx">このプログラムを実行すると、質問を表示して、ユーザーが<span class="thesansmonocd_w5regular_">GREat</span>のような<span class="thesansmonocd_w5regular_">great</span>に相当する内容を入力すれば、<span class="thesansmonocd_w5regular_">I feel great too.</span>と出力します。大文字と小文字の違いなど、ユーザーの入力の表記ゆれや間違いに対応できるようにすれば、プログラムがうまく動かなくなる可能性を減らせます。</p>
<pre class="pre"><code class="calibre9">How are you?
<b class="calibre10">GREat</b>
I feel great too.
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1199" aria-label="167"></span><span class="thesansmonocd_w5regular_">isupper()</span>メソッドと<span class="thesansmonocd_w5regular_">islower()</span>メソッドは、対象文字列に少なくとも1つのアルファベットが含まれていて、そのアルファベットがすべて大文字または小文字であればブール値<span class="thesansmonocd_w5regular_">True</span>を返します。それ以外の場合は<span class="thesansmonocd_w5regular_">False</span>を返します。以下のコードを対話型シェルに入力して、それぞれのメソッドの返り値を確認してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = 'Hello, world!'</b>
&gt;&gt;&gt; <b class="calibre10">spam.islower()</b>
False
&gt;&gt;&gt; <b class="calibre10">spam.isupper()</b>
False
&gt;&gt;&gt; <b class="calibre10">'HELLO'.isupper()</b>
True
&gt;&gt;&gt; <b class="calibre10">'abc12345'.islower()</b>
True
&gt;&gt;&gt; <b class="calibre10">'12345'.islower()</b>
False
&gt;&gt;&gt; <b class="calibre10">'12345'.isupper()</b>
False
</code></pre>
<p class="tx">文字列メソッドの<span class="thesansmonocd_w5regular_">upper()</span>と<span class="thesansmonocd_w5regular_">lower()</span>は文字列を返しますから、返された文字列値に対してさらに文字列メソッドを呼び出すことができます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'Hello'.upper()</b>
'HELLO'
&gt;&gt;&gt; <b class="calibre10">'Hello'.upper().lower()</b>
'hello'
&gt;&gt;&gt; <b class="calibre10">'Hello'.upper().lower().upper()</b>
'HELLO'
&gt;&gt;&gt; <b class="calibre10">'HELLO'.lower()</b>
'hello'
&gt;&gt;&gt; <b class="calibre10">'HELLO'.lower().islower()</b>
True
</code></pre>
<p class="tx">こうした式ではメソッド呼び出しが連鎖しているように見えます。</p>
</section>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1604"><span id="calibre_link-173"></span><span class="sans_futura_std_heavy_oblique_bi_">文字列を構成する文字のチェック</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">islower()</span>と<span class="thesansmonocd_w5regular_">isupper()</span>に加えて、<i class="calibre5">is</i>で始まる文字列メソッドがほかにもいくつかあります。これらのメソッドは文字列の特性に応じてブール値を返します。よく使う<span class="thesansmonocd_w5regular_">is</span><span class="sans_thesansmonocd_w5regular_italic_">X</span><span class="thesansmonocd_w5regular_">()</span>文字列メソッドを紹介します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">isalpha()</span> 文字列が文字だけで構成されていたら<span class="thesansmonocd_w5regular_">True</span>を返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">isalnum()</span> 文字列が文字と数字だけで構成されていたら<span class="thesansmonocd_w5regular_">True</span>を返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">isdecimal()</span> 文字列が数字だけで構成されていたら<span class="thesansmonocd_w5regular_">True</span>を返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">isspace()</span> 文字列がスペース、タブ、改行だけで構成されていたら<span class="thesansmonocd_w5regular_">True</span>を返します。</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">istitle()</span> 文字列が大文字で始まりその他は小文字である単語だけで構成されていたら<span class="thesansmonocd_w5regular_">True</span>を返します。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1200" aria-label="168"></span>以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'hello'.isalpha()</b>
True
&gt;&gt;&gt; <b class="calibre10">'hello123'.isalpha()</b>
False
&gt;&gt;&gt; <b class="calibre10">'hello123'.isalnum()</b>
True
&gt;&gt;&gt; <b class="calibre10">'hello'.isalnum()</b>
True
&gt;&gt;&gt; <b class="calibre10">'123'.isdecimal()</b>
True
&gt;&gt;&gt; <b class="calibre10">'    '.isspace()</b>
True
&gt;&gt;&gt; <b class="calibre10">'This Is Title Case'.istitle()</b>
True
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">is</span><span class="sans_thesansmonocd_w5regular_italic_">X</span><span class="thesansmonocd_w5regular_">()</span>文字列メソッドはユーザーの入力を検証する必要があるときに役立ちます。例えば、以下のプログラムは、正しく入力されるまでユーザーに年齢とパスワードを繰り返し尋ねます。新しいファイルエディタウィンドウを開いて、以下のコードを<i class="calibre5">validateInput.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">while True:
    print('Enter your age:')
    age = input()
    if age.isdecimal():
        break
    print('Please enter a number for your age.')

while True:
    print('Select a new password (letters and numbers only):')
    password = input()
    if password.isalnum():
        break
    print('Passwords can only have letters and numbers.')
</code></pre>
<p class="tx">最初の<span class="thesansmonocd_w5regular_">while</span>ループでは、ユーザーに年齢を尋ね、入力された値を<span class="thesansmonocd_w5regular_">age</span>に格納しています。<span class="thesansmonocd_w5regular_">age</span>が正しい値（数字の値）であれば、最初の<span class="thesansmonocd_w5regular_">while</span>ループから抜け、パスワードを尋ねる2つ目の<span class="thesansmonocd_w5regular_">while</span>ループに進みます。正しい値でなければ、ユーザーに数字を入力する必要があることを伝えて、もう一度年齢を尋ねます。2つ目の<span class="thesansmonocd_w5regular_">while</span>ループでは、パスワードを尋ね、入力された値を<span class="thesansmonocd_w5regular_">password</span>に格納し、その値が文字と数字だけで構成されていたらループを抜けます。そうでなければ、その値を受け入れられないので、パスワードには文字と数字しか使えないことをユーザーに伝えて、もう一度パスワードを入力してもらいます。</p>
<p class="tx">このプログラムを実行すると、次のように出力されます。</p>
<pre class="pre"><code class="calibre9">Enter your age:
<b class="calibre10">forty two</b>
Please enter a number for your age.
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1133" aria-label="169"></span>Enter your age:
<b class="calibre10">42</b>
Select a new password (letters and numbers only):
<b class="calibre10">secr3t!</b>
Passwords can only have letters and numbers.
Select a new password (letters and numbers only):
<b class="calibre10">secr3t</b>
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">isdecimal()</span>と<span class="thesansmonocd_w5regular_">isalnum()</span>を変数について呼び出し、その変数に格納されている値が数字だけで構成されているか、文字と数字だけで構成されているかを検証しています。<span class="thesansmonocd_w5regular_">forty two</span>を拒否して<span class="thesansmonocd_w5regular_">42</span>を受け入れていますし、<span class="thesansmonocd_w5regular_">secr3t!</span>を拒否して<span class="thesansmonocd_w5regular_">secr3t</span>を受け入れています。</p>
</section>
<section type="division" aria-labelledby="sec15">
<h4 class="h1" id="calibre_link-1605"><span id="calibre_link-174"></span><span class="sans_futura_std_heavy_oblique_bi_">文字列の先頭または末尾をチェックする</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">startswith()</span>メソッドと<span class="thesansmonocd_w5regular_">endswith()</span>メソッドは、文字列値がメソッドに渡された文字列で始まっていればあるいは終わっていれば、<span class="thesansmonocd_w5regular_">True</span>を返します。それ以外の場合は<span class="thesansmonocd_w5regular_">False</span>を返します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'Hello, world!'.startswith('Hello')</b>
True
&gt;&gt;&gt; <b class="calibre10">'Hello, world!'.endswith('world!')</b>
True
&gt;&gt;&gt; <b class="calibre10">'abc123'.startswith('abcdef')</b>
False
&gt;&gt;&gt; <b class="calibre10">'abc123'.endswith('12')</b>
False
&gt;&gt;&gt; <b class="calibre10">'Hello, world!'.startswith('Hello, world!')</b>
True
&gt;&gt;&gt; <b class="calibre10">'Hello, world!'.endswith('Hello, world!')</b>
True
</code></pre>
<p class="tx">これらのメソッドは等価演算子（<span class="thesansmonocd_w5regular_">==</span>）の代わりに使えます。文字列全体ではなく、文字列の最初や最後だけをチェックすればよい場合に便利です。</p>
</section>
<section type="division" aria-labelledby="sec16">
<h4 class="h1" id="calibre_link-1606"><span id="calibre_link-175"></span><span class="sans_futura_std_heavy_oblique_bi_">文字列の連結と分割</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">join()</span>メソッドは、文字列のリストがあり、その文字列を連結して一つの文字列値を作成したいときに使います。文字列について<span class="thesansmonocd_w5regular_">join()</span>メソッドを呼び出し、文字列のリストを渡します。そうすると渡されたリストをその文字列で連結したものが返されます。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">', '.join(['cats', 'rats', 'bats'])</b>
'cats, rats, bats'
&gt;&gt;&gt; <b class="calibre10">' '.join(['My', 'name', 'is', 'Simon'])</b>
'My name is Simon'
&gt;&gt;&gt; <b class="calibre10">'ABC'.join(['My', 'name', 'is', 'Simon'])</b>
'MyABCnameABCisABCSimon'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1288" aria-label="170"></span><span class="thesansmonocd_w5regular_">join()</span>を呼び出した文字列が、引数に渡されたリストの各文字列の間に挿入されます。例えば、<span class="thesansmonocd_w5regular_">', '</span>という文字列について<span class="thesansmonocd_w5regular_">join(['cats', 'rats', 'bats'])</span>を呼び出すと、<span class="thesansmonocd_w5regular_">'cats, rats, bats'</span>という文字列が返されます。</p>
<p class="tx">文字列について<span class="thesansmonocd_w5regular_">join()</span>を呼び出し、リスト値を渡すということを覚えておいてください（間違えて逆にして呼び出してしまうことがよくあります）。<span class="thesansmonocd_w5regular_">split()</span>メソッドは反対の動作をします。つまり、文字列値に対して呼び出すと、文字列のリストを返します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'My name is Simon'.split()</b>
['My', 'name', 'is', 'Simon']
</code></pre>
<p class="tx">デフォルトでは、スペース、タブ、改行文字といった空白文字で文字列<span class="thesansmonocd_w5regular_">'My name is Simon'</span>を分割します。これらの空白文字は返されるリスト中の文字列には含まれません。区切り文字を<span class="thesansmonocd_w5regular_">split()</span>メソッドに渡して指定することができます。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'MyABCnameABCisABCSimon'.split('ABC')</b>
['My', 'name', 'is', 'Simon']
&gt;&gt;&gt; <b class="calibre10">'My name is Simon'.split('m')</b>
['My na', 'e is Si', 'on']
</code></pre>
<p class="tx">複数行文字列を改行文字で区切るために<span class="thesansmonocd_w5regular_">split()</span>をよく使います。対話型シェルで次のように入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt;<b class="calibre10"> spam = '''Dear Alice,</b>
... <b class="calibre10">There is a milk bottle in the fridge</b>
... <b class="calibre10">that is labeled "Milk Experiment."</b>
...
... <b class="calibre10">Please do not drink it.</b>
... <b class="calibre10">Sincerely,</b>
... <b class="calibre10">Bob'''</b>
...
&gt;&gt;&gt; <b class="calibre10">spam.split('\n')</b>
['Dear Alice,', 'There is a milk bottle in the fridge',
'that is labeled "Milk Experiment."', '', 'Please do not drink it.',
'Sincerely,', 'Bob']
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">split()</span>に引数<span class="thesansmonocd_w5regular_">'\n'</span>を渡すと、<span class="thesansmonocd_w5regular_">spam</span>に格納されている複数行文字列を改行文字で分割して、1行ずつ要素に入れたリストが返されます。</p>
</section>
<section type="division" aria-labelledby="sec17">
<h4 class="h1" id="calibre_link-1607"><span id="calibre_link-176"></span><span class="sans_futura_std_heavy_oblique_bi_">テキストの左寄せ、右寄せ、中央寄せ</span></h4>
<p class="tni">文字列メソッドの<span class="thesansmonocd_w5regular_">rjust()</span>と<span class="thesansmonocd_w5regular_">ljust()</span>は文字列を空白で詰めたものを返します。第一引数は出来上がりの文字列の長さです。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'Hello'.rjust(10)</b>
'     Hello'
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1004" aria-label="171"></span>&gt;&gt;&gt; <b class="calibre10">'Hello'.rjust(20)</b>
'              Hello'
&gt;&gt;&gt; <b class="calibre10">'Hello, World'.rjust(20)</b>
'         Hello, World'
&gt;&gt;&gt; <b class="calibre10">'Hello'.ljust(10)</b>
'Hello     '
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">'Hello'.rjust(10)</span>は「文字列<span class="thesansmonocd_w5regular_">'Hello'</span>を合計<span class="thesansmonocd_w5regular_">10</span>文字になるように右寄せしてください」と読めます。<span class="thesansmonocd_w5regular_">'Hello'</span>は5文字ですから、5個のスペースが左側に詰められ、<span class="thesansmonocd_w5regular_">'Hello'</span>を右寄せした10文字の文字列になります。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">rjust()</span>と<span class="thesansmonocd_w5regular_">ljust()</span>のオプションの第二引数は、スペース以外の詰める文字を指定します。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'Hello'.rjust(20, '*')</b>
'***************Hello'
&gt;&gt;&gt; <b class="calibre10">'Hello'.ljust(20, '-')</b>
'Hello---------------'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">center()</span>文字列メソッドは<span class="thesansmonocd_w5regular_">ljust()</span>や<span class="thesansmonocd_w5regular_">rjust()</span>と似ていますが、中央寄せにします。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">'Hello'.center(20)</b>
'       Hello        '
&gt;&gt;&gt; <b class="calibre10">'Hello'.center(20, '=')</b>
'=======Hello========'
</code></pre>
<p class="tx">表示されたテキストは中央寄せになっています。</p>
</section>
<section type="division" aria-labelledby="sec18">
<h4 class="h1" id="calibre_link-1608"><span id="calibre_link-177"></span><span class="sans_futura_std_heavy_oblique_bi_">空白の削除</span></h4>
<p class="tni">空白文字（スペース、タブ、改行文字）を、文字列の片側あるいは両側から切り落としたいときがあるでしょう。文字列メソッド<span class="thesansmonocd_w5regular_">strip()</span>は、文字列の始まりと終わりの空白を削除した新しい文字列を返します。<span class="thesansmonocd_w5regular_">lstrip()</span>は左側（始まり）から、<span class="thesansmonocd_w5regular_">rstrip()</span>は右側（終わり）から空白文字を取り除きます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = '    Hello, World    '</b>
&gt;&gt;&gt; <b class="calibre10">spam.strip()</b>
'Hello, World'
&gt;&gt;&gt; <b class="calibre10">spam.lstrip()</b>
'Hello, World    '
&gt;&gt;&gt; <b class="calibre10">spam.rstrip()</b>
'    Hello, World'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-956" aria-label="172"></span>オプションで取り除く文字を指定できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">spam = 'SpamSpamBaconSpamEggsSpamSpam'</b>
&gt;&gt;&gt; <b class="calibre10">spam.strip('ampS')</b>
'BaconSpamEggs'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">strip()</span>に引数<span class="thesansmonocd_w5regular_">'ampS'</span>を渡しているので、<span class="thesansmonocd_w5regular_">spam</span>に格納されている文字列の両端から<span class="thesansmonocd_w5regular_">a</span>、<span class="thesansmonocd_w5regular_">m</span>、<span class="thesansmonocd_w5regular_">p</span>、<span class="thesansmonocd_w5regular_">S</span>を切り落とします。<span class="thesansmonocd_w5regular_">strip()</span>に渡す文字の順番は関係ありません。<span class="thesansmonocd_w5regular_">strip('ampS')</span>と<span class="thesansmonocd_w5regular_">strip('mapS')</span>と<span class="thesansmonocd_w5regular_">strip('Spam')</span>は同じ動作になります。</p>
</section>
</section>
<section type="division" aria-labelledby="sec19">
<h3 class="h" id="calibre_link-1609"><span id="calibre_link-178"></span><span class="sans_futura_std_bold_b_">文字の数値コード</span></h3>
<p class="tni">コンピュータは情報を<i class="calibre5">バイト</i>（0と1の列）として保存します。つまり、テキストを数値に変換できなければならないということです。この要請から、すべてのテキスト文字は<i class="calibre5">Unicodeコードポイント</i>と呼ばれる数値と対応します。例えば、<span class="thesansmonocd_w5regular_">'A'</span>の数値コードは<span class="thesansmonocd_w5regular_">65</span>で、<span class="thesansmonocd_w5regular_">'4'</span>の数値コードは<span class="thesansmonocd_w5regular_">52</span>で、<span class="thesansmonocd_w5regular_">'!'</span>の数値コードは<span class="thesansmonocd_w5regular_">33</span>です。<span class="thesansmonocd_w5regular_">ord()</span>関数を使うと指定した文字の数値コードを取得でき、<span class="thesansmonocd_w5regular_">chr()</span>関数を使うと指定した数値コードの文字を取得できます。以下の式を対話型シェルに入力してみてください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">ord('A')</b>
65
&gt;&gt;&gt; <b class="calibre10">ord('4')</b>
52
&gt;&gt;&gt; <b class="calibre10">ord('!')</b>
33
&gt;&gt;&gt; <b class="calibre10">chr(65)</b>
'A'
</code></pre>
<p class="tx">文字を順番に並べたり、文字の数値計算を行ったりする必要があるときに、これらの関数を使えます。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">ord('B')</b>
66
&gt;&gt;&gt; <b class="calibre10">ord('A') &lt; ord('B')</b>
True
&gt;&gt;&gt; <b class="calibre10">chr(ord('A'))</b>
'A'
&gt;&gt;&gt; <b class="calibre10">chr(ord('A') + 1)</b>
'B'
</code></pre>
<p class="tx">Unicodeコードポイントはこれだけではありませんが、詳細に入ると本書の範囲を逸脱してしまいます。もっと知りたければ、<i class="calibre5"><a href="https://nedbatchelder.com/text/unipain.html" class="calibre1">https://<wbr></wbr>nedbatchelder<wbr></wbr>.com<wbr></wbr>/text<wbr></wbr>/unipain<wbr></wbr>.html</a></i> でNed Batchelderの2012 PyCon talk, “Pragmatic Unicode, or How Do I Stop the Pain?”を見るか読むかするのをおすすめします。</p>
<p class="tx">文字列をファイルに書き込んだりインターネットで送ったりするときには、テキストからバイトに変換します。これを<i class="calibre5">エンコード</i>と呼びます。Unicodeのエンコード基準がいくつかありますが、最もよく使われるのはUTF-8です。Unicodeのエンコーディングを選ぶ必要があったとしたら、<span class="thesansmonocd_w5regular_">'utf-8'</span>を選んでおけばまず間違いないです。Tom Scottの“Characters, Symbols and the Unicode Miracle”という題名の動画（<i class="calibre5"><a href="https://youtu.be/MijmeoH9LT4" class="calibre1">https://<wbr></wbr>youtu<wbr></wbr>.be<wbr></wbr>/MijmeoH9LT4</a></i>）でUTF-8について説明されています。</p>
</section>
<section type="division" aria-labelledby="sec20">
<h3 class="h" id="calibre_link-1610"><span id="calibre_link-179"></span><span class="sans_futura_std_bold_b_">文字列のコピーアンドペースト</span></h3>
<p class="tni"><span class="thesansmonocd_w5regular_">pyperclip</span>モジュールには、コンピュータのクリップボードからテキストをコピーアンドペーストできる<span class="thesansmonocd_w5regular_">copy()</span>関数と<span class="thesansmonocd_w5regular_">paste()</span>関数があります。プログラムの出力をクリップボードに送れば、メールやワープロソフトなどに簡単に貼り付けられます。</p>
<p class="tx"><span class="thesansmonocd_w5regular_">pyperclip</span>モジュールはPython本体には付属していません。<span>Appendix A</span>のサードパーティのパッケージのインストール手順の指示に従ってインストールしてください。<span class="thesansmonocd_w5regular_">pyperclip</span>をインストールしてから、対話型シェルで次のように入力してください。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import pyperclip</b>
&gt;&gt;&gt; <b class="calibre10">pyperclip.copy('Hello, world!')</b>
&gt;&gt;&gt; <b class="calibre10">pyperclip.paste()</b>
'Hello, world!'
</code></pre>
<p class="tx">プログラム外でクリップボードの内容を変更すると、<span class="thesansmonocd_w5regular_">paste()</span>関数の結果が変わります。例えば、"For example, if I copied this sentence to the clipboard and then called
paste(), it would look like this:"をクリップボードに貼り付けてから<span class="thesansmonocd_w5regular_">paste()</span>を呼び出すと、次のようになります。</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">pyperclip.paste()</b>
'For example, if I copied this sentence to the clipboard and then called
paste(), it would look like this:'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">input()</span>関数を呼び出して入力しなくても大量のテキストを受け取ることができるので、クリップボードは便利です。例えば、aLtErNaTiNgのように小文字と大文字を交互に繰り返すプログラムを書くとしましょう。小文字と大文字を交互に繰り返したいテキストをクリップボードにコピーして、このプログラムを実行してください。そうするとプログラムがクリップボードを読み取り、小文字と大文字を交互に繰り返したテキストをクリップボードに保存します。以下のコードを<i class="calibre5">alternatingText.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import pyperclip

text = pyperclip.paste()  # クリップボードからテキストを取得
alt_text = ''  # 小文字と大文字を交互に繰り返したテキストを格納
make_uppercase = False
for character in text:
    # 各文字を反復処理してalt_textに追加
    if make_uppercase:
        alt_text += character.upper()
    else:
        alt_text += character.lower()

    # make_uppercaseの値を反転
    make_uppercase = not make_uppercase
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-886" aria-label="174"></span>pyperclip.copy(alt_text)  # 結果をクリップボードに保存
print(alt_text)  # 結果を画面にも表示
</code></pre>
<p class="tx">クリップボードにテキスト（例えば"If you copy some text to the clipboard (for instance, this sentence) and run this program, the output and clipboard contents become this:"）をコピーしてこのプログラムを実行すると、出力とクリップボードに保存されている内容は次のものになります。</p>
<pre class="pre"><code class="calibre9">iF YoU CoPy sOmE TeXt tO ThE ClIpBoArD (fOr iNsTaNcE, tHiS SeNtEnCe) AnD
 RuN ThIs pRoGrAm, ThE OuTpUt aNd cLiPbOaRd cOnTeNtS BeCoMe ThIs:
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">pyperclip</span>モジュールを活用すればクリップボードを操作できるので、プログラムとテキストのやり取りを直接できるようになります。</p>
<p class="ph"><span id="calibre_link-180"></span><span class="sans_futura_std_heavy_b_">プロジェクト2：ウィキマークアップに箇条書き記号を追加する</span></p>
<p class="tni">Wikipediaの記事を編集する際には、各項目の行頭にアスタリスクをつけると箇条書きリストを作成できます。箇条書きリストにしたい長いリストがあるとします。1行ずつ行頭にアスタリスクを入れていってもいいのですが、ちょっとしたPythonスクリプトを書けばその作業を自動化できます。</p>
<p class="tx"><i class="calibre5">bulletPointAdder.py</i>スクリプトはクリップボードからテキストを取得して、アスタリスクとスペースを各行の行頭に入れ、その追加後のテキストをクリップボードに保存します。例えば、以下のテキスト（List of lists of listsというWikipediaの記事）をクリップボードにコピーしたとします。</p>
<pre class="pre"><code class="calibre9">Lists of animals
Lists of aquarium life
Lists of biologists by author abbreviation
Lists of cultivars
</code></pre>
<p class="tx">その状態で<i class="calibre5">bulletPointAdder.py</i>プログラムを実行すると、クリップボードの内容は以下のようになります。</p>
<pre class="pre"><code class="calibre9">* Lists of animals
* Lists of aquarium life
* Lists of biologists by author abbreviation
* Lists of cultivars
</code></pre>
<p class="tx">このテキストをWikipediaの記事に貼り付けると箇条書きになります。</p>
<section type="division" aria-labelledby="sec21">
<h4 class="h1" id="calibre_link-1611"><span id="calibre_link-181"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ1：クリップボードのコピーアンドペースト</span></h4>
<p class="tni"><i class="calibre5">bulletPointAdder.py</i>プログラムは以下の内容を実行します。</p>
<ul class="ul">
<li class="bl">クリップボードからテキストを取得する</li>
<li class="bl">そのテキストに対して何らかの処理を行う</li>
<li class="bl">新しいテキストをクリップボードに保存する</li>
</ul>
<p class="tx">テキストの処理は少しややこしいですが、コピーアンドペーストはごく単純です。<span class="thesansmonocd_w5regular_">pyperclip.copy()</span>関数と<span class="thesansmonocd_w5regular_">pyperclip.paste()</span> <span role="doc-pagebreak" type="pagebreak" id="calibre_link-1061" aria-label="175"></span>関数を使うだけです。とりあえずその関数を呼び出す部分を書いてみましょう。次のコードを<i class="calibre5">bulletPointAdder.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9">import pyperclip
text = pyperclip.paste()

# TODO：行を分割してアスタリスクをつける

pyperclip.copy(text)
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">TODO</span>コメントはプログラムの未完成部分を示します。次にその部分に取り組みます。</p>
</section>
<section type="division" aria-labelledby="sec22">
<h4 class="h1" id="calibre_link-1612"><span id="calibre_link-182"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ2：テキストを行ごとに分割する</span></h4>
<p class="tni"><span class="thesansmonocd_w5regular_">pyperclip.paste()</span>を呼び出すと、クリップボードに保存されているテキストがすべて一つの大きな文字列として返されます。“List of Lists of Lists”の例で言うと、<span class="thesansmonocd_w5regular_">text</span>に格納される文字列は次のようになります。</p>
<pre class="pre"><code class="calibre9">'Lists of animals\nLists of aquarium life\nLists of biologists by author
abbreviation\nLists of cultivars'
</code></pre>
<p class="tx">この文字列中の改行文字<span class="thesansmonocd_w5regular_">\n</span>により、クリップボードから貼り付けたときに複数行で表示されます。この一つの文字列値には複数の「行」があるということです。各行の行頭にアスタリスクをつけたいです。</p>
<p class="tx">文字列の中から改行文字<span class="thesansmonocd_w5regular_">\n</span>を一つずつ探してその直後にアスタリスクを加えるコードを書くこともできます。しかし、<span class="thesansmonocd_w5regular_">split()</span>メソッドを使って元の文字列を一行ずつ分割した文字列のリストを取得し、リストの中に入っている各文字列の先頭にアスタリスクを加えるほうが簡単でしょう。</p>
<p class="tx">次のようにプログラムを編集してください。</p>
<pre class="pre"><code class="calibre9">import pyperclip
text = pyperclip.paste()

# 行を分割してアスタリスクをつける
<b class="calibre10">lines = text.split('\n')</b>
<b class="calibre10">for i in range(len(lines)):  </b># リスト"lines"のすべてのインデックスを反復処理
<b class="calibre10">    lines[i] = '* ' + lines[i] </b># リスト"lines"の各文字列にアスタリスクをつける

pyperclip.copy(text)
</code></pre>
<p class="tx">テキストを改行で分割してリストを取得します。そのリストを<span class="thesansmonocd_w5regular_">lines</span>という名前の変数に格納し、ループで各要素を反復処理します。行ごとに行頭にアスタリスクとスペースを加えます。そうすれば<span class="thesansmonocd_w5regular_">lines</span>の中に入っている各行すべてにアスタリスクがつきます。</p>
</section>
<section type="division" aria-labelledby="sec23">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1261" aria-label="176"></span>
<h4 class="h1" id="calibre_link-1613"><span id="calibre_link-183"></span><span class="sans_futura_std_heavy_oblique_bi_">ステップ3：調整した各行を連結する</span></h4>
<p class="tni">リスト<span class="thesansmonocd_w5regular_">lines</span>にはアスタリスクで始まるように調整した行が入っています。しかし、<span class="thesansmonocd_w5regular_">pyperclip.copy()</span>は文字列が入ったリストではなく、一つの文字列値を取ります。一つの文字列値を作るために、<span class="thesansmonocd_w5regular_">join()</span>メソッドに<span class="thesansmonocd_w5regular_">lines</span>を渡してリスト中の文字列を連結した一つの文字列を取得します。</p>
<pre class="pre"><code class="calibre9">import pyperclip
text = pyperclip.paste()

# 行を分割してアスタリスクをつける
lines = text.split('\n')
for i in range(len(lines)):  # リスト"lines"のすべてのインデックスを反復処理
    lines[i] = '* ' + lines[i]  # リスト"lines"の各文字列にアスタリスクをつける
<b class="calibre10">text = '\n'.join(lines)</b>
pyperclip.copy(text)
</code></pre>
<p class="tx">このプログラムを実行すると、クリップボードのテキストを、各行にアスタリスクをつけたものに置き換えます。これでプログラムは完成ですから、クリップボードにテキストをコピーしてから実行してみてください。</p>
<p class="tx">この箇条書きを自動化する作業は必要ないとしても、行末のスペースを落とすとか、テキストを大文字または小文字に変換するといった、似たようなテキスト操作を自動化する必要を感じることはあるかもしれません。どのような作業であっても、クリップボードを通じてテキストのやり取りができます。</p>
</section>
</section>
<section type="division" aria-labelledby="sec24">
<h3 class="h" id="calibre_link-1614"><span id="calibre_link-184"></span><span class="sans_futura_std_bold_b_">短いプログラム：ピッグ・ラテン（訳注：英語をラテン語風に変換する言葉遊び）</span></h3>
<p class="tni">ピッグ・ラテンは英語をラテン語風に変換します。母音で始まる単語には<i class="calibre5">yay</i>をつけます。子音（<i class="calibre5">ch</i>や<i class="calibre5">gr</i>のような連結子音を含む）で始まる単語は、その子音（連結子音）を語末に移し、さらに<i class="calibre5">ay</i>をつけます。</p>
<p class="tx">次のように出力するピッグ・ラテンプログラムを書いてみましょう。</p>
<pre class="pre"><code class="calibre9">Enter the English message to translate into pig latin:
<b class="calibre10">My name is AL SWEIGART and I am 4,000 years old.</b>
Ymay amenay isyay ALYAY EIGARTSWAY andyay Iyay amyay 4,000 yearsyay oldyay.
</code></pre>
<p class="tx">このプログラムでは、本章で紹介したメソッドを使って文字列を変換しています。次のコードを<i class="calibre5">pigLat.py</i>という名前で保存してください。</p>
<pre class="pre"><code class="calibre9"># 英語からピッグ・ラテンに変換
print('Enter the English message to translate into pig latin:')
message = input()

VOWELS = ('a', 'e', 'i', 'o', 'u', 'y')

pig_latin = [] # ピッグ・ラテンに変換した単語のリスト
for word in message.split():
    # 語頭の非アルファベットを分離
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1615" aria-label="177"></span>    prefix_non_letters = ''
    while len(word) &gt; 0 and not word[0].isalpha():
        prefix_non_letters += word[0]
        word = word[1:]
    if len(word) == 0:
        pig_latin.append(prefix_non_letters)
        continue

    # 語末の非アルファベットを分離
    suffix_non_letters = ''
    while not word[-1].isalpha():
        suffix_non_letters = word[-1] + suffix_non_letters
        word = word[:-1]

    # その語が全部大文字なのか先頭が大文字なのかを記憶
    was_upper = word.isupper()
    was_title = word.istitle()

    word = word.lower() # 変換するために単語を全部小文字に

    # 語頭の子音を分離
    prefix_consonants = ''
    while len(word) &gt; 0 and not word[0] in VOWELS:
        prefix_consonants += word[0]
        word = word[1:]

    # ピッグ・ラテンの語尾を追加
    if prefix_consonants != '':
        word += prefix_consonants + 'ay'
    else:
        word += 'yay'

    # 全部大文字または先頭が大文字を復元
    if was_upper:
        word = word.upper()
    if was_title:
        word = word.title()

    # 語頭と語末に非アルファベットを復元
    pig_latin.append(prefix_non_letters + word + suffix_non_letters)

# すべての単語を一つの文字列に連結
print(' '.join(pig_latin))
</code></pre>
<p class="tx">このコードを最初から一行ずつ見ていきましょう。</p>
<pre class="pre"><code class="calibre9"># 英語からピッグ・ラテンに変換
print('Enter the English message to translate into pig latin:')
message = input()

VOWELS = ('a', 'e', 'i', 'o', 'u', 'y')
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1616" aria-label="178"></span>まず、ピッグ・ラテンに変換する英語のテキストをユーザーに入力してもらいます。また、小文字の母音（<i class="calibre5">y</i>を含む）を保持する定数をタプルで設定します。あとでこれを使います。</p>
<p class="tx">次に、英語をピッグ・ラテンに変換した語を格納する変数<span class="thesansmonocd_w5regular_">pigLatin</span>を作成します。</p>
<pre class="pre"><code class="calibre9">pigLatin = [] # ピッグ・ラテンに変換した単語のリスト
for word in message.split():
    # 語頭の非アルファベットを分離
    prefixNonLetters = ''
    while len(word) &gt; 0 and not word[0].isalpha():
        prefixNonLetters += word[0]
        word = word[1:]
    if len(word) == 0:
        pigLatin.append(prefixNonLetters)
        continue
</code></pre>
<p class="tx">単語ごとに変換する必要がありますから、<span class="thesansmonocd_w5regular_">message.split()</span>を呼び出して単語のリストを得ます。文字列<span class="thesansmonocd_w5regular_">'My name is AL SWEIGART and I am 4,000 years old.'</span>に<span class="thesansmonocd_w5regular_">split()</span>を適用すると、<span class="thesansmonocd_w5regular_">['My', 'name', 'is', 'AL', 'SWEIGART', 'and', 'I', 'am', '4,000', 'years', 'old.']</span>が返されます。</p>
<p class="tx"> <span class="thesansmonocd_w5regular_">'old.'</span>のような文字列を<span class="thesansmonocd_w5regular_">'old.yay'</span>ではなく <span class="thesansmonocd_w5regular_">'oldyay.'</span>へと変換できるように、それぞれの単語の語頭と語末からアルファベット以外の部分を除去する必要があります。この非アルファベットを<span class="thesansmonocd_w5regular_">prefixNonLetters</span>という名前の変数に保存しておきます。</p>
<pre class="pre"><code class="calibre9">    # 語末の非アルファベットを分離
    suffixNonLetters = ''
    while not word[-1].isalpha():
        suffixNonLetters += word[-1] + suffixNonLetters
        word = word[:-1]
</code></pre>
<p class="tx">単語の最初の文字について<span class="thesansmonocd_w5regular_">isalpha()</span>を呼び出すループで、語頭を除去するかどうかを判定します。語頭を除去する場合は<span class="thesansmonocd_w5regular_">prefixNonLetters</span>と結合します。<span class="thesansmonocd_w5regular_">'4,000'</span>のように単語全体が非アルファベットなら、単に<span class="thesansmonocd_w5regular_">pigLatin</span>リストに追加して次の語に進みます。<span class="thesansmonocd_w5regular_">word</span>文字列の語末の非アルファベットを保存しておく必要もあります。その部分のコードは先ほどのループに似ています。</p>
<p class="tx">次に、ピッグ・ラテンへの変換後に復元できるよう、その語が全部大文字なのか先頭が大文字なのかを記憶しておきます。</p>
<pre class="pre"><code class="calibre9">    # その語が全部大文字なのか先頭が大文字なのかを記憶
    wasUpper = word.isupper()
    wasTitle = word.istitle()

    word = word.lower() # 変換するために単語を全部小文字に
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループの残りのコードでは<span class="thesansmonocd_w5regular_">word</span>を小文字で扱います。</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1617" aria-label="179"></span><i class="calibre5">sweigart</i>を<i class="calibre5">eigart-sway</i>のように変換するために、<span class="thesansmonocd_w5regular_">word</span>の最初の子音を取り除く必要があります。</p>
<pre class="pre"><code class="calibre9">    # 語頭の子音を分離
    prefixConsonants = ''
    while len(word) &gt; 0 and not word[0] in VOWELS:
        prefixConsonants += word[0]
        word = word[1:]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">word</span>の語頭から非アルファベットを除去したループと似たようなループを使います。ただし今回は<span class="thesansmonocd_w5regular_">prefixConsonants</span>という名前の変数に子音を保存します。</p>
<p class="tx">その語が子音で始まれば、その子音を<span class="thesansmonocd_w5regular_">prefixConsonants</span>に格納し、 <span class="thesansmonocd_w5regular_">word</span>の終わりにその子音と文字列<span class="thesansmonocd_w5regular_">'ay'</span>を結合します。それ以外の場合は、<span class="thesansmonocd_w5regular_">word</span>が母音で始まりますから、<span class="thesansmonocd_w5regular_">'yay'</span>と結合するだけでよいです。</p>
<pre class="pre"><code class="calibre9">    # ピッグ・ラテンの語尾を追加
    if prefixConsonants != '':
        word += prefixConsonants + 'ay'
    else:
        word += 'yay'
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">word</span>に<span class="thesansmonocd_w5regular_">word</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">word.lower()</span>で小文字を設定したことを思い出してください。<span class="thesansmonocd_w5regular_">word</span>がもともとはすべて大文字や先頭が大文字だったとしたら、<span class="thesansmonocd_w5regular_">word</span>を元の大文字に戻します。</p>
<pre class="pre"><code class="calibre9">    # 全部大文字または先頭が大文字を復元
    if wasUpper:
        word = word.upper()
    if wasTitle:
        word = word.title()
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">for</span>ループの最後で、元の語にあった非アルファベットをくっつけ、リスト<span class="thesansmonocd_w5regular_">pigLatin</span>に追加します。</p>
<pre class="pre"><code class="calibre9">    # 語頭と語末に非アルファベットを復元
    pigLatin.append(prefixNonLetters + word + suffixNonLetters)

# すべての単語を一つの文字列に連結
print(' '.join(pigLatin))
</code></pre>
<p class="tx">このループが終われば、<span class="thesansmonocd_w5regular_">join()</span>メソッドでこの文字列のリストを一つの文字列へと結合します。そして、その一つの文字列を<span class="thesansmonocd_w5regular_">print()</span>に渡し、画面上にピッグ・ラテンを表示します。</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec25">
<h3 class="h" id="calibre_link-1618"><span id="calibre_link-185"></span><span class="sans_futura_std_bold_b_">まとめ</span></h3>
<p class="tni">テキストは一般的なデータ形式であり、Pythonには文字列値に保存されたテキストを処理する便利な文字列メソッドがたくさんあります。インデックスやスライスに加えて、こうした文字列メソッドを多くのプログラムで使うことになるでしょう。</p>
<p class="tx">今書いているプログラムはそれほど洗練されているように見えません。画像や色がついているグラフィカルユーザーインターフェース（GUI）はありません。これまでのところは、<span class="thesansmonocd_w5regular_">print()</span>でテキストを表示して、<span class="thesansmonocd_w5regular_">input()</span>でユーザーがテキストを入力しました。しかし、クリップボードを経由すれば、大量のテキストを素早く入力できます。大量のテキストを操作するプログラムを書く際には、クリップボードを使うと便利です。こうしたテキストベースのプログラムにおしゃれなウィンドウやグラフィックスはありませんが、有用な作業を素早く終わらせられます。</p>
<p class="tx">大量のテキストを操作するもう一つの方法は、ハードドライブ上のファイルを直接読み書きすることです。その方法については<span>第10章</span>で説明します。</p>
<p class="tx">これでPythonプログラミングの基礎概念を学び終えました。本書の残りの部分で新しい概念に出会うでしょうが、作業を自動化できる便利なプログラムを書く準備はもう整っています。ここまでに学んだ基本概念から作られているちょっとしたPythonプログラム集を見たければ、私の<i class="calibre5">The Big Book of Small Python Projects</i> (No Starch Press, 2021)という別の本をご覧ください。それぞれのプログラムのソースコードを手で写し、いろいろいじってみてどういう挙動になるのか確かめてみてください。プログラムの動作を理解したら、自分でゼロからプログラムを再作成してみてください。ソースコードを正確に再現する必要はありません。プログラムがどのように実行されるかよりも、プログラムが何を実行するかを意識してください。</p>
<p class="tx">Pythonでウェブページをダウンロードしたり、スプレッドシートを更新したり、ショートメールを送ったりする方法がまだわからないと思われるかもしれません。それらはPythonのモジュールを使って実現します。別のプログラマが書いてくれたモジュールの関数を使うと、そうした作業が簡単にできます。次章では、実際に役立つ業務自動化プログラムを書きます。</p>
</section>
<section type="division" aria-labelledby="sec26">
<h3 class="h" id="calibre_link-1619"><span id="calibre_link-186"></span><span class="sans_futura_std_bold_b_">練習問題</span></h3>
<p class="listnumber">  1. エスケープ文字とは何ですか？</p>
<p class="listnumber">  2. エスケープ文字<span class="thesansmonocd_w5regular_">\n</span>と<span class="thesansmonocd_w5regular_">\t</span>はそれぞれ何を表していますか？</p>
<p class="listnumber">  3. 文字列中にバックスラッシュ文字<span class="thesansmonocd_w5regular_">\</span>を入れるにはどうすればよいですか？</p>
<p class="listnumber">  4. 文字列値<span class="thesansmonocd_w5regular_">"Howl's Moving Castle"</span>有効な文字列です。<span class="thesansmonocd_w5regular_">Howl's</span>のシングルクォートがエスケープされていないのに問題が生じないのはなぜですか？</p>
<p class="listnumber">  5. 文字列中に<span class="thesansmonocd_w5regular_">\n</span>を入れずに改行したい場合は、どうすればよいですか？</p>
<p class="listnumber">  6. 次の式はどのように評価されますか？</p>
<ul class="ul">
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Hello, world!'[1]</span></li>
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Hello, world!'[0:5]</span></li>
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Hello, world!'[:5]</span></li>
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Hello, world!'[3:]</span></li>
</ul>
<p class="listnumber"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1304" aria-label="181"></span>  7. 次の式はどのように評価されますか？</p>
<ul class="ul">
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Hello'.upper()</span></li>
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Hello'.upper().isupper()</span></li>
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Hello'.upper().lower()</span></li>
</ul>
<p class="listnumber">  8. 次の式はどのように評価されますか？</p>
<ul class="ul">
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'Remember, remember, the fifth of November.'.split()</span></li>
<li class="listbulletsub"><span class="thesansmonocd_w5regular_">'-'.join('There can be only one.'.split())</span></li>
</ul>
<p class="listnumber">  9. 右寄せ、左寄せ、中央寄せができる文字列メソッドは何ですか？</p>
<p class="listnumber">10. 文字列の両端から空白文字を除去するにはどうすればよいですか？</p>
</section>
<section type="division" aria-labelledby="sec27">
<h3 class="h" id="calibre_link-1620"><span id="calibre_link-187"></span><span class="sans_futura_std_bold_b_">練習プログラム：表形式の表示</span></h3>
<p class="tni">練習のために、リストのリスト（入れ子のリスト）を取って各列を右寄せしてきれいに表形式で表示する<span class="thesansmonocd_w5regular_">printTable()</span>という名前の関数を書いてください。内側のリストに入っている文字列の個数は同じであると想定してください。例えば次のような値です。</p>
<pre class="pre"><code class="calibre9">tableData = [['apples', 'oranges', 'cherries', 'banana'],
             ['Alice', 'Bob', 'Carol', 'David'],
             ['dogs', 'cats', 'moose', 'goose']]
</code></pre>
<p class="tx"><span class="thesansmonocd_w5regular_">printTable()</span>関数は次のように出力します。</p>
<pre class="pre"><code class="calibre9">   apples Alice  dogs
  oranges   Bob  cats
 cherries Carol moose
   banana David goose
</code></pre>
<p class="tx">ヒント：まず、列幅を決めるために、内側のリストの各列中で最も長い文字列を見つけなければなりません。各列の最大文字数（列幅）を整数のリストに格納します。そのために、<span class="thesansmonocd_w5regular_">printTable()</span>関数は、<span class="thesansmonocd_w5regular_">tableData</span>の内側のリスト数（列数）だけ<span class="thesansmonocd_w5regular_">0</span>を含むリストを作成する、 <span class="thesansmonocd_w5regular_">colWidths</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">[0] * len(tableData)</span>という行で開始します。このようにすれば、<span class="thesansmonocd_w5regular_">colWidths[0]</span>が<span class="thesansmonocd_w5regular_">tableData[0]</span>の最大文字数（列幅）を保持し、<span class="thesansmonocd_w5regular_">colWidths[1]</span>が<span class="thesansmonocd_w5regular_">tableData[1]</span>の最大文字数（列幅）を保持するといった形で、それぞれの列について最大文字数（列幅）を保持できます。<span class="thesansmonocd_w5regular_">colWidths</span>リストから最大文字数（列幅）を取得して、その文字数を文字列メソッド<span class="thesansmonocd_w5regular_">rjust()</span>に渡します。</p>
</section>
</section>
</div>


<div type="bodymatter" class="calibre" id="calibre_link-188">
<section type="part" role="doc-part" aria-labelledby="pt2">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1621" aria-label="183"></span>
<hgroup>
<h1 class="title" id="calibre_link-1622">
<span class="pn"><span class="sans_dogma_ot_bold_b_">第2部</span></span> <span class="pt"><span class="sans_dogma_ot_bold_b_">業務自動化</span></span>
</h1>
</hgroup>
</section>
</div>


</div>



</body></html>